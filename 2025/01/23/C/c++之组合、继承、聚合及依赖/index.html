<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>c++之组合、继承、聚合及依赖 | 易锦风的博客</title><meta name="author" content="formeasy"><meta name="copyright" content="formeasy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="c++之组合、继承、聚合及依赖"><meta property="og:type" content="article"><meta property="og:title" content="c++之组合、继承、聚合及依赖"><meta property="og:url" content="http://www.formeasy.cc/2025/01/23/C/c++%E4%B9%8B%E7%BB%84%E5%90%88%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E8%81%9A%E5%90%88%E5%8F%8A%E4%BE%9D%E8%B5%96/index.html"><meta property="og:site_name" content="易锦风的博客"><meta property="og:description" content="c++之组合、继承、聚合及依赖"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.formeasy.cc/img/cover.png"><meta property="article:published_time" content="2025-01-23T07:34:52.000Z"><meta property="article:modified_time" content="2025-01-23T09:08:32.272Z"><meta property="article:author" content="formeasy"><meta property="article:tag" content="C"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://www.formeasy.cc/img/cover.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.formeasy.cc/2025/01/23/C/c++%E4%B9%8B%E7%BB%84%E5%90%88%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E8%81%9A%E5%90%88%E5%8F%8A%E4%BE%9D%E8%B5%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{var e={set:(e,t,a)=>{a&&(a=Date.now()+864e5*a,localStorage.setItem(e,JSON.stringify({value:t,expiry:a})))},get:e=>{var t=localStorage.getItem(e);if(t){var{value:t,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return t;localStorage.removeItem(e)}}},t=(window.btf={saveToLocal:e,getScript:(o,n={})=>new Promise((e,t)=>{const a=document.createElement("script");a.src=o,a.async=!0,Object.entries(n).forEach(([e,t])=>a.setAttribute(e,t)),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),getCSS:(o,n)=>new Promise((e,t)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),addGlobalFn:(e,t,a=!1,o=window)=>{var n;e.startsWith("pjax")||((n=o.globalFn||{})[e]=n[e]||{},n[e][a||Object.keys(n[e]).length]=t,o.globalFn=n)}},()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")}),a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")},o=(btf.activateDarkMode=t,btf.activateLightMode=a,e.get("theme")),t=("dark"===o?t():"light"===o&&a(),e.get("aside-status"));void 0!==t&&document.documentElement.classList.toggle("hide-aside","hide"===t);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"c++之组合、继承、聚合及依赖",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,isShuoshuo:!1}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="易锦风的博客" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly-icon.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">216</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/cover.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/icon.png" alt="Logo"><span class="site-name">易锦风的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">c++之组合、继承、聚合及依赖</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">c++之组合、继承、聚合及依赖</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-23T07:34:52.000Z" title="发表于 2025-01-23 15:34:52">2025-01-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-23T09:08:32.272Z" title="更新于 2025-01-23 17:08:32">2025-01-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BE%E8%AE%A1/">设计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>3分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>在学习c++的过程中相信大家对这几个概念都不陌生。 c++中一些常用的设计模式都是由这几种特性组合而成。本文再从整体对这个概念或者特性进行简要的介绍。</p><h2 id="组合"><a class="markdownIt-Anchor" href="#组合"></a> 组合</h2><p>c++中类之间的一种关系叫做&quot;has-a&quot;的关系。这种关系表示的是一个类中包含另一类的对象，体现了“有一个”的关系。这个被包含的类一般以实例对象的形式存在，而非指针对象的形式存在。请看下面的示例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;引擎启动&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Engine engine;  <span class="comment">//这里以实例的形式存在，而非指针，在类关系中是组合的关系</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">startCar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		engine.<span class="built_in">start</span>();  <span class="comment">//启动引擎</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合特点"><a class="markdownIt-Anchor" href="#组合特点"></a> 组合特点</h3><ul><li>组合关系下被包含的类无法独立存在，即部分不能脱离整体存在</li><li>被包含的类实例生命周期与包含类实例绑定</li><li>这两个类是强拥有关系，个人理解是通过实例对象实现这个隐含的作用的，如果是指针对象的那么就不能理解为强拥有关系。</li></ul><h2 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h2><p>继承关系是c++中特别重要的一种关系，它同样是用于描述两个类关系。用一个英文描述继承的就是&quot;is-a&quot;，核心含义是一个类是另外一个类的特殊类型，即“是一个”的关系。具体示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span>   <span class="comment">//虚函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;动物的叫声&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="keyword">class</span> <span class="title class_">Animal</span>  <span class="comment">//继承关系，狗也是动物的一种，Dog类是Animal的一种特殊类型</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;汪汪&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承特点"><a class="markdownIt-Anchor" href="#继承特点"></a> 继承特点</h3><ul><li>强耦合关系</li><li>子类继承父类的所有特性</li><li>支持多态，在继承中这个多态是运行时多态；同样有编译时多态，即一个同一个函数或者方法可以定义不同的参数，这是编译时多态，也叫静态多态。</li></ul><h2 id="聚合"><a class="markdownIt-Anchor" href="#聚合"></a> 聚合</h2><p>聚合也是c++中类之间关系的一种，这种关系与组合类似，也是&quot;has-a&quot;关系的一种。区别是在聚合关系下被包含对象的存在是以指针对象的形式存在的。请看下面的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		std::string name;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">School</span>  <span class="comment">//学校类</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::vector&lt;Student*&gt; students;  <span class="comment">//学生对象的集合,聚合关系，注意这里描述学生的类型是Student*</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">addStudent</span><span class="params">(Student* stu)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			students.<span class="built_in">push_back</span>(stu);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="聚合特点"><a class="markdownIt-Anchor" href="#聚合特点"></a> 聚合特点</h3><ul><li>松耦合的关系，比组合的松耦合还要送，也可以叫做弱拥有关系</li><li>被包含的类可以独立存在，即部分可以脱离整体存在</li><li>生命周期独立</li></ul><h2 id="依赖关系"><a class="markdownIt-Anchor" href="#依赖关系"></a> 依赖关系</h2><p>除了上面的3中关系外，还有一种依赖关系，那怎么叫做依赖关系呢？相信大家也有到类似的情况，一个类使用另外一个类时仅在函数参数中使用。这种情况明显不属于上面的3种关系，所以这里就有了依赖关系。那都有哪些情况属于依赖关系呢？</p><ul><li>函数参数</li><li>作为返回类型</li><li>在成员函数中以局部变量出现</li><li>静态方法调用</li></ul><p>具体示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Document doc)</span> </span>&#123;  <span class="comment">//参数依赖</span></span><br><span class="line">		<span class="comment">// 使用 Document 对象</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Report <span class="title">createReport</span><span class="params">()</span> </span>&#123;    <span class="comment">// 返回类型依赖</span></span><br><span class="line">		Report report;         <span class="comment">// 局部变量依赖</span></span><br><span class="line">		<span class="keyword">return</span> report;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Logger::<span class="built_in">log</span>(<span class="string">&quot;Processing&quot;</span>);  <span class="comment">// 静态方法调用依赖</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="依赖关系特点"><a class="markdownIt-Anchor" href="#依赖关系特点"></a> 依赖关系特点</h3><ul><li>这是一种最弱的关系，关系强度如下:依赖关系&lt;聚合关系&lt;组合关系&lt;继承关系。</li></ul><h2 id="设计原则"><a class="markdownIt-Anchor" href="#设计原则"></a> 设计原则</h2><ul><li>优先使用组合而非继承</li><li>合理使用继承</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>c++中非常重要的设计模式，就是对上面的几种关系的组合运用。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://www.formeasy.cc">formeasy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.formeasy.cc/2025/01/23/C/c++%E4%B9%8B%E7%BB%84%E5%90%88%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E8%81%9A%E5%90%88%E5%8F%8A%E4%BE%9D%E8%B5%96/">http://www.formeasy.cc/2025/01/23/C/c++之组合、继承、聚合及依赖/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://www.formeasy.cc" target="_blank">易锦风的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a></div><div class="post-share"><div class="social-share" data-image="/img/cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/01/24/ROS/ROS2%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" title="ROS2简介与基本使用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/24/ROS/ROS2%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/3ca4d9399b3e53e675dbfd863d98611c.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">ROS2简介与基本使用</div></div><div class="info-2"><div class="info-item-1">1. ROS2 介绍与安装 1.1 ROS2 的历史 ROS（Robot Operating System，机器人操作系统），但 ROS 本身并不是一个操作系统，而是可以安装在现在已有的操作系统上（Linux、Windows、Mac）的软件库和工具集 ROS 出生于 2007 年，ROS 的出现解决了机器人各个组件之间的通信问题，同时基于 ROS 完善的通信机制，越来越多的优秀的机器人算法集成到了 ROS 中来 现在的 ROS 功能已经变得非常的丰富和强大。但随着对 ROS 功能上要求越来越多，一些原始的架构和设计不能够满足目前的使用需求，这也是 ROS2 出现的原因 1.1.1 ROS 的作用 做一个机器人需要涉及到多个部分，而且这些部分之间还要进行通信，如果想要整个机器人可以跑起来，那么必须要有一个东西将下面的几个部分合理的连接到一起，这个东西就是 ROS 感知部分：激光雷达、深度相机、IMU、里程计、碰撞感知、建图 决策部分：路径规划（navigation）算法、定位算法 控制部分：轮子驱动 1.1.2 为什么需要 ROS2 2007 年 ROS...</div></div></div></a><a class="pagination-related" href="/2025/01/23/EA/%E7%94%A8Enterprise%20Architect%E7%94%BB%E7%B1%BB%E5%9B%BE%E5%92%8C%E9%A1%BA%E5%BA%8F%E5%9B%BE/" title="用Enterprise Architect画类图和顺序图"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/01/23/EA/%E7%94%A8Enterprise%20Architect%E7%94%BB%E7%B1%BB%E5%9B%BE%E5%92%8C%E9%A1%BA%E5%BA%8F%E5%9B%BE/bVxO8f.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">用Enterprise Architect画类图和顺序图</div></div><div class="info-2"><div class="info-item-1">新建一个Project 没什么好说的，“文件-新建项目”，然后选择保存位置就好了，模式的话由于我喜欢一个包一张图所以一般都选择“新建包的时候同时新建图”。 会弹出一个模型向导的对话框， 是给你导入模板的，我不需要，所以都不选直接点确定。 在项目浏览器里新增包，一个图一个包比较舒服： UML的图就主要在UML Structural和UML Behavioral两个包里： 有时候你新建在图里的元素删除了只是在图里删除而没有在包里删除，作为一个强迫症，总是要多动手删一次= = EA还提供一些像Word那样的操作，比如这两个按钮可以修改元素的层次关系： ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/11/C/C++11%20%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%9Astdcopy_if%20%E4%B8%8E%20stdcopy_n/" title="C++11 算法详解：std::copy_if 与 std::copy_n"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-11</div><div class="info-item-2">C++11 算法详解：std::copy_if 与 std::copy_n</div></div><div class="info-2"><div class="info-item-1">引言 C++11 标准为算法库带来了诸多增强，其中 std::copy_if 和 std::copy_n 作为 std::copy 的补充，为元素复制操作提供了更精细的控制。这两个算法不仅简化了代码逻辑，还提升了可读性和性能。本文将深入探讨这两个算法的实现细节、使用场景及最佳实践，帮助开发者在实际项目中正确高效地应用它们。 std::copy_if：条件筛选复制 函数原型 12template&lt; class InputIt, class OutputIt, class UnaryPred &gt;OutputIt copy_if( InputIt first, InputIt last, OutputIt d_first, UnaryPred pred ); 核心功能 std::copy_if 从输入范围 [first, last) 中复制满足谓词 pred 的元素到目标范围（始于 d_first），并保持元素的相对顺序。该算法在 C++11 中引入，是对传统 std::copy 的条件化扩展。 ...</div></div></div></a><a class="pagination-related" href="/2025/07/10/C/C++%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%81/" title="C++动态分配内存知识点！"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-10</div><div class="info-item-2">C++动态分配内存知识点！</div></div><div class="info-2"><div class="info-item-1">1.动态分配内存的思想 动态分配内存是指在程序运行时根据需要动态地分配内存空间。这相对于静态分配内存来说，静态分配内存是在编译时固定地分配内存空间，而动态分配内存可以在程序运行期间根据实际需求进行内存的申请和释放，以提高内存的利用率和灵活性。 2.动态分配内存的概念 动态分配内存的概念包括以下几个方面： 2.1内存分配函数 动态分配内存需要使用内存分配函数，如C语言中的malloc()、calloc()、realloc()等，这些函数可以根据需要在运行时动态地分配一块连续的内存空间。 2.2动态内存的申请和释放 使用内存分配函数可以申请一块指定大小的内存空间，申请的内存空间可以在程序运行期间使用。使用完毕后，可以使用释放函数将内存空间释放，以便其他程序继续使用。 2.3内存碎片问题 动态分配内存可能会导致内存碎片问题。当频繁地进行内存分配和释放操作时，可能会在内存中留下一些未被使用的小块内存，这些小块内存无法被再次利用，导致内存的浪费。为了解决内存碎片问题，可以使用内存管理算法来进行内存的分配和释放操作。 ...</div></div></div></a><a class="pagination-related" href="/2025/07/10/C/C++%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="C++之红黑树认识与实现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/07/10/C/C++%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/d6e48fbd9ca54c63aa684f0bcbe9ccf5.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-10</div><div class="info-item-2">C++之红黑树认识与实现</div></div><div class="info-2"><div class="info-item-1">一.红黑树的概念 红⿊树是⼀棵⼆叉搜索树，他的每个结点增加⼀个存储位来表⽰结点的颜⾊，可以是红⾊或者⿊⾊。通过对任何⼀条从根到叶⼦的路径上各个结点的颜⾊进⾏约束，红⿊树确保没有⼀条路径会⽐其他路径⻓出2倍，因⽽是接近平衡的。 红黑树的结构 123456789101112131415161718192021222324252627282930313233343536// 枚举值表⽰颜⾊ enum Colour&#123; RED, BLACK&#125;;template&lt;class K, class V&gt;struct RBTreeNode&#123; // 这⾥更新控制平衡也要加⼊parent指针 pair&lt;K, V&gt; _kv; RBTreeNode&lt;K, V&gt;* _left; RBTreeNode&lt;K, V&gt;* _right; RBTreeNode&lt;K, V&gt;* _parent; Colour _col; RBTreeNode(const pair&lt;K, V&gt;&amp; kv) :_kv(kv) ,...</div></div></div></a><a class="pagination-related" href="/2025/07/11/C/vector%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/" title="vector的详细讲解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/07/11/C/vector%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/53d1d2e536204e609dc694bcb054ce9c.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-11</div><div class="info-item-2">vector的详细讲解</div></div><div class="info-2"><div class="info-item-1">1.vector的介绍及使用 1.1 vector的介绍 1. vector 是表示可变大小数组的序列容器。 2. 就像数组一样， vector 也采用的连续存储空间来存储元素。也就是意味着可以采用下标对 vector 的元素 进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自 动处理。 3. 本质讲， vector 使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小 为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是 一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector 并不会每次都重新分配大 小。 4. vector 分配空间策略： vector 会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存 储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是 对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。 5. 因此， vector...</div></div></div></a><a class="pagination-related" href="/2025/07/21/C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/" title="内存管理基础：数据结构的存储方式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/07/21/C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/6dbd55eda53d6550a09ffc9da8295446.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-21</div><div class="info-item-2">内存管理基础：数据结构的存储方式</div></div><div class="info-2"><div class="info-item-1">内存管理基础：数据结构的存储方式 想象一下你正在整理你的衣柜。有些衣服你会折叠整齐地放在抽屉里（连续存储），有些则挂在衣架上分散在衣柜各处（链式存储。计算机内存管理数据的方式其实和这个场景非常相似。今天，我们就来探讨一下数据结构在内存中的不同存储方式，以及它们各自的优缺点。 1. 连续存储结构 理解了衣柜的比喻后，我们来看看计算机中最基础的存储方式——连续存储。这种存储方式就像把衣服一件件紧密地叠放在抽屉里，每件衣服占据固定大小的空间，并且按照顺序排列。 1.1 数组的存储方式 数组是最典型的连续存储结构。让我们通过一个简单的例子来看看数组在内存中是如何存储的： 1int arr[5] = &#123;10, 20, 30, 40, 50&#125;; 上述代码定义了一个包含5个整数的数组。在内存中，这些元素会被连续地存储在一起。 以上流程图说明了数组在内存中的连续存储方式，每个元素占据4字节空间 1.2...</div></div></div></a><a class="pagination-related" href="/2025/04/30/RPC/GRPC%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="GRPC 快速入门"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-30</div><div class="info-item-2">GRPC 快速入门</div></div><div class="info-2"><div class="info-item-1">1. 背景介绍 gRPC全称Google Remote Procedure Call. 它是一种基于Protobuf buffer 格式的高效的通讯协议。与许多 RPC 系统一样，gRPC 基于定义服务的理念，指定可以远程调用的方法及其参数和返回类型。在服务器端，服务器实现此接口并运行 gRPC 服务器以处理客户端调用。在客户端，客户端具有一个存根（在某些语言中称为客户端），它提供与服务器相同的 方法。 2. 快速入门 安装 cmake 您需要 cmake 的 3.13 版或更高版本。请按照以下说明进行安装 Linux 1sudo apt install -y cmake macOS 1brew install cmake 安装其他必需工具 Linux 1sudo apt install -y build-essential autoconf libtool pkg-config macOS 1brew install autoconf automake libtool pkg-config 克隆 grpc 仓库 设置安装路径 123export...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly-icon.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">formeasy</div><div class="author-info-description">专注互联网和软件技术</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">216</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/formeasy"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/formeasy" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:formeasy@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">用学习，面对遭遇的变化；用斗志，面对每天的挫折；用坚持，面对失去的动力!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number">1.</span> <span class="toc-text">组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">组合特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">继承特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88"><span class="toc-number">3.</span> <span class="toc-text">聚合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.</span> <span class="toc-text">聚合特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">4.</span> <span class="toc-text">依赖关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">依赖关系特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">5.</span> <span class="toc-text">设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/10/03/Elasticsearch/Elasticsearch%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/" title="Elasticsearch知识点详细总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Elasticsearch知识点详细总结"></a><div class="content"><a class="title" href="/2025/10/03/Elasticsearch/Elasticsearch%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/" title="Elasticsearch知识点详细总结">Elasticsearch知识点详细总结</a><time datetime="2025-10-03T13:42:57.000Z" title="发表于 2025-10-03 21:42:57">2025-10-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/03/Other/%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B4%A0%E6%9D%90%E6%A0%BC%E5%BC%8F%E5%AE%8C%E6%95%B4%E6%B8%85%E5%8D%95%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E3%80%81%E5%85%A8%E6%A0%88%E5%8F%8A%E5%90%84%E9%A2%86%E5%9F%9F%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%89/" title="开发中常用素材格式完整清单（适用于前后端、全栈及各领域研发工程师）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="开发中常用素材格式完整清单（适用于前后端、全栈及各领域研发工程师）"></a><div class="content"><a class="title" href="/2025/10/03/Other/%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B4%A0%E6%9D%90%E6%A0%BC%E5%BC%8F%E5%AE%8C%E6%95%B4%E6%B8%85%E5%8D%95%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E3%80%81%E5%85%A8%E6%A0%88%E5%8F%8A%E5%90%84%E9%A2%86%E5%9F%9F%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%89/" title="开发中常用素材格式完整清单（适用于前后端、全栈及各领域研发工程师）">开发中常用素材格式完整清单（适用于前后端、全栈及各领域研发工程师）</a><time datetime="2025-10-03T13:29:38.000Z" title="发表于 2025-10-03 21:29:38">2025-10-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/21/ollama/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20RAG%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/" title="深入浅出 RAG：原理、流程与代码实战"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="深入浅出 RAG：原理、流程与代码实战"></a><div class="content"><a class="title" href="/2025/09/21/ollama/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20RAG%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/" title="深入浅出 RAG：原理、流程与代码实战">深入浅出 RAG：原理、流程与代码实战</a><time datetime="2025-09-21T03:22:29.000Z" title="发表于 2025-09-21 11:22:29">2025-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/17/Python/%E4%BD%BF%E7%94%A8WinSW%E6%8A%8Anginx%E5%81%9A%E6%88%90windows%E6%9C%8D%E5%8A%A1/" title="使用WinSW把nginx做成windows服务"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="使用WinSW把nginx做成windows服务"></a><div class="content"><a class="title" href="/2025/09/17/Python/%E4%BD%BF%E7%94%A8WinSW%E6%8A%8Anginx%E5%81%9A%E6%88%90windows%E6%9C%8D%E5%8A%A1/" title="使用WinSW把nginx做成windows服务">使用WinSW把nginx做成windows服务</a><time datetime="2025-09-17T05:58:13.000Z" title="发表于 2025-09-17 13:58:13">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/17/Python/%E4%BD%BF%E7%94%A8NSSM%E5%B0%86.exe%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%E6%88%90windows%E6%9C%8D%E5%8A%A1/" title="使用NSSM将.exe程序安装成windows服务"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/09/17/Python/%E4%BD%BF%E7%94%A8NSSM%E5%B0%86.exe%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%E6%88%90windows%E6%9C%8D%E5%8A%A1/2447777-20240506104400143-1336746940.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="使用NSSM将.exe程序安装成windows服务"></a><div class="content"><a class="title" href="/2025/09/17/Python/%E4%BD%BF%E7%94%A8NSSM%E5%B0%86.exe%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%E6%88%90windows%E6%9C%8D%E5%8A%A1/" title="使用NSSM将.exe程序安装成windows服务">使用NSSM将.exe程序安装成windows服务</a><time datetime="2025-09-17T05:52:51.000Z" title="发表于 2025-09-17 13:52:51">2025-09-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By formeasy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(async()=>{window.katex_js_css||(window.katex_js_css=!0,await btf.getCSS("https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"),await btf.getScript("https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js")),document.querySelectorAll("#article-container .katex").forEach(t=>t.classList.add("katex-show"))})()</script><script>(()=>{var e=()=>{var e;0!==(e=document.querySelectorAll("pre > code.mermaid")).length&&e.forEach(e=>{var t=document.createElement("pre"),n=(t.className="mermaid-src",t.hidden=!0,t.textContent=e.textContent,document.createElement("div"));n.className="mermaid-wrap",n.appendChild(t),e.parentNode.replaceWith(n)});const t=document.querySelectorAll("#article-container .mermaid-wrap");0!==t.length&&(e=()=>{{var e=t;window.loadMermaid=!0;const a="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";e.forEach((e,t)=>{const n=e.firstElementChild;e=`%%{init:{ 'theme':'${a}'}}%%
`+n.textContent,t=mermaid.render("mermaid-"+t,e);const d=e=>{n.insertAdjacentHTML("afterend",e)};"string"==typeof t?d(t):t.then(({svg:e})=>d(e))})}},btf.addGlobalFn("themeChange",e,"mermaid"),window.loadMermaid?e():btf.getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(e))};btf.addGlobalFn("encrypt",e,"mermaid"),window.pjax?e():document.addEventListener("DOMContentLoaded",e)})()</script><script>(()=>{const a=GLOBAL_CONFIG_SITE.isShuoshuo,s=null,n=t=>"dark"===t?"dark":"light";var t=(t=document,e)=>{e=a?{"data-mapping":"specific","data-term":e}:{"data-mapping":(s,"pathname")},e=(t=>{const a=document.createElement("script");return Object.entries(t).forEach(([t,e])=>{a.setAttribute(t,e)}),a})({src:"https://giscus.app/client.js","data-repo":"formeasy/blog","data-repo-id":"R_kgDOJ2sA5A","data-category-id":"DIC_kwDOJ2sA5M4CktKh","data-theme":n(document.documentElement.getAttribute("data-theme")),"data-reactions-enabled":"1",crossorigin:"anonymous",async:!0,...s,...e});t.querySelector("#giscus-wrap").appendChild(e),a&&(window.shuoshuoComment.destroyGiscus=()=>{t.children.length&&(t.innerHTML="",t.classList.add("no-comment"))})};btf.addGlobalFn("themeChange",t=>{var e=document.querySelector("#giscus-wrap iframe");e&&(t={giscus:{setConfig:{theme:n(t)}}},e.contentWindow.postMessage(t,"https://giscus.app"))},"giscus"),a?window.shuoshuoComment={loadComment:t}:t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="请输入搜索关键字" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>