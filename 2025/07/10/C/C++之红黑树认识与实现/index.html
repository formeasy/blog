<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>C++之红黑树认识与实现 | 易锦风的博客</title><meta name="author" content="formeasy"><meta name="copyright" content="formeasy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++之红黑树认识与实现"><meta property="og:type" content="article"><meta property="og:title" content="C++之红黑树认识与实现"><meta property="og:url" content="http://www.formeasy.cc/2025/07/10/C/C++%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/index.html"><meta property="og:site_name" content="易锦风的博客"><meta property="og:description" content="C++之红黑树认识与实现"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.formeasy.cc/2025/07/10/C/C++%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/d6e48fbd9ca54c63aa684f0bcbe9ccf5.png"><meta property="article:published_time" content="2025-07-10T01:06:20.000Z"><meta property="article:modified_time" content="2025-07-10T01:24:22.769Z"><meta property="article:author" content="formeasy"><meta property="article:tag" content="C"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://www.formeasy.cc/2025/07/10/C/C++%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/d6e48fbd9ca54c63aa684f0bcbe9ccf5.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.formeasy.cc/2025/07/10/C/C++%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{var e={set:(e,t,a)=>{a&&(a=Date.now()+864e5*a,localStorage.setItem(e,JSON.stringify({value:t,expiry:a})))},get:e=>{var t=localStorage.getItem(e);if(t){var{value:t,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return t;localStorage.removeItem(e)}}},t=(window.btf={saveToLocal:e,getScript:(o,n={})=>new Promise((e,t)=>{const a=document.createElement("script");a.src=o,a.async=!0,Object.entries(n).forEach(([e,t])=>a.setAttribute(e,t)),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),getCSS:(o,n)=>new Promise((e,t)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),addGlobalFn:(e,t,a=!1,o=window)=>{var n;e.startsWith("pjax")||((n=o.globalFn||{})[e]=n[e]||{},n[e][a||Object.keys(n[e]).length]=t,o.globalFn=n)}},()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")}),a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")},o=(btf.activateDarkMode=t,btf.activateLightMode=a,e.get("theme")),t=("dark"===o?t():"light"===o&&a(),e.get("aside-status"));void 0!==t&&document.documentElement.classList.toggle("hide-aside","hide"===t);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"C++之红黑树认识与实现",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,isShuoshuo:!1}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="易锦风的博客" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly-icon.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">247</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 资源链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/2025/07/10/C/C++之红黑树认识与实现/d6e48fbd9ca54c63aa684f0bcbe9ccf5.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/icon.png" alt="Logo"><span class="site-name">易锦风的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">C++之红黑树认识与实现</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 资源链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++之红黑树认识与实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-10T01:06:20.000Z" title="发表于 2025-07-10 09:06:20">2025-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-10T01:24:22.769Z" title="更新于 2025-07-10 09:24:22">2025-07-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="一红黑树的概念"><a class="markdownIt-Anchor" href="#一红黑树的概念"></a> 一.红黑树的概念</h2><p>红⿊树是⼀棵⼆叉搜索树，他的每个结点增加⼀个存储位来表⽰结点的颜⾊，可以是红⾊或者⿊⾊。通过对任何⼀条从根到叶⼦的路径上各个结点的颜⾊进⾏约束，红⿊树确保没有⼀条路径会⽐其他路径⻓出2倍，因⽽是接近平衡的。</p><h3 id="红黑树的结构"><a class="markdownIt-Anchor" href="#红黑树的结构"></a> 红黑树的结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举值表⽰颜⾊ </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Colour</span></span><br><span class="line">&#123;</span><br><span class="line"> RED,</span><br><span class="line"> BLACK</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBTreeNode</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 这⾥更新控制平衡也要加⼊parent指针 </span></span><br><span class="line"> pair&lt;K, V&gt; _kv;</span><br><span class="line"> RBTreeNode&lt;K, V&gt;* _left;</span><br><span class="line"> RBTreeNode&lt;K, V&gt;* _right;</span><br><span class="line"> RBTreeNode&lt;K, V&gt;* _parent;</span><br><span class="line"> Colour _col;</span><br><span class="line"> <span class="built_in">RBTreeNode</span>(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span><br><span class="line"> :_kv(kv)</span><br><span class="line"> , _left(<span class="literal">nullptr</span>)</span><br><span class="line"> , _right(<span class="literal">nullptr</span>)</span><br><span class="line"> , _parent(<span class="literal">nullptr</span>)</span><br><span class="line"> &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RBTree</span>&#123;</span><br><span class="line"> <span class="keyword">typedef</span> RBTreeNode&lt;K, V&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> Node* _root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二红黑树的定义与特性"><a class="markdownIt-Anchor" href="#二红黑树的定义与特性"></a> 二.红黑树的定义与特性</h2><p>红黑树是一种自平衡的二叉查找树，它满足以下五条基本性质：</p><ol><li><strong>节点是红色或黑色</strong>：每个节点都有一个颜色属性，红色或黑色。</li><li><strong>根节点是黑色</strong>：树的根节点必须是黑色。</li><li><strong>叶子节点是黑色</strong>：叶子节点（即空节点或<code>NULL</code>节点）是黑色。</li><li><strong>红色节点的子节点是黑色</strong>：如果一个节点是红色，则它的两个子节点都是黑色。</li><li><strong>从任意节点到其每个叶子的所有路径都包含相同数量的黑色节点</strong>：这确保了树的平衡性。</li></ol><p>这些性质保证了红黑树在插入和删除操作后能够保持大致平衡，从而使得查找、插入和删除操作的时间复杂度都能保持在(O(log n))。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="d6e48fbd9ca54c63aa684f0bcbe9ccf5.png" alt="在这里插入图片描述"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="57bb4dc3a4f0472b9c5ecf1c2642799c.png" alt="在这里插入图片描述"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="e98c05a4313d4c4ca8556b4c106ba207.png" alt="在这里插入图片描述"></p><h3 id="一红黑树的插入操作"><a class="markdownIt-Anchor" href="#一红黑树的插入操作"></a> 一.红黑树的插入操作</h3><p>插入操作是红黑树中最复杂的部分之一。插入一个新节点后，可能会破坏红黑树的性质，因此需要通过一系列的调整来恢复这些性质。插入操作可以分为以下几个步骤：</p><h4 id="1-插入节点"><a class="markdownIt-Anchor" href="#1-插入节点"></a> 1. 插入节点</h4><p>首先，将新节点插入到红黑树中，就像在普通二叉查找树中插入一样。新插入的节点会被标记为红色，因为插入红色节点比插入黑色节点更容易保持树的平衡。</p><h4 id="2-修复红黑树"><a class="markdownIt-Anchor" href="#2-修复红黑树"></a> 2. 修复红黑树</h4><p>插入红色节点后，可能会违反红黑树的性质4（红色节点的子节点是黑色）。因此，需要通过以下几种情况进行调整：</p><ul><li><p><strong>情况1：新节点的父节点是黑色</strong><br>这种情况下，插入的红色节点不会破坏红黑树的性质，无需进行任何调整。</p></li><li><p><strong>情况2：新节点的父节点和叔叔节点都是红色</strong><br>这种情况下，将父节点和叔叔节点变为黑色，祖父节点变为红色。然后，将祖父节点作为新的当前节点，继续向上调整。</p></li><li><p><strong>情况3：新节点的父节点是红色，叔叔节点是黑色或为空</strong><br>这种情况下，不仅仅需要变色，还需要进行旋转来调整。</p></li></ul><h4 id="插入操作的步骤"><a class="markdownIt-Anchor" href="#插入操作的步骤"></a> 插入操作的步骤</h4><h4 id="1-插入新节点"><a class="markdownIt-Anchor" href="#1-插入新节点"></a> 1. 插入新节点</h4><ul><li>如果树为空（<code>_root == nullptr</code>），直接创建一个黑色节点作为根节点并返回。</li><li>如果树不为空，从根节点开始，通过比较键值来找到插入位置。如果键值已经存在，则返回<code>false</code>，表示插入失败。</li><li>找到插入位置后，创建一个红色节点（新节点默认为红色），并将其插入到合适的位置（作为某个节点的左子节点或右子节点）。</li></ul><h4 id="2-修复红黑树的性质"><a class="markdownIt-Anchor" href="#2-修复红黑树的性质"></a> 2. 修复红黑树的性质</h4><p>插入红色节点后，可能会违反红黑树的性质（尤其是第4条性质：不能有两个连续的红色节点）。因此需要通过旋转和变色操作来修复。</p><h4 id="修复逻辑"><a class="markdownIt-Anchor" href="#修复逻辑"></a> 修复逻辑</h4><ul><li><strong>循环条件</strong>：只要当前节点的父节点是红色，就需要进行修复。</li><li><strong>祖父节点和叔叔节点</strong>：<ul><li>祖父节点是当前节点的父节点的父节点。</li><li>叔叔节点是祖父节点的另一个子节点（与父节点不同）。</li></ul></li></ul><h4 id="修复情况"><a class="markdownIt-Anchor" href="#修复情况"></a> 修复情况</h4><ol><li><p><strong>叔叔节点存在且为红色</strong>：</p><ul><li>父节点和叔叔节点都变色为黑色。</li><li>祖父节点变色为红色。</li><li>将当前节点更新为祖父节点，继续向上检查。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="8173e5abe9de46b4918dcce67448046b.png" alt="在这里插入图片描述"></li></ul></li><li><p><strong>叔叔节点不存在或者为黑色</strong>：</p><ul><li>如果父节点是祖父节点的左子节点：<ul><li>如果当前节点是父节点的左子节点：<ul><li>右旋祖父节点。</li><li>父节点变色为黑色，祖父节点变色为红色。</li></ul></li><li>如果当前节点是父节点的右子节点：<ul><li>左旋父节点。</li><li>右旋祖父节点。</li><li>当前节点变色为黑色，祖父节点变色为红色。</li></ul></li></ul></li><li>如果父节点是祖父节点的右子节点：<ul><li>如果当前节点是父节点的右子节点：<ul><li>左旋祖父节点。</li><li>父节点变色为黑色，祖父节点变色为红色。</li></ul></li><li>如果当前节点是父节点的左子节点：<ul><li>右旋父节点。</li><li>左旋祖父节点。</li><li>当前节点变色为黑色，祖父节点变色为红色。</li></ul></li></ul></li></ul><p>单旋：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="78afdf364740493bba91f4c99c1cd71b.png" alt=""></p><p>双旋：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="050539e173b14306b63c9002f4fd7a67.png" alt=""></p></li></ol><h4 id="3-根节点的颜色"><a class="markdownIt-Anchor" href="#3-根节点的颜色"></a> 3. 根节点的颜色</h4><ul><li>最后，确保根节点是黑色。</li></ul><h4 id="代码逻辑解析"><a class="markdownIt-Anchor" href="#代码逻辑解析"></a> 代码逻辑解析</h4><ul><li><strong>插入新节点</strong>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_root == nullptr)</span><br><span class="line">&#123;</span><br><span class="line">    _root = new Node(kv);</span><br><span class="line">    _root-&gt;_col = BLACK;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>如果树为空，直接创建一个黑色的根节点。
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node* parent = nullptr;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;_kv.first &lt; kv.first)</span><br><span class="line">    &#123;</span><br><span class="line">        parent = cur;</span><br><span class="line">        cur = cur-&gt;_right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_kv.first &gt; kv.first)</span><br><span class="line">    &#123;</span><br><span class="line">        parent = cur;</span><br><span class="line">        cur = cur-&gt;_left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>从根节点开始，通过比较键值找到插入位置。如果键值已存在，返回`false`。
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cur = new Node(kv);</span><br><span class="line">cur-&gt;_col = RED;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_kv.first &lt; kv.first)</span><br><span class="line">&#123;</span><br><span class="line">    parent-&gt;_right = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    parent-&gt;_left = cur;</span><br><span class="line">&#125;</span><br><span class="line">cur-&gt;_parent = parent;</span><br></pre></td></tr></table></figure><pre><code>创建一个红色的新节点，并将其插入到合适的位置。
</code></pre><ul><li><strong>修复红黑树性质</strong>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (parent &amp;&amp; parent-&gt;_col == RED)</span><br><span class="line">&#123;</span><br><span class="line">    Node* grandfather = parent-&gt;_parent;</span><br><span class="line">    <span class="keyword">if</span> (parent == grandfather-&gt;_left)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* uncle = grandfather-&gt;_right;</span><br><span class="line">        <span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_col == RED)</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_col = uncle-&gt;_col = BLACK;</span><br><span class="line">            grandfather-&gt;_col = RED;</span><br><span class="line">            cur = grandfather;</span><br><span class="line">            parent = cur-&gt;_parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == parent-&gt;_left)</span><br><span class="line">            &#123;</span><br><span class="line">                RotateR(grandfather);</span><br><span class="line">                parent-&gt;_col = BLACK;</span><br><span class="line">                grandfather-&gt;_col = RED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                RotateL(parent);</span><br><span class="line">                RotateR(grandfather);</span><br><span class="line">                cur-&gt;_col = BLACK;</span><br><span class="line">                grandfather-&gt;_col = RED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node* uncle = grandfather-&gt;_left;</span><br><span class="line">        <span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_col == RED)</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;_col = uncle-&gt;_col = BLACK;</span><br><span class="line">            grandfather-&gt;_col = RED;</span><br><span class="line">            cur = grandfather;</span><br><span class="line">            parent = cur-&gt;_parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == parent-&gt;_right)</span><br><span class="line">            &#123;</span><br><span class="line">                RotateL(grandfather);</span><br><span class="line">                parent-&gt;_col = BLACK;</span><br><span class="line">                grandfather-&gt;_col = RED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                RotateR(parent);</span><br><span class="line">                RotateL(grandfather);</span><br><span class="line">                cur-&gt;_col = BLACK;</span><br><span class="line">                grandfather-&gt;_col = RED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据父节点和叔叔节点的颜色，以及当前节点的位置，选择合适的旋转和变色操作来修复红黑树的性质。</p><ul><li><strong>确保根节点为黑色</strong>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">        _root-&gt;_col = BLACK;</span><br><span class="line">```    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### 二.红黑树的删除操作（作为了解即可）</span><br><span class="line"></span><br><span class="line">删除操作比插入操作更为复杂，因为它可能会破坏红黑树的平衡。删除操作可以分为以下几个步骤：</span><br><span class="line"></span><br><span class="line">#### <span class="number">1</span>\. 删除节点</span><br><span class="line"></span><br><span class="line">首先，找到需要删除的节点。如果该节点有两个子节点，则需要找到它的后继节点（右子树中的最小节点）来替换它。然后，将该节点的值替换为后继节点的值，并将后继节点删除。</span><br><span class="line"></span><br><span class="line">#### <span class="number">2</span>\. 修复红黑树</span><br><span class="line"></span><br><span class="line">删除节点后，可能会违反红黑树的性质。需要通过以下几种情况进行调整：</span><br><span class="line"></span><br><span class="line">-   **情况<span class="number">1</span>：被删除的节点是红色**  </span><br><span class="line">    这种情况下，直接删除该节点不会破坏红黑树的性质。</span><br><span class="line">    </span><br><span class="line">-   **情况<span class="number">2</span>：被删除的节点是黑色，且其子节点是红色**  </span><br><span class="line">    这种情况下，将子节点变为黑色，然后删除该节点。</span><br><span class="line">    </span><br><span class="line">-   **情况<span class="number">3</span>：被删除的节点是黑色，且其子节点是黑色**  </span><br><span class="line">    这种情况下，需要通过一系列复杂的调整来恢复红黑树的性质，包括颜色调整和旋转操作。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### 三.红黑树的查找操作</span><br><span class="line"></span><br><span class="line">按⼆叉搜索树逻辑实现即可，搜索效率为O(logN)</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">    Node* <span class="title function_">Find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span><br><span class="line">    &#123;</span><br><span class="line">     Node* cur = _root;</span><br><span class="line">     <span class="keyword">while</span> (cur)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">if</span> (cur-&gt;_kv.first &lt; key)</span><br><span class="line">     &#123;</span><br><span class="line">     cur = cur-&gt;_right;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_kv.first &gt; key)</span><br><span class="line">     &#123;</span><br><span class="line">     cur = cur-&gt;_left;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">return</span> cur;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> nullptr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="四红黑树的验证"><a class="markdownIt-Anchor" href="#四红黑树的验证"></a> 四.红黑树的验证</h3><ol><li><strong>每个节点是红色或黑色</strong>。</li><li><strong>根节点是黑色</strong>。</li><li><strong>所有叶子节点（空节点）是黑色</strong>。</li><li><strong>如果一个节点是红色，则它的两个子节点都是黑色</strong>（不能有两个连续的红色节点）。</li><li><strong>从任何节点到其每个叶子的所有路径都包含相同数量的黑色节点</strong>。</li></ol><h4 id="代码中的检查逻辑"><a class="markdownIt-Anchor" href="#代码中的检查逻辑"></a> 代码中的检查逻辑</h4><h4 id="1-isbalance函数"><a class="markdownIt-Anchor" href="#1-isbalance函数"></a> 1. <code>IsBalance</code>函数</h4><p>这个函数是入口函数，用于初始化检查过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">IsBalance</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_root == nullptr)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果树为空，直接返回true，空树满足红黑树的性质</span></span><br><span class="line">    <span class="keyword">if</span> (_root-&gt;_col == RED)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 根节点必须是黑色，否则直接返回false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算从根节点到最左边叶子节点的黑色节点数量作为参考值</span></span><br><span class="line">    <span class="type">int</span> refNum = <span class="number">0</span>;</span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;_col == BLACK)</span><br><span class="line">            ++refNum; <span class="comment">// 如果当前节点是黑色，增加黑色节点计数</span></span><br><span class="line">        cur = cur-&gt;_left; <span class="comment">// 沿着左子树向下遍历</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用参考值调用Check函数检查整棵树</span></span><br><span class="line">    <span class="keyword">return</span> Check(_root, <span class="number">0</span>, refNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>检查根节点颜色</strong>：如果根节点是红色，直接返回<code>false</code>，因为红黑树的根节点必须是黑色。</li><li><strong>计算参考值<code>refNum</code></strong>：从根节点开始，沿着左子树一直向下，统计路径上的黑色节点数量。这个值将作为后续路径检查的参考值。</li><li><strong>调用<code>Check</code>函数</strong>：使用计算出的<code>refNum</code>，从根节点开始递归检查整棵树。</li></ul><h4 id="2-check函数"><a class="markdownIt-Anchor" href="#2-check函数"></a> 2. <code>Check</code>函数</h4><p>这个函数是递归函数，用于检查树的每个路径是否满足红黑树的性质。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Check</span><span class="params">(Node* root, <span class="type">int</span> blackNum, <span class="type">const</span> <span class="type">int</span> refNum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 前序遍历走到空节点，意味着一条路径走完了</span></span><br><span class="line">        <span class="keyword">if</span> (refNum != blackNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;存在黑色节点的数量不相等的路径&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果当前路径的黑色节点数量与参考值不同，返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否存在连续的红色节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;_col == RED &amp;&amp; root-&gt;_parent-&gt;_col == RED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;_kv.first &lt;&lt; <span class="string">&quot;存在连续的红色节点&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果当前节点和父节点都是红色，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;_col == BLACK)</span><br><span class="line">    &#123;</span><br><span class="line">        blackNum++; <span class="comment">// 如果当前节点是黑色，增加黑色节点计数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归检查左右子树</span></span><br><span class="line">    <span class="keyword">return</span> Check(root-&gt;_left, blackNum, refNum) &amp;&amp; Check(root-&gt;_right, blackNum, refNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>检查路径结束</strong>：如果当前节点是空节点（<code>root == nullptr</code>），说明已经到达路径的末端。此时检查当前路径的黑色节点数量<code>blackNum</code>是否与参考值<code>refNum</code>相等。如果不相等，说明违反了红黑树的第5条性质。</li><li><strong>检查连续红色节点</strong>：如果当前节点是红色，并且它的父节点也是红色，直接返回<code>false</code>，因为这违反了红黑树的第4条性质。</li><li><strong>统计黑色节点</strong>：如果当前节点是黑色，将<code>blackNum</code>加1。</li><li><strong>递归检查子树</strong>：递归调用<code>Check</code>函数，分别检查当前节点的左子树和右子树。只有当左右子树都满足红黑树的性质时，当前节点才满足性质。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Check</span><span class="params">(Node* root, <span class="type">int</span> blackNum, <span class="type">const</span> <span class="type">int</span> refNum)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (root == nullptr)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">// 前序遍历⾛到空时，意味着⼀条路径⾛完了 </span></span><br><span class="line"> <span class="comment">//cout &lt;&lt; blackNum &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (refNum != blackNum)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;存在⿊⾊结点的数量不相等的路径&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 检查孩⼦不太⽅便，因为孩⼦有两个，且不⼀定存在，反过来检查⽗亲就⽅便多了 </span></span><br><span class="line"> <span class="keyword">if</span> (root-&gt;_col == RED &amp;&amp; root-&gt;_parent-&gt;_col == RED)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; root-&gt;_kv.first &lt;&lt; <span class="string">&quot;存在连续的红⾊结点&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (root-&gt;_col == BLACK)</span><br><span class="line"> &#123;</span><br><span class="line"> blackNum++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> Check(root-&gt;_left, blackNum, refNum)</span><br><span class="line"> &amp;&amp; Check(root-&gt;_right, blackNum, refNum);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsBalance</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (_root == nullptr)</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">if</span> (_root-&gt;_col == RED)</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 参考值 </span></span><br><span class="line"> <span class="type">int</span> refNum = <span class="number">0</span>;</span><br><span class="line"> Node* cur = _root;</span><br><span class="line"> <span class="keyword">while</span> (cur)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (cur-&gt;_col == BLACK)</span><br><span class="line">  &#123;</span><br><span class="line"> ++refNum;</span><br><span class="line"> &#125;</span><br><span class="line"> cur = cur-&gt;_left;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> Check(_root, <span class="number">0</span>, refNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树-vs-avl树"><a class="markdownIt-Anchor" href="#红黑树-vs-avl树"></a> 红黑树 vs AVL树</h3><table><thead><tr><th>特性</th><th>红黑树</th><th>AVL树</th></tr></thead><tbody><tr><td><strong>平衡严格度</strong></td><td>宽松（最长路径≤2×最短）</td><td>严格（高度差≤1）</td></tr><tr><td><strong>插入/删除</strong></td><td>更快（平均更少旋转）</td><td>较慢（旋转次数多）</td></tr><tr><td><strong>查找效率</strong></td><td>稍慢（高度略高）</td><td>更快（高度最小化）</td></tr><tr><td><strong>适用场景</strong></td><td>频繁修改的关联容器（如map）</td><td>查询密集型场景</td></tr></tbody></table></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://www.formeasy.cc">formeasy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.formeasy.cc/2025/07/10/C/C++%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">http://www.formeasy.cc/2025/07/10/C/C++之红黑树认识与实现/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://www.formeasy.cc" target="_blank">易锦风的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a></div><div class="post-share"><div class="social-share" data-image="/2025/07/10/C/C++%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/d6e48fbd9ca54c63aa684f0bcbe9ccf5.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/10/C/C++%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%81/" title="C++动态分配内存知识点！"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C++动态分配内存知识点！</div></div><div class="info-2"><div class="info-item-1">1.动态分配内存的思想 动态分配内存是指在程序运行时根据需要动态地分配内存空间。这相对于静态分配内存来说，静态分配内存是在编译时固定地分配内存空间，而动态分配内存可以在程序运行期间根据实际需求进行内存的申请和释放，以提高内存的利用率和灵活性。 2.动态分配内存的概念 动态分配内存的概念包括以下几个方面： 2.1内存分配函数 动态分配内存需要使用内存分配函数，如C语言中的malloc()、calloc()、realloc()等，这些函数可以根据需要在运行时动态地分配一块连续的内存空间。 2.2动态内存的申请和释放 使用内存分配函数可以申请一块指定大小的内存空间，申请的内存空间可以在程序运行期间使用。使用完毕后，可以使用释放函数将内存空间释放，以便其他程序继续使用。 2.3内存碎片问题 动态分配内存可能会导致内存碎片问题。当频繁地进行内存分配和释放操作时，可能会在内存中留下一些未被使用的小块内存，这些小块内存无法被再次利用，导致内存的浪费。为了解决内存碎片问题，可以使用内存管理算法来进行内存的分配和释放操作。 ...</div></div></div></a><a class="pagination-related" href="/2025/07/04/Other/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E6%B3%95%E5%88%99%EF%BC%9A%E5%AD%A6%E4%BC%9A%E6%80%9D%E8%80%83%EF%BC%8C%E6%8E%8C%E6%8F%A1%E4%BA%94%E5%A4%A7%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" title="高效工作法则：学会思考，掌握五大管理工具"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/07/04/Other/%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E6%B3%95%E5%88%99%EF%BC%9A%E5%AD%A6%E4%BC%9A%E6%80%9D%E8%80%83%EF%BC%8C%E6%8E%8C%E6%8F%A1%E4%BA%94%E5%A4%A7%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/36b208b9078049ef3b20921b533d06c8.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">高效工作法则：学会思考，掌握五大管理工具</div></div><div class="info-2"><div class="info-item-1">在职场中，如何不断提升自己的效率、优化工作流程，是每位职业人都会面对的问题。本文聚焦于几种经典的管理方法论，如PDCA循环、RACI模型、RCA法则、SWOT分析、SMART目标等，帮助你掌握从计划到执行、从分析到反馈的系统化思维模式。无论你是新晋职场小白，还是希望进一步精进技能的管理者，这些工具都能为你的日常工作提供有效指导，助你在不断思考和改进中迈向更高效的职场表现。让我们从了解这些方法开始，探索如何在工作中活学活用，真正做到在思考中成长，在应用中进步。 一、PDCA循环 （戴明循环） ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/11/C/C++11%20%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%9Astdcopy_if%20%E4%B8%8E%20stdcopy_n/" title="C++11 算法详解：std::copy_if 与 std::copy_n"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-11</div><div class="info-item-2">C++11 算法详解：std::copy_if 与 std::copy_n</div></div><div class="info-2"><div class="info-item-1">引言 C++11 标准为算法库带来了诸多增强，其中 std::copy_if 和 std::copy_n 作为 std::copy 的补充，为元素复制操作提供了更精细的控制。这两个算法不仅简化了代码逻辑，还提升了可读性和性能。本文将深入探讨这两个算法的实现细节、使用场景及最佳实践，帮助开发者在实际项目中正确高效地应用它们。 std::copy_if：条件筛选复制 函数原型 12template&lt; class InputIt, class OutputIt, class UnaryPred &gt;OutputIt copy_if( InputIt first, InputIt last, OutputIt d_first, UnaryPred pred ); 核心功能 std::copy_if 从输入范围 [first, last) 中复制满足谓词 pred 的元素到目标范围（始于 d_first），并保持元素的相对顺序。该算法在 C++11 中引入，是对传统 std::copy 的条件化扩展。 ...</div></div></div></a><a class="pagination-related" href="/2025/07/10/C/C++%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%81/" title="C++动态分配内存知识点！"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-10</div><div class="info-item-2">C++动态分配内存知识点！</div></div><div class="info-2"><div class="info-item-1">1.动态分配内存的思想 动态分配内存是指在程序运行时根据需要动态地分配内存空间。这相对于静态分配内存来说，静态分配内存是在编译时固定地分配内存空间，而动态分配内存可以在程序运行期间根据实际需求进行内存的申请和释放，以提高内存的利用率和灵活性。 2.动态分配内存的概念 动态分配内存的概念包括以下几个方面： 2.1内存分配函数 动态分配内存需要使用内存分配函数，如C语言中的malloc()、calloc()、realloc()等，这些函数可以根据需要在运行时动态地分配一块连续的内存空间。 2.2动态内存的申请和释放 使用内存分配函数可以申请一块指定大小的内存空间，申请的内存空间可以在程序运行期间使用。使用完毕后，可以使用释放函数将内存空间释放，以便其他程序继续使用。 2.3内存碎片问题 动态分配内存可能会导致内存碎片问题。当频繁地进行内存分配和释放操作时，可能会在内存中留下一些未被使用的小块内存，这些小块内存无法被再次利用，导致内存的浪费。为了解决内存碎片问题，可以使用内存管理算法来进行内存的分配和释放操作。 ...</div></div></div></a><a class="pagination-related" href="/2025/01/23/C/c++%E4%B9%8B%E7%BB%84%E5%90%88%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E8%81%9A%E5%90%88%E5%8F%8A%E4%BE%9D%E8%B5%96/" title="c++之组合、继承、聚合及依赖"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-23</div><div class="info-item-2">c++之组合、继承、聚合及依赖</div></div><div class="info-2"><div class="info-item-1">在学习c++的过程中相信大家对这几个概念都不陌生。 c++中一些常用的设计模式都是由这几种特性组合而成。本文再从整体对这个概念或者特性进行简要的介绍。 组合 c++中类之间的一种关系叫做&quot;has-a&quot;的关系。这种关系表示的是一个类中包含另一类的对象，体现了“有一个”的关系。这个被包含的类一般以实例对象的形式存在，而非指针对象的形式存在。请看下面的示例: 12345678910111213141516171819class Engine&#123;	public: void start() &#123; cout&lt;&lt;&quot;引擎启动&quot;&lt;&lt;endl; &#125;&#125;class car&#123;private:	Engine engine; //这里以实例的形式存在，而非指针，在类关系中是组合的关系public:	void startCar()	&#123; engine.start(); //启动引擎	&#125;&#125; ...</div></div></div></a><a class="pagination-related" href="/2025/07/11/C/vector%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/" title="vector的详细讲解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/07/11/C/vector%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/53d1d2e536204e609dc694bcb054ce9c.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-11</div><div class="info-item-2">vector的详细讲解</div></div><div class="info-2"><div class="info-item-1">1.vector的介绍及使用 1.1 vector的介绍 1. vector 是表示可变大小数组的序列容器。 2. 就像数组一样， vector 也采用的连续存储空间来存储元素。也就是意味着可以采用下标对 vector 的元素 进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自 动处理。 3. 本质讲， vector 使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小 为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是 一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector 并不会每次都重新分配大 小。 4. vector 分配空间策略： vector 会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存 储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是 对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。 5. 因此， vector...</div></div></div></a><a class="pagination-related" href="/2025/07/21/C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/" title="内存管理基础：数据结构的存储方式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/07/21/C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/6dbd55eda53d6550a09ffc9da8295446.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-21</div><div class="info-item-2">内存管理基础：数据结构的存储方式</div></div><div class="info-2"><div class="info-item-1">内存管理基础：数据结构的存储方式 想象一下你正在整理你的衣柜。有些衣服你会折叠整齐地放在抽屉里（连续存储），有些则挂在衣架上分散在衣柜各处（链式存储。计算机内存管理数据的方式其实和这个场景非常相似。今天，我们就来探讨一下数据结构在内存中的不同存储方式，以及它们各自的优缺点。 1. 连续存储结构 理解了衣柜的比喻后，我们来看看计算机中最基础的存储方式——连续存储。这种存储方式就像把衣服一件件紧密地叠放在抽屉里，每件衣服占据固定大小的空间，并且按照顺序排列。 1.1 数组的存储方式 数组是最典型的连续存储结构。让我们通过一个简单的例子来看看数组在内存中是如何存储的： 1int arr[5] = &#123;10, 20, 30, 40, 50&#125;; 上述代码定义了一个包含5个整数的数组。在内存中，这些元素会被连续地存储在一起。 以上流程图说明了数组在内存中的连续存储方式，每个元素占据4字节空间 1.2...</div></div></div></a><a class="pagination-related" href="/2025/04/30/RPC/GRPC%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="GRPC 快速入门"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-30</div><div class="info-item-2">GRPC 快速入门</div></div><div class="info-2"><div class="info-item-1">1. 背景介绍 gRPC全称Google Remote Procedure Call. 它是一种基于Protobuf buffer 格式的高效的通讯协议。与许多 RPC 系统一样，gRPC 基于定义服务的理念，指定可以远程调用的方法及其参数和返回类型。在服务器端，服务器实现此接口并运行 gRPC 服务器以处理客户端调用。在客户端，客户端具有一个存根（在某些语言中称为客户端），它提供与服务器相同的 方法。 2. 快速入门 安装 cmake 您需要 cmake 的 3.13 版或更高版本。请按照以下说明进行安装 Linux 1sudo apt install -y cmake macOS 1brew install cmake 安装其他必需工具 Linux 1sudo apt install -y build-essential autoconf libtool pkg-config macOS 1brew install autoconf automake libtool pkg-config 克隆 grpc 仓库 设置安装路径 123export...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly-icon.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">formeasy</div><div class="author-info-description">专注互联网和软件技术</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">247</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/formeasy"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/formeasy" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:formeasy@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">用学习，面对遭遇的变化；用斗志，面对每天的挫折；用坚持，面对失去的动力!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一.红黑树的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">红黑树的结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">二.红黑树的定义与特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.</span> <span class="toc-text">一.红黑树的插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 插入节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BF%AE%E5%A4%8D%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. 修复红黑树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.1.3.</span> <span class="toc-text">插入操作的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8F%92%E5%85%A5%E6%96%B0%E8%8A%82%E7%82%B9"><span class="toc-number">2.1.4.</span> <span class="toc-text">1. 插入新节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BF%AE%E5%A4%8D%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">2.1.5.</span> <span class="toc-text">2. 修复红黑树的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E9%80%BB%E8%BE%91"><span class="toc-number">2.1.6.</span> <span class="toc-text">修复逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%83%85%E5%86%B5"><span class="toc-number">2.1.7.</span> <span class="toc-text">修复情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A0%B9%E8%8A%82%E7%82%B9%E7%9A%84%E9%A2%9C%E8%89%B2"><span class="toc-number">2.1.8.</span> <span class="toc-text">3. 根节点的颜色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E8%A7%A3%E6%9E%90"><span class="toc-number">2.1.9.</span> <span class="toc-text">代码逻辑解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81"><span class="toc-number">2.2.</span> <span class="toc-text">四.红黑树的验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E6%A3%80%E6%9F%A5%E9%80%BB%E8%BE%91"><span class="toc-number">2.2.1.</span> <span class="toc-text">代码中的检查逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-isbalance%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">1. IsBalance函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-check%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">2. Check函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91-vs-avl%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text">红黑树 vs AVL树</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/10/UE/UE5-VR%E9%A1%B9%E7%9B%AEHDRIBackdrop%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" title="UE5-VR项目HDRIBackdrop无法正常显示问题解决"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/10/UE/UE5-VR%E9%A1%B9%E7%9B%AEHDRIBackdrop%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/c279d21ae76201f770cff811d5bc5b9b48676898.png@1192w.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="UE5-VR项目HDRIBackdrop无法正常显示问题解决"></a><div class="content"><a class="title" href="/2026/01/10/UE/UE5-VR%E9%A1%B9%E7%9B%AEHDRIBackdrop%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" title="UE5-VR项目HDRIBackdrop无法正常显示问题解决">UE5-VR项目HDRIBackdrop无法正常显示问题解决</a><time datetime="2026-01-10T07:41:29.000Z" title="发表于 2026-01-10 15:41:29">2026-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/10/UE/UE5%E8%BF%90%E8%A1%8C%E5%B8%A7%E7%8E%87FPS%E7%9A%84%E9%97%AE%E9%A2%98/" title="UE5运行帧率FPS的问题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="UE5运行帧率FPS的问题"></a><div class="content"><a class="title" href="/2026/01/10/UE/UE5%E8%BF%90%E8%A1%8C%E5%B8%A7%E7%8E%87FPS%E7%9A%84%E9%97%AE%E9%A2%98/" title="UE5运行帧率FPS的问题">UE5运行帧率FPS的问题</a><time datetime="2026-01-10T05:20:11.000Z" title="发表于 2026-01-10 13:20:11">2026-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/07/UE/UE5%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E7%BC%BA%E5%B0%91Generate%20Visual%20Studio%20project%20files%E7%AD%89%E9%80%89%E9%A1%B9/" title="UE5中如何解决右键菜单缺少Generate Visual Studio project files等选项"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="UE5中如何解决右键菜单缺少Generate Visual Studio project files等选项"></a><div class="content"><a class="title" href="/2026/01/07/UE/UE5%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E7%BC%BA%E5%B0%91Generate%20Visual%20Studio%20project%20files%E7%AD%89%E9%80%89%E9%A1%B9/" title="UE5中如何解决右键菜单缺少Generate Visual Studio project files等选项">UE5中如何解决右键菜单缺少Generate Visual Studio project files等选项</a><time datetime="2026-01-07T07:43:11.000Z" title="发表于 2026-01-07 15:43:11">2026-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/04/UE/UE5%E8%B5%84%E6%BA%90%E3%80%81%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%B0/" title="UE5资源、快捷键和控制台"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="UE5资源、快捷键和控制台"></a><div class="content"><a class="title" href="/2026/01/04/UE/UE5%E8%B5%84%E6%BA%90%E3%80%81%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%B0/" title="UE5资源、快捷键和控制台">UE5资源、快捷键和控制台</a><time datetime="2026-01-04T07:43:11.000Z" title="发表于 2026-01-04 15:43:11">2026-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/03/UE/UE5%20-%20%E5%AE%9E%E7%8E%B0%E7%94%BB%E4%B8%AD%E7%94%BB/" title="UE5 - 实现画中画"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/03/UE/UE5%20-%20%E5%AE%9E%E7%8E%B0%E7%94%BB%E4%B8%AD%E7%94%BB/2026-01-03_115346_135.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="UE5 - 实现画中画"></a><div class="content"><a class="title" href="/2026/01/03/UE/UE5%20-%20%E5%AE%9E%E7%8E%B0%E7%94%BB%E4%B8%AD%E7%94%BB/" title="UE5 - 实现画中画">UE5 - 实现画中画</a><time datetime="2026-01-03T03:52:42.000Z" title="发表于 2026-01-03 11:52:42">2026-01-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2026 By formeasy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(async()=>{window.katex_js_css||(window.katex_js_css=!0,await btf.getCSS("https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"),await btf.getScript("https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js")),document.querySelectorAll("#article-container .katex").forEach(t=>t.classList.add("katex-show"))})()</script><script>(()=>{var e=()=>{var e;0!==(e=document.querySelectorAll("pre > code.mermaid")).length&&e.forEach(e=>{var t=document.createElement("pre"),n=(t.className="mermaid-src",t.hidden=!0,t.textContent=e.textContent,document.createElement("div"));n.className="mermaid-wrap",n.appendChild(t),e.parentNode.replaceWith(n)});const t=document.querySelectorAll("#article-container .mermaid-wrap");0!==t.length&&(e=()=>{{var e=t;window.loadMermaid=!0;const a="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";e.forEach((e,t)=>{const n=e.firstElementChild;e=`%%{init:{ 'theme':'${a}'}}%%
`+n.textContent,t=mermaid.render("mermaid-"+t,e);const d=e=>{n.insertAdjacentHTML("afterend",e)};"string"==typeof t?d(t):t.then(({svg:e})=>d(e))})}},btf.addGlobalFn("themeChange",e,"mermaid"),window.loadMermaid?e():btf.getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(e))};btf.addGlobalFn("encrypt",e,"mermaid"),window.pjax?e():document.addEventListener("DOMContentLoaded",e)})()</script><script>(()=>{const a=GLOBAL_CONFIG_SITE.isShuoshuo,s=null,n=t=>"dark"===t?"dark":"light";var t=(t=document,e)=>{e=a?{"data-mapping":"specific","data-term":e}:{"data-mapping":(s,"pathname")},e=(t=>{const a=document.createElement("script");return Object.entries(t).forEach(([t,e])=>{a.setAttribute(t,e)}),a})({src:"https://giscus.app/client.js","data-repo":"formeasy/blog","data-repo-id":"R_kgDOJ2sA5A","data-category-id":"DIC_kwDOJ2sA5M4CktKh","data-theme":n(document.documentElement.getAttribute("data-theme")),"data-reactions-enabled":"1",crossorigin:"anonymous",async:!0,...s,...e});t.querySelector("#giscus-wrap").appendChild(e),a&&(window.shuoshuoComment.destroyGiscus=()=>{t.children.length&&(t.innerHTML="",t.classList.add("no-comment"))})};btf.addGlobalFn("themeChange",t=>{var e=document.querySelector("#giscus-wrap iframe");e&&(t={giscus:{setConfig:{theme:n(t)}}},e.contentWindow.postMessage(t,"https://giscus.app"))},"giscus"),a?window.shuoshuoComment={loadComment:t}:t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="请输入搜索关键字" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>