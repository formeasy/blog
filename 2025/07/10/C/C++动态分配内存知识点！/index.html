<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>C++动态分配内存知识点！ | 易锦风的博客</title><meta name="author" content="formeasy"><meta name="copyright" content="formeasy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++动态分配内存知识点！"><meta property="og:type" content="article"><meta property="og:title" content="C++动态分配内存知识点！"><meta property="og:url" content="http://www.formeasy.cc/2025/07/10/C/C++%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%81/index.html"><meta property="og:site_name" content="易锦风的博客"><meta property="og:description" content="C++动态分配内存知识点！"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.formeasy.cc/img/cover.png"><meta property="article:published_time" content="2025-07-10T01:24:48.000Z"><meta property="article:modified_time" content="2025-07-10T01:30:51.007Z"><meta property="article:author" content="formeasy"><meta property="article:tag" content="C"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://www.formeasy.cc/img/cover.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.formeasy.cc/2025/07/10/C/C++%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{var e={set:(e,t,a)=>{a&&(a=Date.now()+864e5*a,localStorage.setItem(e,JSON.stringify({value:t,expiry:a})))},get:e=>{var t=localStorage.getItem(e);if(t){var{value:t,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return t;localStorage.removeItem(e)}}},t=(window.btf={saveToLocal:e,getScript:(o,n={})=>new Promise((e,t)=>{const a=document.createElement("script");a.src=o,a.async=!0,Object.entries(n).forEach(([e,t])=>a.setAttribute(e,t)),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),getCSS:(o,n)=>new Promise((e,t)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),addGlobalFn:(e,t,a=!1,o=window)=>{var n;e.startsWith("pjax")||((n=o.globalFn||{})[e]=n[e]||{},n[e][a||Object.keys(n[e]).length]=t,o.globalFn=n)}},()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")}),a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")},o=(btf.activateDarkMode=t,btf.activateLightMode=a,e.get("theme")),t=("dark"===o?t():"light"===o&&a(),e.get("aside-status"));void 0!==t&&document.documentElement.classList.toggle("hide-aside","hide"===t);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"C++动态分配内存知识点！",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,isShuoshuo:!1}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="易锦风的博客" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly-icon.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">199</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/cover.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/icon.png" alt="Logo"><span class="site-name">易锦风的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">C++动态分配内存知识点！</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++动态分配内存知识点！</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-10T01:24:48.000Z" title="发表于 2025-07-10 09:24:48">2025-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-10T01:30:51.007Z" title="更新于 2025-07-10 09:30:51">2025-07-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="1动态分配内存的思想"><a class="markdownIt-Anchor" href="#1动态分配内存的思想"></a> 1.动态分配内存的思想</h2><p>动态分配内存是指在程序运行时根据需要动态地分配内存空间。这相对于静态分配内存来说，静态分配内存是在编译时固定地分配内存空间，而动态分配内存可以在程序运行期间根据实际需求进行内存的申请和释放，以提高内存的利用率和灵活性。</p><h2 id="2动态分配内存的概念"><a class="markdownIt-Anchor" href="#2动态分配内存的概念"></a> 2.动态分配内存的概念</h2><p>动态分配内存的概念包括以下几个方面：</p><h3 id="21内存分配函数"><a class="markdownIt-Anchor" href="#21内存分配函数"></a> 2.1内存分配函数</h3><p>动态分配内存需要使用内存分配函数，如C语言中的malloc()、calloc()、realloc()等，这些函数可以根据需要在运行时动态地分配一块连续的内存空间。</p><h3 id="22动态内存的申请和释放"><a class="markdownIt-Anchor" href="#22动态内存的申请和释放"></a> 2.2动态内存的申请和释放</h3><p>使用内存分配函数可以申请一块指定大小的内存空间，申请的内存空间可以在程序运行期间使用。使用完毕后，可以使用释放函数将内存空间释放，以便其他程序继续使用。</p><h3 id="23内存碎片问题"><a class="markdownIt-Anchor" href="#23内存碎片问题"></a> 2.3内存碎片问题</h3><p>动态分配内存可能会导致内存碎片问题。当频繁地进行内存分配和释放操作时，可能会在内存中留下一些未被使用的小块内存，这些小块内存无法被再次利用，导致内存的浪费。为了解决内存碎片问题，可以使用内存管理算法来进行内存的分配和释放操作。</p><h2 id="3动态分配内存的作用"><a class="markdownIt-Anchor" href="#3动态分配内存的作用"></a> 3.动态分配内存的作用</h2><p>动态分配内存在计算机编程中有很多重要的作用，包括：</p><h3 id="31-灵活分配内存空间"><a class="markdownIt-Anchor" href="#31-灵活分配内存空间"></a> 3.1 灵活分配内存空间</h3><p>动态分配内存可以根据程序的实际需求，在运行时动态地申请适当大小的内存空间。这使得程序可以根据具体情况来分配所需的内存，提高了程序的灵活性和适应性。</p><h3 id="32-提高内存利用率"><a class="markdownIt-Anchor" href="#32-提高内存利用率"></a> 3.2 提高内存利用率</h3><p>动态分配内存可以避免静态分配内存的固定大小限制，可以根据实际需要进行灵活的内存分配。这样可以更有效地利用内存资源，避免了内存的浪费。</p><h3 id="33-动态数据结构的实现"><a class="markdownIt-Anchor" href="#33-动态数据结构的实现"></a> 3.3 动态数据结构的实现</h3><p>动态分配内存是实现动态数据结构（如链表、树等）的基础。动态数据结构的大小可能在程序运行过程中变化，需要动态地为其分配和释放内存空间。</p><h3 id="34-避免内存溢出和内存泄漏"><a class="markdownIt-Anchor" href="#34-避免内存溢出和内存泄漏"></a> 3.4 避免内存溢出和内存泄漏</h3><p>动态分配内存可以避免程序因为内存空间不足而导致的内存溢出错误。同时，使用动态分配内存还可以确保内存的正确释放，避免造成内存泄漏问题。</p><h3 id="35-提高程序的性能"><a class="markdownIt-Anchor" href="#35-提高程序的性能"></a> 3.5 提高程序的性能</h3><p>动态分配内存可以减少内存碎片的问题，提高内存的利用效率。同时，动态分配内存也可以减少静态分配内存的开销，提高程序的性能。</p><h3 id="36-总结"><a class="markdownIt-Anchor" href="#36-总结"></a> 3.6 总结</h3><p>总之，动态分配内存在计算机编程中具有重要的作用，它可以提供灵活的内存分配方式，提高内存的利用率，支持动态数据结构的实现，避免内存溢出和内存泄漏问题，同时提高程序的性能。</p><h2 id="4动态分配内存的实现"><a class="markdownIt-Anchor" href="#4动态分配内存的实现"></a> 4.动态分配内存的实现</h2><p>在C++中，动态内存分配通常使用new和delete操作符来完成。下面我将分步骤和代码两部分来介绍如何进行动态内存分配。</p><h3><a class="markdownIt-Anchor" href="#"></a></h3><p>4.1 步骤</p><h4 id="411-确定需要分配的内存大小"><a class="markdownIt-Anchor" href="#411-确定需要分配的内存大小"></a> 4.1.1 确定需要分配的内存大小</h4><p>首先，你需要确定要分配多少内存。这通常取决于你要存储的数据类型以及你要存储多少这样的数据。</p><h4 id="-2"><a class="markdownIt-Anchor" href="#-2"></a></h4><p>4.1.2 使用new操作符分配内存</p><p>使用new操作符来分配内存。例如，如果你要分配一个整数数组，你可以使用new int[size]，其中size是你想要的数组大小。</p><h4 id="-3"><a class="markdownIt-Anchor" href="#-3"></a></h4><p>4.1.3 检查分配是否成功</p><p>new操作符在无法分配所需内存时会返回nullptr。因此，你应该检查返回的指针是否为nullptr，以确保内存已成功分配。</p><h4 id="-4"><a class="markdownIt-Anchor" href="#-4"></a></h4><p>4.1.4 使用分配的内存</p><p>一旦内存成功分配，你就可以开始使用它。例如，你可以将值存储在数组中，或者创建对象等。<br>释放内存：当你不再需要分配的内存时，应使用delete或delete[]操作符来释放它。忘记释放内存会导致内存泄漏，这是一个常见的编程错误。</p><h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a></h3><p>4.2 代码示例</p><p>下面是一个简单的代码示例，演示了如何在C++中动态分配和释放内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 步骤1：确定需要分配的内存大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 步骤2：使用new操作符分配内存</span></span><br><span class="line"><span class="type">int</span>* array = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 检查分配是否成功</span></span><br><span class="line"><span class="keyword">if</span> (array == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回错误代码</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 步骤3：使用分配的内存</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">array[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 打印数组内容</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">std::cout &lt;&lt; array[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 步骤4：释放内存</span></span><br><span class="line"><span class="keyword">delete</span>[] array;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先确定要分配的内存大小（一个包含10个整数的数组）。然后，我们使用new操作符分配内存，并检查是否成功。接着，我们使用分配的内存来存储值，并打印数组的内容。最后，我们使用delete[]操作符来释放内存。</p><h2 id="5动态分配内存的分类及代码"><a class="markdownIt-Anchor" href="#5动态分配内存的分类及代码"></a> 5.动态分配内存的分类及代码</h2><p>在C++中，动态内存分配可以分为两类：动态分配单个对象的内存和动态分配对象数组的内存。</p><h3 id="-6"><a class="markdownIt-Anchor" href="#-6"></a></h3><p>5.1 动态分配单个对象的内存</p><p>当你知道需要创建一个对象，但不知道它的生命周期时，可以使用new操作符动态地为其分配内存。这种分配方式在对象的大小不是固定大小时特别有用。</p><h4 id="-7"><a class="markdownIt-Anchor" href="#-7"></a></h4><p>5.1.1 介绍</p><p>使用new为单个对象分配内存时，你需要指定对象的类型。new会返回指向新创建对象的指针。如果内存分配成功，你可以使用这个指针来访问和操作对象。如果内存分配失败，new会返回nullptr。</p><h4 id="-8"><a class="markdownIt-Anchor" href="#-8"></a></h4><p>5.1.2 代码示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; value_ &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 动态分配单个对象的内存</span></span><br><span class="line">MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">42</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用对象</span></span><br><span class="line">obj-&gt;<span class="built_in">printValue</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">delete</span> obj;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="-9"><a class="markdownIt-Anchor" href="#-9"></a></h3><p>5.2 动态分配对象数组的内存</p><p>当你需要创建多个同类型的对象时，可以使用new操作符来动态分配一个对象数组。这种方式在你不确定数组大小，或者数组大小在运行时才能确定时非常有用。</p><h4 id="-10"><a class="markdownIt-Anchor" href="#-10"></a></h4><p>5.2.1 介绍</p><p>使用new为对象数组分配内存时，你需要指定对象的类型和数组的大小。new会返回一个指向数组第一个元素的指针。与单个对象不同，当你使用new为数组分配内存时，需要使用delete[]来释放内存。</p><h4 id="-11"><a class="markdownIt-Anchor" href="#-11"></a></h4><p>5.2.2 代码示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; value_ &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 动态分配对象数组的内存</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> arraySize = <span class="number">5</span>;</span><br><span class="line">MyClass* array = <span class="keyword">new</span> MyClass[arraySize];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始化数组中的对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arraySize; ++i) &#123;</span><br><span class="line">array[i] = <span class="built_in">MyClass</span>(i * <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用数组中的对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arraySize; ++i) &#123;</span><br><span class="line">array[i].<span class="built_in">printValue</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">delete</span>[] array;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们动态地创建了一个包含5个MyClass对象的数组，并分别初始化了它们。之后，我们遍历数组并打印每个对象的值。最后，我们使用delete[]释放了整个数组所占用的内存。</p><h3 id="-12"><a class="markdownIt-Anchor" href="#-12"></a></h3><p>5.3 注意事项</p><blockquote><p>1.使用new分配的内存必须使用delete或delete[]来释放，否则会导致内存泄漏。<br>2.new和delete是配对使用的，new[]和delete[]也是配对使用的。不应该混合使用它们，因为这会导致未定义的行为。<br>3.在使用new分配内存后，总是应该检查返回的指针是否为nullptr，以确保内存分配成功。<br>4.在C++11及以后的版本中，推荐使用智能指针（如std::unique_ptr和std::shared_ptr）来管理动态分配的内存，以自动处理内存释放，减少内存泄漏的风险。</p></blockquote><h2 id="6动态分配内存的练习"><a class="markdownIt-Anchor" href="#6动态分配内存的练习"></a> 6.动态分配内存的练习</h2><h3 id="61-题目描述"><a class="markdownIt-Anchor" href="#61-题目描述"></a> 6.1 题目描述</h3><p>创建一个程序，该程序使用动态内存分配来创建一个字符串数组。用户将首先输入数组的大小，然后为每个字符串元素输入具体的字符串内容。程序将显示所有输入的字符串，并允许用户选择是否继续添加更多字符串或释放内存并退出程序。</p><h3 id="-13"><a class="markdownIt-Anchor" href="#-13"></a></h3><p>6.2 知识点</p><p>动态内存分配与释放（new、delete[]）<br>字符串处理（std::string）：C++ 字符串详解<br>用户输入和输出 （std::cin、std::cout）<br>循环结构（while、for）: C++ 循环：简化重复的代码<br>条件语句（if、else）：C++分支语句</p><h3 id="-14"><a class="markdownIt-Anchor" href="#-14"></a></h3><p>6.3 步骤</p><h4 id="-15"><a class="markdownIt-Anchor" href="#-15"></a></h4><p>6.3.1 初始化</p><p>设置必要的变量和标志，如数组大小、当前索引、是否继续的标志等。</p><h4 id="-16"><a class="markdownIt-Anchor" href="#-16"></a></h4><p>6.3.2 输入数组大小</p><p>提示用户输入字符串数组的大小，并读取输入。</p><h4 id="-17"><a class="markdownIt-Anchor" href="#-17"></a></h4><p>6.3.3 分配内存</p><p>使用new[]为字符串数组分配内存。</p><h4 id="-18"><a class="markdownIt-Anchor" href="#-18"></a></h4><p>6.3.4 输入字符串内容</p><p>使用循环让用户为每个数组元素输入字符串内容。</p><h4 id="-19"><a class="markdownIt-Anchor" href="#-19"></a></h4><p>6.3.5 显示字符串内容</p><p>使用循环显示所有输入的字符串。</p><h4 id="-20"><a class="markdownIt-Anchor" href="#-20"></a></h4><p>6.3.6 用户选择</p><p>提供选项让用户决定是否继续添加字符串或退出程序。</p><h4 id="-21"><a class="markdownIt-Anchor" href="#-21"></a></h4><p>6.3.7 释放内存</p><p>如果用户选择退出，释放已分配的内存。</p><h4 id="-22"><a class="markdownIt-Anchor" href="#-22"></a></h4><p>6.3.8 结束程序</p><p>退出程序。</p><h3 id="-23"><a class="markdownIt-Anchor" href="#-23"></a></h3><p>6.4 代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Enter the size of the string array: &quot;</span>;</span><br><span class="line">std::cin &gt;&gt; size;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Invalid array size. Size must be a positive integer.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">std::string* arr = <span class="keyword">new</span> std::string[size];</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输入字符串内容</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Enter &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; strings for the array:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">std::cin &gt;&gt; arr[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 显示字符串内容</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The array contents are:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">std::cout &lt;&lt; arr[i] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 用户选择</span></span><br><span class="line"><span class="type">char</span> choice;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Do you want to continue adding more strings? (y/n): &quot;</span>;</span><br><span class="line">std::cin &gt;&gt; choice;</span><br><span class="line">std::cin.<span class="built_in">ignore</span>(); <span class="comment">// 忽略换行符</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (choice == <span class="string">&#x27;y&#x27;</span> || choice == <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 如果用户选择继续，再次分配内存并输入字符串</span></span><br><span class="line">size *= <span class="number">2</span>; <span class="comment">// 假设我们每次翻倍</span></span><br><span class="line">std::string* newArr = <span class="keyword">new</span> std::string[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br><span class="line">arr = newArr;</span><br><span class="line"> </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Enter &quot;</span> &lt;&lt; size / <span class="number">2</span> &lt;&lt; <span class="string">&quot; additional strings:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size / <span class="number">2</span>; i &lt; size; ++i) &#123;</span><br><span class="line">std::cin &gt;&gt; arr[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 再次显示字符串内容（可选）</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="string">&#x27;n&#x27;</span> || choice == <span class="string">&#x27;N&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 如果用户选择退出，释放内存并退出程序</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Exiting program.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Invalid choice. Please enter &#x27;y&#x27; or &#x27;n&#x27;: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序演示了如何动态分配内存来创建一个字符串数组，如何让用户输入字符串内容，如何根据用户的选择动态调整数组大小，以及如何释放内存。同时，它也展示了基本的错误处理和用户交互。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://www.formeasy.cc">formeasy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.formeasy.cc/2025/07/10/C/C++%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%81/">http://www.formeasy.cc/2025/07/10/C/C++动态分配内存知识点！/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://www.formeasy.cc" target="_blank">易锦风的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a></div><div class="post-share"><div class="social-share" data-image="/img/cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/10/algo/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91%EF%BC%88Decision%20Tree%EF%BC%89/" title="【机器学习】决策树（Decision Tree）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/07/10/algo/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E5%86%B3%E7%AD%96%E6%A0%91%EF%BC%88Decision%20Tree%EF%BC%89/797984871ce756bea69a8e3cbcde1c5d.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【机器学习】决策树（Decision Tree）</div></div><div class="info-2"><div class="info-item-1">引入 决策树是一类预测模型，它代表的是对象属性与对象值之间的一种映射关系。树中每个节点表示某个对象，而每个分叉路径则代表某个可能的属性值，而每个叶节点则对应从根节点到该叶节点所经历的路径所表示的对象的值。 关于分类问题 这里主要考虑决策树基于分类问题的处理算法，分类问题和回归问题有个简单的判别方式：分类的目标属性是离散的，而回归的目标属性是连续的。 分类问题的步骤 1、模型构建：通过对训练集合的归纳，利用归纳算法生成可读的规则，建立分类模型。 2、预测推论：根据规则和建立的分类模型，对测试集合进行测试，并处理新的数据。 ...</div></div></div></a><a class="pagination-related" href="/2025/07/10/C/C++%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="C++之红黑树认识与实现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/07/10/C/C++%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/d6e48fbd9ca54c63aa684f0bcbe9ccf5.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C++之红黑树认识与实现</div></div><div class="info-2"><div class="info-item-1">一.红黑树的概念 红⿊树是⼀棵⼆叉搜索树，他的每个结点增加⼀个存储位来表⽰结点的颜⾊，可以是红⾊或者⿊⾊。通过对任何⼀条从根到叶⼦的路径上各个结点的颜⾊进⾏约束，红⿊树确保没有⼀条路径会⽐其他路径⻓出2倍，因⽽是接近平衡的。 红黑树的结构 123456789101112131415161718192021222324252627282930313233343536// 枚举值表⽰颜⾊ enum Colour&#123; RED, BLACK&#125;;template&lt;class K, class V&gt;struct RBTreeNode&#123; // 这⾥更新控制平衡也要加⼊parent指针 pair&lt;K, V&gt; _kv; RBTreeNode&lt;K, V&gt;* _left; RBTreeNode&lt;K, V&gt;* _right; RBTreeNode&lt;K, V&gt;* _parent; Colour _col; RBTreeNode(const pair&lt;K, V&gt;&amp; kv) :_kv(kv) ,...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/11/C/C++11%20%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%9Astdcopy_if%20%E4%B8%8E%20stdcopy_n/" title="C++11 算法详解：std::copy_if 与 std::copy_n"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-11</div><div class="info-item-2">C++11 算法详解：std::copy_if 与 std::copy_n</div></div><div class="info-2"><div class="info-item-1">引言 C++11 标准为算法库带来了诸多增强，其中 std::copy_if 和 std::copy_n 作为 std::copy 的补充，为元素复制操作提供了更精细的控制。这两个算法不仅简化了代码逻辑，还提升了可读性和性能。本文将深入探讨这两个算法的实现细节、使用场景及最佳实践，帮助开发者在实际项目中正确高效地应用它们。 std::copy_if：条件筛选复制 函数原型 12template&lt; class InputIt, class OutputIt, class UnaryPred &gt;OutputIt copy_if( InputIt first, InputIt last, OutputIt d_first, UnaryPred pred ); 核心功能 std::copy_if 从输入范围 [first, last) 中复制满足谓词 pred 的元素到目标范围（始于 d_first），并保持元素的相对顺序。该算法在 C++11 中引入，是对传统 std::copy 的条件化扩展。 ...</div></div></div></a><a class="pagination-related" href="/2025/01/23/C/c++%E4%B9%8B%E7%BB%84%E5%90%88%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E8%81%9A%E5%90%88%E5%8F%8A%E4%BE%9D%E8%B5%96/" title="c++之组合、继承、聚合及依赖"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-23</div><div class="info-item-2">c++之组合、继承、聚合及依赖</div></div><div class="info-2"><div class="info-item-1">在学习c++的过程中相信大家对这几个概念都不陌生。 c++中一些常用的设计模式都是由这几种特性组合而成。本文再从整体对这个概念或者特性进行简要的介绍。 组合 c++中类之间的一种关系叫做&quot;has-a&quot;的关系。这种关系表示的是一个类中包含另一类的对象，体现了“有一个”的关系。这个被包含的类一般以实例对象的形式存在，而非指针对象的形式存在。请看下面的示例: 12345678910111213141516171819class Engine&#123;	public: void start() &#123; cout&lt;&lt;&quot;引擎启动&quot;&lt;&lt;endl; &#125;&#125;class car&#123;private:	Engine engine; //这里以实例的形式存在，而非指针，在类关系中是组合的关系public:	void startCar()	&#123; engine.start(); //启动引擎	&#125;&#125; ...</div></div></div></a><a class="pagination-related" href="/2025/07/10/C/C++%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="C++之红黑树认识与实现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/07/10/C/C++%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/d6e48fbd9ca54c63aa684f0bcbe9ccf5.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-10</div><div class="info-item-2">C++之红黑树认识与实现</div></div><div class="info-2"><div class="info-item-1">一.红黑树的概念 红⿊树是⼀棵⼆叉搜索树，他的每个结点增加⼀个存储位来表⽰结点的颜⾊，可以是红⾊或者⿊⾊。通过对任何⼀条从根到叶⼦的路径上各个结点的颜⾊进⾏约束，红⿊树确保没有⼀条路径会⽐其他路径⻓出2倍，因⽽是接近平衡的。 红黑树的结构 123456789101112131415161718192021222324252627282930313233343536// 枚举值表⽰颜⾊ enum Colour&#123; RED, BLACK&#125;;template&lt;class K, class V&gt;struct RBTreeNode&#123; // 这⾥更新控制平衡也要加⼊parent指针 pair&lt;K, V&gt; _kv; RBTreeNode&lt;K, V&gt;* _left; RBTreeNode&lt;K, V&gt;* _right; RBTreeNode&lt;K, V&gt;* _parent; Colour _col; RBTreeNode(const pair&lt;K, V&gt;&amp; kv) :_kv(kv) ,...</div></div></div></a><a class="pagination-related" href="/2025/07/21/C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/" title="内存管理基础：数据结构的存储方式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/07/21/C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/6dbd55eda53d6550a09ffc9da8295446.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-21</div><div class="info-item-2">内存管理基础：数据结构的存储方式</div></div><div class="info-2"><div class="info-item-1">内存管理基础：数据结构的存储方式 想象一下你正在整理你的衣柜。有些衣服你会折叠整齐地放在抽屉里（连续存储），有些则挂在衣架上分散在衣柜各处（链式存储。计算机内存管理数据的方式其实和这个场景非常相似。今天，我们就来探讨一下数据结构在内存中的不同存储方式，以及它们各自的优缺点。 1. 连续存储结构 理解了衣柜的比喻后，我们来看看计算机中最基础的存储方式——连续存储。这种存储方式就像把衣服一件件紧密地叠放在抽屉里，每件衣服占据固定大小的空间，并且按照顺序排列。 1.1 数组的存储方式 数组是最典型的连续存储结构。让我们通过一个简单的例子来看看数组在内存中是如何存储的： 1int arr[5] = &#123;10, 20, 30, 40, 50&#125;; 上述代码定义了一个包含5个整数的数组。在内存中，这些元素会被连续地存储在一起。 以上流程图说明了数组在内存中的连续存储方式，每个元素占据4字节空间 1.2...</div></div></div></a><a class="pagination-related" href="/2025/07/11/C/vector%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/" title="vector的详细讲解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/07/11/C/vector%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/53d1d2e536204e609dc694bcb054ce9c.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-11</div><div class="info-item-2">vector的详细讲解</div></div><div class="info-2"><div class="info-item-1">1.vector的介绍及使用 1.1 vector的介绍 1. vector 是表示可变大小数组的序列容器。 2. 就像数组一样， vector 也采用的连续存储空间来存储元素。也就是意味着可以采用下标对 vector 的元素 进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自 动处理。 3. 本质讲， vector 使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小 为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是 一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector 并不会每次都重新分配大 小。 4. vector 分配空间策略： vector 会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存 储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是 对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。 5. 因此， vector...</div></div></div></a><a class="pagination-related" href="/2025/05/06/RPC/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8BGRPC%E5%9C%A8C++%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Windows系统下GRPC在C++中的使用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/05/06/RPC/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8BGRPC%E5%9C%A8C++%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/19d5dd5e7a6ab1333f210349af49e517.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-06</div><div class="info-item-2">Windows系统下GRPC在C++中的使用</div></div><div class="info-2"><div class="info-item-1">1. 准备工作 按照grpc官网的指引先做环境配置，选好版本，不同版本要求下载的软件不一样，先选的1.15.1版本，但是安装 Active State Perl 总是安装失败，于是后边换了新一点的版本。先说1.15.1版本的安装历程，网址：https://github.com/grpc/grpc/blob/v1.15.1/BUILDING.md （1） 安装vs2017 网址：https://my.visualstudio.com/Downloads?q=visual%20studio%202017&amp;wt.mc_id=omsftvscom~older-downloads 社区版不能下载，下载的专业版 点击下载，然后安装，安装时选择与C++相关的项。 （2）安装Git 直接索引到上面的链接Git，下载安装即可。 （3）安装CMake 索引到链接Download CMake，我选择的是二进制分布中的windows x64版本。 （4）安装Active State Perl 1）首先索引到网址Download &amp; Install Perl -...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly-icon.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">formeasy</div><div class="author-info-description">专注互联网和软件技术</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">199</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/formeasy"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/formeasy" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:formeasy@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">用学习，面对遭遇的变化；用斗志，面对每天的挫折；用坚持，面对失去的动力!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E6%80%9D%E6%83%B3"><span class="toc-number">1.</span> <span class="toc-text">1.动态分配内存的思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">2.动态分配内存的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">2.1内存分配函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE"><span class="toc-number">2.2.</span> <span class="toc-text">2.2动态内存的申请和释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.</span> <span class="toc-text">2.3内存碎片问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">3.动态分配内存的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E7%81%B5%E6%B4%BB%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 灵活分配内存空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E6%8F%90%E9%AB%98%E5%86%85%E5%AD%98%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 提高内存利用率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 动态数据结构的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 避免内存溢出和内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 提高程序的性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E6%80%BB%E7%BB%93"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">4.动态分配内存的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.1.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#411-%E7%A1%AE%E5%AE%9A%E9%9C%80%E8%A6%81%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 确定需要分配的内存大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-2"><span class="toc-number">4.1.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-3"><span class="toc-number">4.1.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-4"><span class="toc-number">4.1.4.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-5"><span class="toc-number">4.2.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E4%BB%A3%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">5.动态分配内存的分类及代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#-6"><span class="toc-number">5.1.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#-7"><span class="toc-number">5.1.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-8"><span class="toc-number">5.1.2.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-9"><span class="toc-number">5.2.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#-10"><span class="toc-number">5.2.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-11"><span class="toc-number">5.2.2.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-12"><span class="toc-number">5.3.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%83%E4%B9%A0"><span class="toc-number">6.</span> <span class="toc-text">6.动态分配内存的练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#61-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-13"><span class="toc-number">6.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-14"><span class="toc-number">6.3.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#-15"><span class="toc-number">6.3.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-16"><span class="toc-number">6.3.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-17"><span class="toc-number">6.3.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-18"><span class="toc-number">6.3.4.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-19"><span class="toc-number">6.3.5.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-20"><span class="toc-number">6.3.6.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-21"><span class="toc-number">6.3.7.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-22"><span class="toc-number">6.3.8.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-23"><span class="toc-number">6.4.</span> <span class="toc-text"></span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/27/Springboot/Spring%20Boot%203%20%E6%95%B4%E5%90%88%20MyBatis-Plus%20%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B/" title="Spring Boot 3 整合 MyBatis-Plus 完整示例"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Spring Boot 3 整合 MyBatis-Plus 完整示例"></a><div class="content"><a class="title" href="/2025/08/27/Springboot/Spring%20Boot%203%20%E6%95%B4%E5%90%88%20MyBatis-Plus%20%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B/" title="Spring Boot 3 整合 MyBatis-Plus 完整示例">Spring Boot 3 整合 MyBatis-Plus 完整示例</a><time datetime="2025-08-27T09:06:33.000Z" title="发表于 2025-08-27 17:06:33">2025-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/27/Springboot/SpringBoot%E6%95%B4%E5%90%88Spring%20Security%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/" title="SpringBoot整合Spring Security实现认证与授权"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/08/27/Springboot/SpringBoot%E6%95%B4%E5%90%88Spring%20Security%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/gqnkyc66e4gn2_9e13ac55ee084f79bb67aa80cffde80a.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="SpringBoot整合Spring Security实现认证与授权"></a><div class="content"><a class="title" href="/2025/08/27/Springboot/SpringBoot%E6%95%B4%E5%90%88Spring%20Security%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/" title="SpringBoot整合Spring Security实现认证与授权">SpringBoot整合Spring Security实现认证与授权</a><time datetime="2025-08-27T05:38:56.000Z" title="发表于 2025-08-27 13:38:56">2025-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/26/Springboot/Spring%20Boot%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(%E6%A1%88%E4%BE%8B%E7%AF%87)/" title="Spring Boot入门指南(案例篇)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/08/26/Springboot/Spring%20Boot%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(%E6%A1%88%E4%BE%8B%E7%AF%87)/baaa5c67e3754abe83e0bbb2f2e14c58.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Spring Boot入门指南(案例篇)"></a><div class="content"><a class="title" href="/2025/08/26/Springboot/Spring%20Boot%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(%E6%A1%88%E4%BE%8B%E7%AF%87)/" title="Spring Boot入门指南(案例篇)">Spring Boot入门指南(案例篇)</a><time datetime="2025-08-26T05:33:37.000Z" title="发表于 2025-08-26 13:33:37">2025-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/25/Springboot/IntelliJ%20IDEA-Gradle-SpringBoot%E6%90%AD%E5%BB%BA/" title="IntelliJ IDEA-Gradle-SpringBoot搭建"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/08/25/Springboot/IntelliJ%20IDEA-Gradle-SpringBoot%E6%90%AD%E5%BB%BA/bf20a8e746a740ac3d0d29d4bc6d8d3f.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="IntelliJ IDEA-Gradle-SpringBoot搭建"></a><div class="content"><a class="title" href="/2025/08/25/Springboot/IntelliJ%20IDEA-Gradle-SpringBoot%E6%90%AD%E5%BB%BA/" title="IntelliJ IDEA-Gradle-SpringBoot搭建">IntelliJ IDEA-Gradle-SpringBoot搭建</a><time datetime="2025-08-25T06:53:06.000Z" title="发表于 2025-08-25 14:53:06">2025-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/25/Springboot/Gradle%20%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%8B%E8%BD%BD/" title="Gradle 安装和下载"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/08/25/Springboot/Gradle%20%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%8B%E8%BD%BD/4fcfe740e4704d31b12c9cd7ca46c0d9.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Gradle 安装和下载"></a><div class="content"><a class="title" href="/2025/08/25/Springboot/Gradle%20%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%8B%E8%BD%BD/" title="Gradle 安装和下载">Gradle 安装和下载</a><time datetime="2025-08-25T06:27:17.000Z" title="发表于 2025-08-25 14:27:17">2025-08-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By formeasy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(async()=>{window.katex_js_css||(window.katex_js_css=!0,await btf.getCSS("https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"),await btf.getScript("https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js")),document.querySelectorAll("#article-container .katex").forEach(t=>t.classList.add("katex-show"))})()</script><script>(()=>{var e=()=>{var e;0!==(e=document.querySelectorAll("pre > code.mermaid")).length&&e.forEach(e=>{var t=document.createElement("pre"),n=(t.className="mermaid-src",t.hidden=!0,t.textContent=e.textContent,document.createElement("div"));n.className="mermaid-wrap",n.appendChild(t),e.parentNode.replaceWith(n)});const t=document.querySelectorAll("#article-container .mermaid-wrap");0!==t.length&&(e=()=>{{var e=t;window.loadMermaid=!0;const a="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";e.forEach((e,t)=>{const n=e.firstElementChild;e=`%%{init:{ 'theme':'${a}'}}%%
`+n.textContent,t=mermaid.render("mermaid-"+t,e);const d=e=>{n.insertAdjacentHTML("afterend",e)};"string"==typeof t?d(t):t.then(({svg:e})=>d(e))})}},btf.addGlobalFn("themeChange",e,"mermaid"),window.loadMermaid?e():btf.getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(e))};btf.addGlobalFn("encrypt",e,"mermaid"),window.pjax?e():document.addEventListener("DOMContentLoaded",e)})()</script><script>(()=>{const a=GLOBAL_CONFIG_SITE.isShuoshuo,s=null,n=t=>"dark"===t?"dark":"light";var t=(t=document,e)=>{e=a?{"data-mapping":"specific","data-term":e}:{"data-mapping":(s,"pathname")},e=(t=>{const a=document.createElement("script");return Object.entries(t).forEach(([t,e])=>{a.setAttribute(t,e)}),a})({src:"https://giscus.app/client.js","data-repo":"formeasy/blog","data-repo-id":"R_kgDOJ2sA5A","data-category-id":"DIC_kwDOJ2sA5M4CktKh","data-theme":n(document.documentElement.getAttribute("data-theme")),"data-reactions-enabled":"1",crossorigin:"anonymous",async:!0,...s,...e});t.querySelector("#giscus-wrap").appendChild(e),a&&(window.shuoshuoComment.destroyGiscus=()=>{t.children.length&&(t.innerHTML="",t.classList.add("no-comment"))})};btf.addGlobalFn("themeChange",t=>{var e=document.querySelector("#giscus-wrap iframe");e&&(t={giscus:{setConfig:{theme:n(t)}}},e.contentWindow.postMessage(t,"https://giscus.app"))},"giscus"),a?window.shuoshuoComment={loadComment:t}:t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="请输入搜索关键字" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>