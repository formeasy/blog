<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>C++11 算法详解：std::copy_if 与 std::copy_n | 易锦风的博客</title><meta name="author" content="formeasy"><meta name="copyright" content="formeasy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++11 算法详解：std::copy_if 与 std::copy_n"><meta property="og:type" content="article"><meta property="og:title" content="C++11 算法详解：std::copy_if 与 std::copy_n"><meta property="og:url" content="http://www.formeasy.cc/2025/07/11/C/C++11%20%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%9Astdcopy_if%20%E4%B8%8E%20stdcopy_n/index.html"><meta property="og:site_name" content="易锦风的博客"><meta property="og:description" content="C++11 算法详解：std::copy_if 与 std::copy_n"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.formeasy.cc/img/cover.png"><meta property="article:published_time" content="2025-07-11T02:12:20.000Z"><meta property="article:modified_time" content="2025-07-11T02:16:02.548Z"><meta property="article:author" content="formeasy"><meta property="article:tag" content="C"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://www.formeasy.cc/img/cover.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.formeasy.cc/2025/07/11/C/C++11%20%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%9Astdcopy_if%20%E4%B8%8E%20stdcopy_n/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{var e={set:(e,t,a)=>{a&&(a=Date.now()+864e5*a,localStorage.setItem(e,JSON.stringify({value:t,expiry:a})))},get:e=>{var t=localStorage.getItem(e);if(t){var{value:t,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return t;localStorage.removeItem(e)}}},t=(window.btf={saveToLocal:e,getScript:(o,n={})=>new Promise((e,t)=>{const a=document.createElement("script");a.src=o,a.async=!0,Object.entries(n).forEach(([e,t])=>a.setAttribute(e,t)),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),getCSS:(o,n)=>new Promise((e,t)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),addGlobalFn:(e,t,a=!1,o=window)=>{var n;e.startsWith("pjax")||((n=o.globalFn||{})[e]=n[e]||{},n[e][a||Object.keys(n[e]).length]=t,o.globalFn=n)}},()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")}),a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")},o=(btf.activateDarkMode=t,btf.activateLightMode=a,e.get("theme")),t=("dark"===o?t():"light"===o&&a(),e.get("aside-status"));void 0!==t&&document.documentElement.classList.toggle("hide-aside","hide"===t);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"C++11 算法详解：std::copy_if 与 std::copy_n",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,isShuoshuo:!1}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="易锦风的博客" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly-icon.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">200</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/cover.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/icon.png" alt="Logo"><span class="site-name">易锦风的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">C++11 算法详解：std::copy_if 与 std::copy_n</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++11 算法详解：std::copy_if 与 std::copy_n</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-11T02:12:20.000Z" title="发表于 2025-07-11 10:12:20">2025-07-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-11T02:16:02.548Z" title="更新于 2025-07-11 10:16:02">2025-07-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>7分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h3><p>C++11 标准为算法库带来了诸多增强，其中 <code>std::copy_if</code> 和 <code>std::copy_n</code> 作为 <code>std::copy</code> 的补充，为元素复制操作提供了更精细的控制。这两个算法不仅简化了代码逻辑，还提升了可读性和性能。本文将深入探讨这两个算法的实现细节、使用场景及最佳实践，帮助开发者在实际项目中正确高效地应用它们。</p><h3 id="stdcopy_if条件筛选复制"><a class="markdownIt-Anchor" href="#stdcopy_if条件筛选复制"></a> std::copy_if：条件筛选复制</h3><h4 id="函数原型"><a class="markdownIt-Anchor" href="#函数原型"></a> 函数原型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> OutputIt, <span class="keyword">class</span> UnaryPred &gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">copy_if</span><span class="params">( InputIt first, InputIt last, OutputIt d_first, UnaryPred pred )</span></span>;</span><br></pre></td></tr></table></figure><h4 id="核心功能"><a class="markdownIt-Anchor" href="#核心功能"></a> 核心功能</h4><p><code>std::copy_if</code> 从输入范围 <code>[first, last)</code> 中复制满足谓词 <code>pred</code> 的元素到目标范围（始于 <code>d_first</code>），并<strong>保持元素的相对顺序</strong>。该算法在 C++11 中引入，是对传统 <code>std::copy</code> 的条件化扩展。</p><h4 id="参数解析"><a class="markdownIt-Anchor" href="#参数解析"></a> 参数解析</h4><ul><li><strong>first/last</strong>：输入迭代器对，定义源元素范围。</li><li><strong>d_first</strong>：输出迭代器，指向目标范围的起始位置。</li><li><strong>pred</strong>：一元谓词函数（可调用对象），返回 <code>bool</code> 类型，用于判断元素是否应被复制。</li></ul><blockquote><p><strong>注意</strong>：谓词 <code>pred</code> 不得修改输入元素，其<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B&amp;spm=1001.2101.3001.7020">参数类型</a>通常为 <code>const T&amp;</code>。</p></blockquote><h4 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h4><p>返回目标范围中最后一个被复制元素的下一个位置<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&amp;spm=1001.2101.3001.7020">迭代器</a>，便于后续操作（如继续添加元素）。</p><h4 id="实现逻辑"><a class="markdownIt-Anchor" href="#实现逻辑"></a> 实现逻辑</h4><p>cppreference 提供的参考实现清晰展示了其工作原理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> OutputIt, <span class="keyword">class</span> UnaryPred&gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">copy_if</span><span class="params">(InputIt first, InputIt last, OutputIt d_first, UnaryPred pred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pred</span>(*first)) &#123;</span><br><span class="line">            *d_first = *first;</span><br><span class="line">            ++d_first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环遍历输入范围，对每个元素应用谓词判断，满足条件则复制到目标位置并移动目标迭代器。</p><h4 id="示例筛选容器中的偶数"><a class="markdownIt-Anchor" href="#示例筛选容器中的偶数"></a> 示例：筛选容器中的偶数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; src = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dest;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预留空间以避免多次扩容（性能优化）</span></span><br><span class="line">    dest.<span class="built_in">reserve</span>(src.<span class="built_in">size</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制所有偶数</span></span><br><span class="line">    std::<span class="built_in">copy_if</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(dest),</span><br><span class="line">                 [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果：2 4 6 8 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : dest) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h4><ol><li><strong>范围重叠</strong>：若目标范围与输入范围重叠，行为未定义。此时应考虑 <code>std::copy_backward</code>。</li><li><strong>谓词副作用</strong>：谓词函数不得修改输入元素，否则可能导致未定义行为。</li><li><strong>性能考量</strong>：对于大型容器，提前调用 <code>reserve</code> 为目标容器分配空间可避免多次内存分配。</li></ol><h3 id="stdcopy_n固定数量复制"><a class="markdownIt-Anchor" href="#stdcopy_n固定数量复制"></a> std::copy_n：固定数量复制</h3><h4 id="函数原型-2"><a class="markdownIt-Anchor" href="#函数原型-2"></a> 函数原型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> Size, <span class="keyword">class</span> OutputIt &gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">copy_n</span><span class="params">( InputIt first, Size count, OutputIt result )</span></span>;</span><br></pre></td></tr></table></figure><h4 id="核心功能-2"><a class="markdownIt-Anchor" href="#核心功能-2"></a> 核心功能</h4><p><code>std::copy_n</code> 从起始位置 <code>first</code> 复制<strong>恰好 <code>count</code> 个元素</strong>到目标范围（始于 <code>result</code>）。该算法同样在 C++11 中引入，填补了传统 <code>std::copy</code> 无法指定复制数量的空白。</p><h4 id="参数解析-2"><a class="markdownIt-Anchor" href="#参数解析-2"></a> 参数解析</h4><ul><li><strong>first</strong>：输入迭代器，指向源范围的起始位置。</li><li><strong>count</strong>：要复制的元素数量（若为负数，行为未定义）。</li><li><strong>result</strong>：输出迭代器，指向目标范围的起始位置。</li></ul><h4 id="返回值-2"><a class="markdownIt-Anchor" href="#返回值-2"></a> 返回值</h4><p>返回目标范围中最后一个被复制元素的下一个位置迭代器（若 <code>count</code> 为 0，则返回 <code>result</code>）。</p><h4 id="实现逻辑-2"><a class="markdownIt-Anchor" href="#实现逻辑-2"></a> 实现逻辑</h4><p>参考实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> Size, <span class="keyword">class</span> OutputIt&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> OutputIt <span class="title">copy_n</span><span class="params">(InputIt first, Size count, OutputIt result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *result = *first;</span><br><span class="line">        ++result;</span><br><span class="line">        <span class="keyword">for</span> (Size i = <span class="number">1</span>; i != count; ++i, (<span class="type">void</span>)++result) &#123;</span><br><span class="line">            *result = *++first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先处理 <code>count &gt; 0</code> 的情况，复制首个元素后循环复制剩余 <code>count-1</code> 个元素。</p><h4 id="示例复制前-n-个元素"><a class="markdownIt-Anchor" href="#示例复制前-n-个元素"></a> 示例：复制前 N 个元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">src</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), <span class="number">1</span>); <span class="comment">// 填充 1~100</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dest</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 复制前 5 个元素（1,2,3,4,5）</span></span><br><span class="line">    std::<span class="built_in">copy_n</span>(src.<span class="built_in">begin</span>(), <span class="number">5</span>, dest.<span class="built_in">begin</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果：1 2 3 4 5 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : dest) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项-2"><a class="markdownIt-Anchor" href="#注意事项-2"></a> 注意事项</h4><ol><li><strong>目标空间不足</strong>：若目标容器容量小于 <code>count</code>，会导致缓冲区溢出（未定义行为）。</li><li><strong>负数 count</strong>：标准明确规定 <code>count</code> 为负数时行为未定义，实际使用中应确保其非负。</li><li><strong>迭代器类型</strong>：输入迭代器只需满足 <code>LegacyInputIterator</code>，但随机访问迭代器可提升性能（支持 <code>first + i</code> 直接访问）。</li></ol><h3 id="对比分析与应用场景"><a class="markdownIt-Anchor" href="#对比分析与应用场景"></a> 对比分析与应用场景</h3><h4 id="功能差异"><a class="markdownIt-Anchor" href="#功能差异"></a> 功能差异</h4><table><thead><tr><th>特性</th><th><code>std::copy_if</code></th><th><code>std::copy_n</code></th></tr></thead><tbody><tr><td><strong>核心逻辑</strong></td><td>条件筛选复制</td><td>固定数量复制</td></tr><tr><td><strong>关键参数</strong></td><td>谓词函数 <code>pred</code></td><td>元素数量 <code>count</code></td></tr><tr><td><strong>元素数量</strong></td><td>取决于谓词匹配结果</td><td>严格等于 <code>count</code>（若源足够）</td></tr><tr><td><strong>顺序保证</strong></td><td>保持源范围中的相对顺序</td><td>按源范围顺序复制</td></tr></tbody></table><h4 id="性能对比"><a class="markdownIt-Anchor" href="#性能对比"></a> 性能对比</h4><ul><li><strong><code>std::copy_if</code></strong>：需对每个元素执行谓词判断，时间复杂度为 <strong>O(N)</strong>（N 为输入范围大小），但实际复制次数可能小于 N。</li><li><strong><code>std::copy_n</code></strong>：时间复杂度为 <strong>O(count)</strong>，无额外判断开销，适合已知复制数量的场景。</li></ul><blockquote><p><strong>优化提示</strong>：当源迭代器为 <code>LegacyContiguousIterator</code>（如 <code>std::vector::iterator</code>）且元素类型为 <code>TriviallyCopyable</code> 时，编译器可能将 <code>std::copy_n</code> 优化为 <code>memmove</code>，大幅提升性能。</p></blockquote><h4 id="典型应用场景"><a class="markdownIt-Anchor" href="#典型应用场景"></a> 典型应用场景</h4><h5 id="stdcopy_if-适用场景"><a class="markdownIt-Anchor" href="#stdcopy_if-适用场景"></a> <code>std::copy_if</code> 适用场景</h5><ul><li><strong>数据过滤</strong>：从容器中提取满足特定条件的元素（如筛选日志中的错误信息）。</li><li><strong>数据清洗</strong>：移除无效数据（如空字符串、负数等）。</li><li><strong>条件转换</strong>：结合 <code>std::back_inserter</code> 动态构建新容器。</li></ul><h5 id="stdcopy_n-适用场景"><a class="markdownIt-Anchor" href="#stdcopy_n-适用场景"></a> <code>std::copy_n</code> 适用场景</h5><ul><li><strong>批量数据处理</strong>：读取固定大小的数据包（如网络通信中的报文头）。</li><li><strong>截断/截取</strong>：获取容器的前 N 个元素（如分页显示前 10 条记录）。</li><li><strong>定长缓冲区填充</strong>：向固定大小的数组中复制数据。</li></ul><h3 id="最佳实践与常见陷阱"><a class="markdownIt-Anchor" href="#最佳实践与常见陷阱"></a> 最佳实践与常见陷阱</h3><h4 id="1-避免目标容器空间不足"><a class="markdownIt-Anchor" href="#1-避免目标容器空间不足"></a> 1. 避免目标容器空间不足</h4><p><strong>问题</strong>：使用 <code>std::copy_n</code> 时，若目标容器大小小于 <code>count</code>，会导致未定义行为。<br><strong>解决方案</strong>：提前确保目标容器有足够空间，或使用 <code>std::back_inserter</code> 自动扩容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：目标容器大小不足</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dest</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">copy_n</span>(src.<span class="built_in">begin</span>(), <span class="number">5</span>, dest.<span class="built_in">begin</span>()); <span class="comment">// 缓冲区溢出！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例：使用 back_inserter</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; dest;</span><br><span class="line">std::<span class="built_in">copy_n</span>(src.<span class="built_in">begin</span>(), <span class="number">5</span>, std::<span class="built_in">back_inserter</span>(dest)); <span class="comment">// 自动扩容</span></span><br></pre></td></tr></table></figure><h4 id="2-谓词函数的设计"><a class="markdownIt-Anchor" href="#2-谓词函数的设计"></a> 2. 谓词函数的设计</h4><p><strong>问题</strong>：谓词函数修改输入元素或有副作用。<br><strong>解决方案</strong>：确保谓词为纯函数，仅依赖输入参数且无副作用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：谓词修改输入元素</span></span><br><span class="line">std::<span class="built_in">copy_if</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), dest.<span class="built_in">begin</span>(),</span><br><span class="line">             [](<span class="type">int</span>&amp; x) &#123; <span class="keyword">return</span> x++ &gt; <span class="number">5</span>; &#125;); <span class="comment">// 修改了 x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例：纯函数谓词</span></span><br><span class="line">std::<span class="built_in">copy_if</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), dest.<span class="built_in">begin</span>(),</span><br><span class="line">             [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; <span class="number">5</span>; &#125;); <span class="comment">// 仅读取 x</span></span><br></pre></td></tr></table></figure><h4 id="3-处理重叠范围"><a class="markdownIt-Anchor" href="#3-处理重叠范围"></a> 3. 处理重叠范围</h4><p><strong>问题</strong>：源范围与目标范围重叠时使用 <code>std::copy_if</code> 或 <code>std::copy_n</code>。<br><strong>解决方案</strong>：若需复制到右侧重叠区域，使用 <code>std::copy_backward</code>；若需条件复制，手动实现安全逻辑。</p><h4 id="4-与其他算法的配合"><a class="markdownIt-Anchor" href="#4-与其他算法的配合"></a> 4. 与其他算法的配合</h4><p>结合 <code>std::distance</code> 和 <code>std::copy_n</code> 可实现动态数量复制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制两个迭代器之间的元素（等价于 std::copy）</span></span><br><span class="line"><span class="keyword">auto</span> n = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line">std::<span class="built_in">copy_n</span>(first, n, result);</span><br></pre></td></tr></table></figure><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p><code>std::copy_if</code> 和 <code>std::copy_n</code> 作为 C++11 引入的算法，为元素复制提供了更灵活的选择。前者擅长<strong>条件筛选</strong>，后者专注<strong>固定数量复制</strong>，二者相辅相成，可大幅简化代码并提升可读性。实际使用中，需注意目标容器空间、迭代器类型及范围重叠等问题，结合具体场景选择合适的算法。</p><p>现代 C++ 倡导使用标准算法而非手动循环，这不仅能减少错误，还能让代码更具表达力。掌握这些算法的细节，将有助于写出更高效、更优雅的 C++ 代码。</p><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><ol><li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm/copy">cppreference.com - std::copy_if</a></li><li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm/copy_n">cppreference.com - std::copy_n</a></li><li>ISO/IEC 14882:2011 (C++11 Standard), § 25.3.1]</li></ol></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://www.formeasy.cc">formeasy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.formeasy.cc/2025/07/11/C/C++11%20%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%9Astdcopy_if%20%E4%B8%8E%20stdcopy_n/">http://www.formeasy.cc/2025/07/11/C/C++11 算法详解：stdcopy_if 与 stdcopy_n/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://www.formeasy.cc" target="_blank">易锦风的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a></div><div class="post-share"><div class="social-share" data-image="/img/cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/11/Docker/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="Docker常用命令"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/07/11/Docker/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/86e1ca153e50424cac6fd5d903b490bf.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Docker常用命令</div></div><div class="info-2"><div class="info-item-1">Docker 通过镜像 (Image) 和容器 (Container) 两个核心概念，极大地简化了应用的构建、分发和运行。掌握相关的命令行工具是高效使用 Docker 的关键。 思维导图 一、Docker 镜像 (Image) 常用命令 镜像是一个只读的模板，包含了运行应用程序所需的文件系统、库、依赖和代码。容器是镜像的一个可运行实例。 1. 搜索镜像 (search) 从 Docker Hub (默认的公共镜像仓库) 搜索可用的镜像。 1docker search &lt;image_name&gt; 代码案例： 搜索所有与 nginx 相关的镜像。 1docker search nginx 2. 拉取镜像 (pull) 从仓库下载一个镜像到本地。 1docker pull &lt;image_name&gt;[:tag] [:tag]: 可选。指定镜像的版本标签。如果不指定，默认拉取 latest 标签。 代码案例： 12345# 拉取最新版本的 Ubuntu 镜像docker pull ubuntu# 拉取指定版本的 Redis 镜像docker...</div></div></div></a><a class="pagination-related" href="/2025/07/11/Ubuntu/%E3%80%90ubuntu%E3%80%91%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%B3%BB%E7%BB%9F%E8%AF%A6%E6%83%85/" title="【ubuntu】查看端口占用情况，以及系统详情"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【ubuntu】查看端口占用情况，以及系统详情</div></div><div class="info-2"><div class="info-item-1">一、ubuntu 查看端口占用情况 在Ubuntu 系统中，你可以使用以下几种方法来查看端口占用情况以及检查指定端口是否被占用： 方法 1：使用 netstat 命令（传统方式） 12345# 查看所有端口占用情况sudo netstat -tulnp# 查看指定端口是否被占用（例如检查 80, 443, 3306 端口）sudo netstat -tulnp | grep -E &#x27;:(80|443|3306)\s&#x27; 选项说明： -t：显示 TCP 端口 -u：显示 UDP 端口 -l：仅显示监听中的端口 -n：以数字形式显示地址和端口 -p：显示进程信息 方法 2：使用 ss 命令（更现代的替代方案） 12345# 查看所有端口占用情况sudo ss -tulnp# 检查指定端口是否被占用（例如 80, 443, 3306）sudo ss -tulnp | grep -E &#x27;:(80|443|3306)\s&#x27; ss 命令比 netstat 更快，是推荐的现代替代方案。 方法 3：使用 lsof 命令 12345#...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/10/C/C++%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="C++之红黑树认识与实现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/07/10/C/C++%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/d6e48fbd9ca54c63aa684f0bcbe9ccf5.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-10</div><div class="info-item-2">C++之红黑树认识与实现</div></div><div class="info-2"><div class="info-item-1">一.红黑树的概念 红⿊树是⼀棵⼆叉搜索树，他的每个结点增加⼀个存储位来表⽰结点的颜⾊，可以是红⾊或者⿊⾊。通过对任何⼀条从根到叶⼦的路径上各个结点的颜⾊进⾏约束，红⿊树确保没有⼀条路径会⽐其他路径⻓出2倍，因⽽是接近平衡的。 红黑树的结构 123456789101112131415161718192021222324252627282930313233343536// 枚举值表⽰颜⾊ enum Colour&#123; RED, BLACK&#125;;template&lt;class K, class V&gt;struct RBTreeNode&#123; // 这⾥更新控制平衡也要加⼊parent指针 pair&lt;K, V&gt; _kv; RBTreeNode&lt;K, V&gt;* _left; RBTreeNode&lt;K, V&gt;* _right; RBTreeNode&lt;K, V&gt;* _parent; Colour _col; RBTreeNode(const pair&lt;K, V&gt;&amp; kv) :_kv(kv) ,...</div></div></div></a><a class="pagination-related" href="/2025/07/10/C/C++%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%81/" title="C++动态分配内存知识点！"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-10</div><div class="info-item-2">C++动态分配内存知识点！</div></div><div class="info-2"><div class="info-item-1">1.动态分配内存的思想 动态分配内存是指在程序运行时根据需要动态地分配内存空间。这相对于静态分配内存来说，静态分配内存是在编译时固定地分配内存空间，而动态分配内存可以在程序运行期间根据实际需求进行内存的申请和释放，以提高内存的利用率和灵活性。 2.动态分配内存的概念 动态分配内存的概念包括以下几个方面： 2.1内存分配函数 动态分配内存需要使用内存分配函数，如C语言中的malloc()、calloc()、realloc()等，这些函数可以根据需要在运行时动态地分配一块连续的内存空间。 2.2动态内存的申请和释放 使用内存分配函数可以申请一块指定大小的内存空间，申请的内存空间可以在程序运行期间使用。使用完毕后，可以使用释放函数将内存空间释放，以便其他程序继续使用。 2.3内存碎片问题 动态分配内存可能会导致内存碎片问题。当频繁地进行内存分配和释放操作时，可能会在内存中留下一些未被使用的小块内存，这些小块内存无法被再次利用，导致内存的浪费。为了解决内存碎片问题，可以使用内存管理算法来进行内存的分配和释放操作。 ...</div></div></div></a><a class="pagination-related" href="/2025/01/23/C/c++%E4%B9%8B%E7%BB%84%E5%90%88%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E8%81%9A%E5%90%88%E5%8F%8A%E4%BE%9D%E8%B5%96/" title="c++之组合、继承、聚合及依赖"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-23</div><div class="info-item-2">c++之组合、继承、聚合及依赖</div></div><div class="info-2"><div class="info-item-1">在学习c++的过程中相信大家对这几个概念都不陌生。 c++中一些常用的设计模式都是由这几种特性组合而成。本文再从整体对这个概念或者特性进行简要的介绍。 组合 c++中类之间的一种关系叫做&quot;has-a&quot;的关系。这种关系表示的是一个类中包含另一类的对象，体现了“有一个”的关系。这个被包含的类一般以实例对象的形式存在，而非指针对象的形式存在。请看下面的示例: 12345678910111213141516171819class Engine&#123;	public: void start() &#123; cout&lt;&lt;&quot;引擎启动&quot;&lt;&lt;endl; &#125;&#125;class car&#123;private:	Engine engine; //这里以实例的形式存在，而非指针，在类关系中是组合的关系public:	void startCar()	&#123; engine.start(); //启动引擎	&#125;&#125; ...</div></div></div></a><a class="pagination-related" href="/2025/07/21/C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/" title="内存管理基础：数据结构的存储方式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/07/21/C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/6dbd55eda53d6550a09ffc9da8295446.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-21</div><div class="info-item-2">内存管理基础：数据结构的存储方式</div></div><div class="info-2"><div class="info-item-1">内存管理基础：数据结构的存储方式 想象一下你正在整理你的衣柜。有些衣服你会折叠整齐地放在抽屉里（连续存储），有些则挂在衣架上分散在衣柜各处（链式存储。计算机内存管理数据的方式其实和这个场景非常相似。今天，我们就来探讨一下数据结构在内存中的不同存储方式，以及它们各自的优缺点。 1. 连续存储结构 理解了衣柜的比喻后，我们来看看计算机中最基础的存储方式——连续存储。这种存储方式就像把衣服一件件紧密地叠放在抽屉里，每件衣服占据固定大小的空间，并且按照顺序排列。 1.1 数组的存储方式 数组是最典型的连续存储结构。让我们通过一个简单的例子来看看数组在内存中是如何存储的： 1int arr[5] = &#123;10, 20, 30, 40, 50&#125;; 上述代码定义了一个包含5个整数的数组。在内存中，这些元素会被连续地存储在一起。 以上流程图说明了数组在内存中的连续存储方式，每个元素占据4字节空间 1.2...</div></div></div></a><a class="pagination-related" href="/2025/07/11/C/vector%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/" title="vector的详细讲解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/07/11/C/vector%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/53d1d2e536204e609dc694bcb054ce9c.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-11</div><div class="info-item-2">vector的详细讲解</div></div><div class="info-2"><div class="info-item-1">1.vector的介绍及使用 1.1 vector的介绍 1. vector 是表示可变大小数组的序列容器。 2. 就像数组一样， vector 也采用的连续存储空间来存储元素。也就是意味着可以采用下标对 vector 的元素 进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自 动处理。 3. 本质讲， vector 使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小 为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是 一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector 并不会每次都重新分配大 小。 4. vector 分配空间策略： vector 会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存 储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是 对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。 5. 因此， vector...</div></div></div></a><a class="pagination-related" href="/2025/04/30/RPC/GRPC%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="GRPC 快速入门"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-30</div><div class="info-item-2">GRPC 快速入门</div></div><div class="info-2"><div class="info-item-1">1. 背景介绍 gRPC全称Google Remote Procedure Call. 它是一种基于Protobuf buffer 格式的高效的通讯协议。与许多 RPC 系统一样，gRPC 基于定义服务的理念，指定可以远程调用的方法及其参数和返回类型。在服务器端，服务器实现此接口并运行 gRPC 服务器以处理客户端调用。在客户端，客户端具有一个存根（在某些语言中称为客户端），它提供与服务器相同的 方法。 2. 快速入门 安装 cmake 您需要 cmake 的 3.13 版或更高版本。请按照以下说明进行安装 Linux 1sudo apt install -y cmake macOS 1brew install cmake 安装其他必需工具 Linux 1sudo apt install -y build-essential autoconf libtool pkg-config macOS 1brew install autoconf automake libtool pkg-config 克隆 grpc 仓库 设置安装路径 123export...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly-icon.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">formeasy</div><div class="author-info-description">专注互联网和软件技术</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">200</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/formeasy"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/formeasy" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:formeasy@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">用学习，面对遭遇的变化；用斗志，面对每天的挫折；用坚持，面对失去的动力!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stdcopy_if%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E5%A4%8D%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">std::copy_if：条件筛选复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">核心功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">参数解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.4.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91"><span class="toc-number">2.5.</span> <span class="toc-text">实现逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E7%AD%9B%E9%80%89%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%81%B6%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">示例：筛选容器中的偶数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.7.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stdcopy_n%E5%9B%BA%E5%AE%9A%E6%95%B0%E9%87%8F%E5%A4%8D%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">std::copy_n：固定数量复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-2"><span class="toc-number">3.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD-2"><span class="toc-number">3.2.</span> <span class="toc-text">核心功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90-2"><span class="toc-number">3.3.</span> <span class="toc-text">参数解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="toc-number">3.4.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91-2"><span class="toc-number">3.5.</span> <span class="toc-text">实现逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%A4%8D%E5%88%B6%E5%89%8D-n-%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">3.6.</span> <span class="toc-text">示例：复制前 N 个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">3.7.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.</span> <span class="toc-text">对比分析与应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%B7%AE%E5%BC%82"><span class="toc-number">4.1.</span> <span class="toc-text">功能差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">4.2.</span> <span class="toc-text">性能对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.3.</span> <span class="toc-text">典型应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#stdcopy_if-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.3.1.</span> <span class="toc-text">std::copy_if 适用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stdcopy_n-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.3.2.</span> <span class="toc-text">std::copy_n 适用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1"><span class="toc-number">5.</span> <span class="toc-text">最佳实践与常见陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%81%BF%E5%85%8D%E7%9B%AE%E6%A0%87%E5%AE%B9%E5%99%A8%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3"><span class="toc-number">5.1.</span> <span class="toc-text">1. 避免目标容器空间不足</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B0%93%E8%AF%8D%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.2.</span> <span class="toc-text">2. 谓词函数的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%84%E7%90%86%E9%87%8D%E5%8F%A0%E8%8C%83%E5%9B%B4"><span class="toc-number">5.3.</span> <span class="toc-text">3. 处理重叠范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%8E%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95%E7%9A%84%E9%85%8D%E5%90%88"><span class="toc-number">5.4.</span> <span class="toc-text">4. 与其他算法的配合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/04/Other/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A4%B4%E5%8F%91%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A%EF%BC%9A%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%91%E9%99%85%E7%BA%BF%E7%9A%84%E7%A7%91%E5%AD%A6%E6%8E%A2%E7%B4%A2/" title="程序员头发研究报告：从代码到发际线的科学探索"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/09/04/Other/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A4%B4%E5%8F%91%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A%EF%BC%9A%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%91%E9%99%85%E7%BA%BF%E7%9A%84%E7%A7%91%E5%AD%A6%E6%8E%A2%E7%B4%A2/eb931b13e76647dbb8400b9d52e70dfc.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="程序员头发研究报告：从代码到发际线的科学探索"></a><div class="content"><a class="title" href="/2025/09/04/Other/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A4%B4%E5%8F%91%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A%EF%BC%9A%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%91%E9%99%85%E7%BA%BF%E7%9A%84%E7%A7%91%E5%AD%A6%E6%8E%A2%E7%B4%A2/" title="程序员头发研究报告：从代码到发际线的科学探索">程序员头发研究报告：从代码到发际线的科学探索</a><time datetime="2025-09-04T06:42:12.000Z" title="发表于 2025-09-04 14:42:12">2025-09-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/27/Springboot/Spring%20Boot%203%20%E6%95%B4%E5%90%88%20MyBatis-Plus%20%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B/" title="Spring Boot 3 整合 MyBatis-Plus 完整示例"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Spring Boot 3 整合 MyBatis-Plus 完整示例"></a><div class="content"><a class="title" href="/2025/08/27/Springboot/Spring%20Boot%203%20%E6%95%B4%E5%90%88%20MyBatis-Plus%20%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B/" title="Spring Boot 3 整合 MyBatis-Plus 完整示例">Spring Boot 3 整合 MyBatis-Plus 完整示例</a><time datetime="2025-08-27T09:06:33.000Z" title="发表于 2025-08-27 17:06:33">2025-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/27/Springboot/SpringBoot%E6%95%B4%E5%90%88Spring%20Security%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/" title="SpringBoot整合Spring Security实现认证与授权"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/08/27/Springboot/SpringBoot%E6%95%B4%E5%90%88Spring%20Security%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/gqnkyc66e4gn2_9e13ac55ee084f79bb67aa80cffde80a.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="SpringBoot整合Spring Security实现认证与授权"></a><div class="content"><a class="title" href="/2025/08/27/Springboot/SpringBoot%E6%95%B4%E5%90%88Spring%20Security%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/" title="SpringBoot整合Spring Security实现认证与授权">SpringBoot整合Spring Security实现认证与授权</a><time datetime="2025-08-27T05:38:56.000Z" title="发表于 2025-08-27 13:38:56">2025-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/26/Springboot/Spring%20Boot%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(%E6%A1%88%E4%BE%8B%E7%AF%87)/" title="Spring Boot入门指南(案例篇)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/08/26/Springboot/Spring%20Boot%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(%E6%A1%88%E4%BE%8B%E7%AF%87)/baaa5c67e3754abe83e0bbb2f2e14c58.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Spring Boot入门指南(案例篇)"></a><div class="content"><a class="title" href="/2025/08/26/Springboot/Spring%20Boot%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(%E6%A1%88%E4%BE%8B%E7%AF%87)/" title="Spring Boot入门指南(案例篇)">Spring Boot入门指南(案例篇)</a><time datetime="2025-08-26T05:33:37.000Z" title="发表于 2025-08-26 13:33:37">2025-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/25/Springboot/IntelliJ%20IDEA-Gradle-SpringBoot%E6%90%AD%E5%BB%BA/" title="IntelliJ IDEA-Gradle-SpringBoot搭建"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2025/08/25/Springboot/IntelliJ%20IDEA-Gradle-SpringBoot%E6%90%AD%E5%BB%BA/bf20a8e746a740ac3d0d29d4bc6d8d3f.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="IntelliJ IDEA-Gradle-SpringBoot搭建"></a><div class="content"><a class="title" href="/2025/08/25/Springboot/IntelliJ%20IDEA-Gradle-SpringBoot%E6%90%AD%E5%BB%BA/" title="IntelliJ IDEA-Gradle-SpringBoot搭建">IntelliJ IDEA-Gradle-SpringBoot搭建</a><time datetime="2025-08-25T06:53:06.000Z" title="发表于 2025-08-25 14:53:06">2025-08-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By formeasy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(async()=>{window.katex_js_css||(window.katex_js_css=!0,await btf.getCSS("https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"),await btf.getScript("https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js")),document.querySelectorAll("#article-container .katex").forEach(t=>t.classList.add("katex-show"))})()</script><script>(()=>{var e=()=>{var e;0!==(e=document.querySelectorAll("pre > code.mermaid")).length&&e.forEach(e=>{var t=document.createElement("pre"),n=(t.className="mermaid-src",t.hidden=!0,t.textContent=e.textContent,document.createElement("div"));n.className="mermaid-wrap",n.appendChild(t),e.parentNode.replaceWith(n)});const t=document.querySelectorAll("#article-container .mermaid-wrap");0!==t.length&&(e=()=>{{var e=t;window.loadMermaid=!0;const a="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";e.forEach((e,t)=>{const n=e.firstElementChild;e=`%%{init:{ 'theme':'${a}'}}%%
`+n.textContent,t=mermaid.render("mermaid-"+t,e);const d=e=>{n.insertAdjacentHTML("afterend",e)};"string"==typeof t?d(t):t.then(({svg:e})=>d(e))})}},btf.addGlobalFn("themeChange",e,"mermaid"),window.loadMermaid?e():btf.getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(e))};btf.addGlobalFn("encrypt",e,"mermaid"),window.pjax?e():document.addEventListener("DOMContentLoaded",e)})()</script><script>(()=>{const a=GLOBAL_CONFIG_SITE.isShuoshuo,s=null,n=t=>"dark"===t?"dark":"light";var t=(t=document,e)=>{e=a?{"data-mapping":"specific","data-term":e}:{"data-mapping":(s,"pathname")},e=(t=>{const a=document.createElement("script");return Object.entries(t).forEach(([t,e])=>{a.setAttribute(t,e)}),a})({src:"https://giscus.app/client.js","data-repo":"formeasy/blog","data-repo-id":"R_kgDOJ2sA5A","data-category-id":"DIC_kwDOJ2sA5M4CktKh","data-theme":n(document.documentElement.getAttribute("data-theme")),"data-reactions-enabled":"1",crossorigin:"anonymous",async:!0,...s,...e});t.querySelector("#giscus-wrap").appendChild(e),a&&(window.shuoshuoComment.destroyGiscus=()=>{t.children.length&&(t.innerHTML="",t.classList.add("no-comment"))})};btf.addGlobalFn("themeChange",t=>{var e=document.querySelector("#giscus-wrap iframe");e&&(t={giscus:{setConfig:{theme:n(t)}}},e.contentWindow.postMessage(t,"https://giscus.app"))},"giscus"),a?window.shuoshuoComment={loadComment:t}:t()})()</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="请输入搜索关键字" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>