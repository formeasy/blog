<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>易锦风的博客</title>
  
  <subtitle>专注互联网和软件技术</subtitle>
  <link href="http://www.formeasy.cc/atom.xml" rel="self"/>
  
  <link href="http://www.formeasy.cc/"/>
  <updated>2025-11-09T14:58:10.762Z</updated>
  <id>http://www.formeasy.cc/</id>
  
  <author>
    <name>formeasy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UE5中使用HDRI</title>
    <link href="http://www.formeasy.cc/2025/11/09/UE/UE5%E4%B8%AD%E4%BD%BF%E7%94%A8HDRI/"/>
    <id>http://www.formeasy.cc/2025/11/09/UE/UE5%E4%B8%AD%E4%BD%BF%E7%94%A8HDRI/</id>
    <published>2025-11-09T14:36:33.000Z</published>
    <updated>2025-11-09T14:58:10.762Z</updated>
    
    <content type="html"><![CDATA[<p>UE5中默认的场景配置中包含：DirectionalLight直射光、ExponentialHeightFog指数高度雾、SkyAtmosphere天空大气、SkyLight天光、VolumetricCloud体积云。</p><p>上述这些是一套模拟现实环境的组件，但是有些情况可能需要一个天空盒就够了。</p><p>在Unity中默认是使用天空盒，是没有边界的。</p><p>在UE5中，使用HDRI高动态范围图像，也可以使用它当菜单背景，这个功能是在插件中。</p><h2 id="开启hdribackdrop"><a class="markdownIt-Anchor" href="#开启hdribackdrop"></a> 开启HDRIBackdrop</h2><p><img src="v2-61bd879743ddfd5d2ccdc74cea01a0d5_1440w.jpg" alt="" /></p><h2 id="添加hdri"><a class="markdownIt-Anchor" href="#添加hdri"></a> 添加HDRI</h2><p>开启HDRIBackdrop插件之后，就可以在Lights灯光组件中找到它。</p><p><img src="v2-c86a8624662ba62e379558337a8ad9f9_1440w.jpg" alt="" /></p><h2 id="hdri天圆地方"><a class="markdownIt-Anchor" href="#hdri天圆地方"></a> HDRI—天圆地方</h2><p>虚幻中这个HDRI是模拟了一个天圆地方的状态，默认有一个示例4K的图像。</p><p><img src="v2-c6c7e74bde8f416ea8c9f6c08a31daa5_1440w.jpg" alt="" /></p><p>HDRI是有一个十分明确的轮廓的，一个半球+四周高中间低的圆弧面。</p><p><img src="v2-17ff793e1d2e352914ae60ad7813cce8_1440w.jpg" alt="" /><br />cube在原点</p><p><img src="v2-bc7df044fd166b848b4813a2f7f7cc50_1440w.jpg" alt="" /><br />cube在边缘处，高度都是0</p><p>上面可以看出来，使用HDRI，模型不能放在边缘位置，不然就露馅了！</p><h2 id="hdri参数"><a class="markdownIt-Anchor" href="#hdri参数"></a> HDRI参数</h2><p>HDRI主要有三个参数：</p><p>1.Intensity 强度 类似于天空的光照强度；</p><p>2.Size 大小 调正范围的；</p><p>3.Projection Center 投影中心</p><p>关于Projection Center，设置一下数据做个对比，这样容易理解它是干什么的！</p><p>极端状态，设置为（0，0，0），你会发现地面部分被严重拉伸了。</p><p><img src="v2-02a541e58b7d3ec8f0b34f7527ccc72a_1440w.jpg" alt="" /></p><p>默认状态，（0，0，170）</p><p><img src="v2-4b2ad0e547566d63d20ea1a2cdcd3cc0_1440w.jpg" alt="" /></p><p>默认状态，（0，0，170），边缘处还是被拉伸了</p><p><img src="v2-5dfc07c26be7c1ff991dab2b70745c71_1440w.jpg" alt="" /></p><p>参数为（0，0，1000）边缘处</p><p><img src="v2-3ea6f642675da91889c9e7f7e2a553bb_1440w.jpg" alt="" /></p><p>极端大（0，0，10000），地面被拉到天上去了！</p><p><img src="v2-c8e2e9e11cf063e26c34e11a845b2d33_1440w.jpg" alt="" /></p><p>参数根据需求调试就可以。</p>]]></content>
    
    
    <summary type="html">UE5中使用HDRI</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>UE5在VR中构建菜单和交互</title>
    <link href="http://www.formeasy.cc/2025/11/02/UE/UE5%E5%9C%A8VR%E4%B8%AD%E6%9E%84%E5%BB%BA%E8%8F%9C%E5%8D%95%E5%92%8C%E4%BA%A4%E4%BA%92/"/>
    <id>http://www.formeasy.cc/2025/11/02/UE/UE5%E5%9C%A8VR%E4%B8%AD%E6%9E%84%E5%BB%BA%E8%8F%9C%E5%8D%95%E5%92%8C%E4%BA%A4%E4%BA%92/</id>
    <published>2025-11-02T03:32:44.000Z</published>
    <updated>2025-11-02T05:18:09.934Z</updated>
    
    <content type="html"><![CDATA[<p>本例基于UE5.4</p><h2 id="1-创建或添加vr虚拟现实项目"><a class="markdownIt-Anchor" href="#1-创建或添加vr虚拟现实项目"></a> 1. 创建或添加VR（虚拟现实）项目</h2><p><img src="wechat_2025-11-02_114925_470.png" alt="" /></p><h2 id="2-创建用户界面"><a class="markdownIt-Anchor" href="#2-创建用户界面"></a> 2. 创建用户界面</h2><h3 id="1-创建用户控件"><a class="markdownIt-Anchor" href="#1-创建用户控件"></a> 1). 创建用户控件</h3><p>创建用户控件，起名为WD_MainMenu</p><p><img src="wechat_2025-11-02_114654_021.png" alt="" /></p><h3 id="2-在用户界面上添加控件"><a class="markdownIt-Anchor" href="#2-在用户界面上添加控件"></a> 2). 在用户界面上添加控件</h3><p>根据业务需要，添加背景图和按钮，并对按钮添加点击事件<br /><img src="wechat_2025-11-02_115333_352.png" alt="" /></p><p>比如添加退出事件<br /><img src="wechat_2025-11-02_115548_493.png" alt="" /></p><h2 id="3-在关卡中放置用户界面"><a class="markdownIt-Anchor" href="#3-在关卡中放置用户界面"></a> 3. 在关卡中放置用户界面</h2><h3 id="1-创建基于actor的蓝图类"><a class="markdownIt-Anchor" href="#1-创建基于actor的蓝图类"></a> 1). 创建基于Actor的蓝图类</h3><p>在内容浏览器右键，新建蓝图类，并创建基于Actor的蓝图类M_Menu</p><p><img src="wechat_2025-11-02_115957_844.png" alt="" /></p><h3 id="2-在蓝图类中创建widget"><a class="markdownIt-Anchor" href="#2-在蓝图类中创建widget"></a> 2). 在蓝图类中创建Widget</h3><p>双击打开蓝图类，并添加Widget</p><p><img src="wechat_2025-11-02_120328_845.png" alt="" /></p><h3 id="3-widget中选择控件类"><a class="markdownIt-Anchor" href="#3-widget中选择控件类"></a> 3). widget中选择控件类</h3><p>选中Widget，在详细面板中设置控件类为用户控件WD_MainMenu<br /><img src="wechat_2025-11-02_120644_506.png" alt="" /></p><p>调整大小，并将碰撞预设改为Custom</p><p><img src="wechat_2025-11-02_120955_447.png" alt="" /></p><h3 id="4-添加蓝图"><a class="markdownIt-Anchor" href="#4-添加蓝图"></a> 4). 添加蓝图</h3><p>将蓝图类M_Menu拖入到关卡中，设置好位置旋转和缩放</p><p>注意：默认拖入后，需要在Z轴旋转180度。</p><p><img src="wechat_2025-11-02_121441_158.png" alt="" /></p><h2 id="4-创建手柄交互"><a class="markdownIt-Anchor" href="#4-创建手柄交互"></a> 4. 创建手柄交互</h2><h3 id="1-在vrpawn添加控件交互子类"><a class="markdownIt-Anchor" href="#1-在vrpawn添加控件交互子类"></a> 1). 在VRPawn添加控件交互子类</h3><p>在内容浏览器中，打开进入到VRTemplate-&gt;Blueprints下，双击打开VRPawn视口</p><p>分别在MotionControllerLeftAim和MotionControllerRightAim下创建控件交互子类</p><p><img src="wechat_2025-11-02_121909_329.png" alt="" /></p><p><img src="wechat_2025-11-02_122053_210.png" alt="" /></p><h3 id="2-设置控件交互子类参数"><a class="markdownIt-Anchor" href="#2-设置控件交互子类参数"></a> 2). 设置控件交互子类参数</h3><p>分别选中刚才创建控件交互子类，在细节面板进行设置：</p><p><img src="wechat_2025-11-02_122633_511.png" alt="" /></p><p>其中：<br />交互下的：<br />Pointer Index是pointer的索引号，左右手分别设置0和1<br />Trace Channel 改为 WorldDynamic<br />Interaction Distance 手柄光束的距离<br />调试下的Show Debug 是否显示手柄光束<br />高级下的Debug Line Thickness 是手柄光束的粗度<br />Debug Color 是手柄光束的颜色，可以设置一手绿色一手为红色</p><p>运行如下图：<br /><img src="wechat_2025-11-02_123333_212.png" alt="" /></p><p>但是由于未添加轴映射，暂不能响应用户控件事件。</p><h2 id="5-创建手柄映射"><a class="markdownIt-Anchor" href="#5-创建手柄映射"></a> 5. 创建手柄映射</h2><h3 id="1-创建输入操作"><a class="markdownIt-Anchor" href="#1-创建输入操作"></a> 1). 创建输入操作</h3><p>在内容浏览器中，进入VRTemplate-&gt;Input-&gt;Actions，添加输入操作</p><p><img src="wechat_2025-11-02_125939_713.png" alt="" /></p><p>创建IA_Left和IA_Right：</p><p><img src="wechat_2025-11-02_130114_914.png" alt="" /></p><h3 id="2-添加映射键轴"><a class="markdownIt-Anchor" href="#2-添加映射键轴"></a> 2). 添加映射键轴</h3><p>进入到上一层VRTemplate-&gt;Input，双击打开IMC_Default</p><p><img src="wechat_2025-11-02_130504_515.png" alt="" /></p><p>分别在映射，添加IA_Left和IA_Right</p><p><img src="wechat_2025-11-02_130642_216.png" alt="" /></p><p>分别在映射IA_Left和IA_Right下，根据手柄型号添加扳机键轴</p><p><img src="wechat_2025-11-02_130834_017.png" alt="" /></p><h3 id="3-添加映射事件"><a class="markdownIt-Anchor" href="#3-添加映射事件"></a> 3). 添加映射事件</h3><p>进入到VRPawn的事件图表中，右键创建EnhancedInputAction IA_Left和EnhancedInputAction IA_Right事件<br />并将与创建的控件交互子类进行鼠标模拟</p><p><img src="wechat_2025-11-02_131423_018.png" alt="" /></p><p>左手与右手相同</p><p>以上，运行后就可以点击手柄并触发菜单上的事件</p>]]></content>
    
    
    <summary type="html">UE5在VR中构建菜单和交互</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>UE5编辑器辅助加强_插件搜集</title>
    <link href="http://www.formeasy.cc/2025/11/02/UE/UE5%E7%BC%96%E8%BE%91%E5%99%A8%E8%BE%85%E5%8A%A9%E5%8A%A0%E5%BC%BA_%E6%8F%92%E4%BB%B6%E6%90%9C%E9%9B%86/"/>
    <id>http://www.formeasy.cc/2025/11/02/UE/UE5%E7%BC%96%E8%BE%91%E5%99%A8%E8%BE%85%E5%8A%A9%E5%8A%A0%E5%BC%BA_%E6%8F%92%E4%BB%B6%E6%90%9C%E9%9B%86/</id>
    <published>2025-11-02T03:06:44.000Z</published>
    <updated>2025-11-02T05:18:59.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-actor-locker"><a class="markdownIt-Anchor" href="#1-actor-locker"></a> 1. Actor Locker</h2><blockquote><p>地址：<a href="https://www.fab.com/listings/ec26ac5e-4720-467c-a3a6-b5103b6b74d0">https://www.fab.com/listings/ec26ac5e-4720-467c-a3a6-b5103b6b74d0</a><br />使用说明：<a href="https://github.com/Gradess2019/ActorLocker">https://github.com/Gradess2019/ActorLocker</a><br />支持：5.0 – 5.5<br /><img src="989ebb24822b43a5844fc38a30c62100.png" alt="" /><br />简单的编辑器扩展。它允许你通过世界轮廓窗口/热键/上下文菜单在编辑器视图中锁定演员，所以锁定的演员不能被选中或移动，直到你解锁他们。</p></blockquote><p>【使用笔记】</p><ul><li>快捷全部关闭，与打开：</li><li>Alt + Shift +逗号 : 锁定所有</li><li>Alt + Shift +句点 : 解锁所有</li><li>Alt +斜线 : 切换已经选中的Actor</li></ul><hr /><h2 id="2-自动缩放批注插件autosizecomments"><a class="markdownIt-Anchor" href="#2-自动缩放批注插件autosizecomments"></a> 2. 自动缩放批注插件AutoSizeComments</h2><blockquote><p>地址：<a href="https://www.fab.com/listings/fdb7e77d-be37-4feb-a6c9-60e317c10adf">https://www.fab.com/listings/fdb7e77d-be37-4feb-a6c9-60e317c10adf</a><br />使用说明：<a href="https://autosizecomments.github.io/">https://autosizecomments.github.io/</a><br />支持：5.0 – 5.5<br /><img src="71446f3a899045738dd2d62fd7db9e0e.png" alt="" /><br />这个插件使评论框自动调整大小以适应里面的节点。</p></blockquote><p>【使用笔记】</p><ul><li>注释框里的节点不再会被随意拖动</li><li>按住Shift，可以重新拖动注释框，来确定要框住的节点</li><li>点左上的?号，可以随机切换颜色</li><li>点左上的?号，可以随机切换颜色</li><li>填写@关键字，利用编辑器设置，快速显示规定颜色<br /><img src="e39d62cf55f647fc89d6a71fe1c1e1b3.png" alt="" /><br /><img src="155a37ef670b44f4b17e009320828490.png" alt="" /></li></ul><hr /><h2 id="3-electronic-nodes"><a class="markdownIt-Anchor" href="#3-electronic-nodes"></a> 3. Electronic Nodes</h2><blockquote><p>地址：<a href="https://www.fab.com/listings/d6148766-27b1-47db-a730-832c53b7a895">https://www.fab.com/listings/d6148766-27b1-47db-a730-832c53b7a895</a><br />使用说明：<a href="https://github.com/hugoattal/ElectronicNodes/wiki/Getting-started">https://github.com/hugoattal/ElectronicNodes/wiki/Getting-started</a><br />支持：5.0 – 5.5<img src="e6806181e50047a0bbd3d69a1a331c3d.png" alt="" /><br />电子节点允许您在可视化脚本编辑器中更好地描绘您的逻辑</p></blockquote><p><img src="242022b0c9e140f4894523b8b1e5924c.gif" alt="" /></p><hr /><h2 id="4-flat-nodes"><a class="markdownIt-Anchor" href="#4-flat-nodes"></a> 4. Flat Nodes</h2><blockquote><p>地址：<a href="https://www.fab.com/listings/7305134c-8f1c-46f4-aa9c-14381074aba5">https://www.fab.com/listings/7305134c-8f1c-46f4-aa9c-14381074aba5</a><br />支持：5.0 – 5.5<br /><img src="9d2ab6da9fbe4fcda91b45d5270c444c.png" alt="" /><br />虚幻引擎图节点的极简风格。这个插件增加了一个简化的视觉外观，更扁平，我认为这使得图形更清晰，可读性更好。</p></blockquote><hr /><h2 id="5-outliner-shortcuts"><a class="markdownIt-Anchor" href="#5-outliner-shortcuts"></a> 5. Outliner Shortcuts</h2><blockquote><p>地址：<a href="https://www.fab.com/listings/9788d72d-b2bd-4181-8bf3-8a6eda69c2c8">https://www.fab.com/listings/9788d72d-b2bd-4181-8bf3-8a6eda69c2c8</a><br />使用说明：<a href="https://github.com/Voulz/OutlinerShortcuts/wiki">https://github.com/Voulz/OutlinerShortcuts/wiki</a><br />支持：5.0 – 5.5<br /><img src="91e20c38f9f040c0a9b183913b72db74.png" alt="" /><br />大纲视图快捷方式是仅编辑器插件这允许将快捷方式绑定到一些基本的世界大纲视图功能，如全部折叠和全部展开，并且还添加了一个新的功能折叠到根。<br />该插件的另一个功能是在地图打开时自动展开/折叠/折叠世界大纲视图。</p></blockquote><p>【使用说明】</p><ul><li>在编辑器设置里，搜索 Outline<br /><img src="9284e82d28e84bc199070ac28daba90b.png" alt="" /></li><li>有3个动作：</li></ul><ol><li>折叠世界大纲到编辑器<br /><img src="8af3af1e1057460eac2352817a2992ac.png" alt="" /></li><li>折叠世界大纲到第一层目录<br /><img src="4f552e4b367f45c6a0137adc27f09b84.png" alt="" /></li><li>展开世界大纲<br /><img src="61ae50b01e5042bb853411f5050b603b.png" alt="" /></li></ol><ul><li>我设置成z / x来做折叠与展开的快捷键<br /><img src="1ca771aa06d44b9180c63d98840bf24a.png" alt="" /></li></ul><hr /><h2 id="6-switchlanguage"><a class="markdownIt-Anchor" href="#6-switchlanguage"></a> 6. SwitchLanguage</h2><blockquote><p>地址：<a href="https://www.fab.com/listings/5a2e80d6-2afa-452d-892e-3ce119d4ceec">https://www.fab.com/listings/5a2e80d6-2afa-452d-892e-3ce119d4ceec</a><br />支持：5.0 – 5.5<br /><img src="e895bc82580245b0aaf54b9dc96780ca.png" alt="" /><br />单击按钮切换编辑器中显示的语言。目前只支持中英文切换。</p></blockquote><h2 id="7-assets-cleaner-project-cleaning-tool"><a class="markdownIt-Anchor" href="#7-assets-cleaner-project-cleaning-tool"></a> 7. Assets Cleaner - Project Cleaning Tool</h2><p>插件类型：编辑器资产管理<br />一句话推荐：资源清理器能快速列出项目中未使用的资产，并允许直接从工具中进行管理。通过轻松查找和移除闲置资源，帮助保持项目整洁高效。<br />下载地址：<a href="https://www.fab.com/zh-cn/listings/907039cf-f267-489e-afe4-7e74768e9b7a">Assets Cleaner - Project Cleaning Tool</a></p><p><img src="568b95dee9f649608d4180655201b6e0.png" alt="" /></p><h2 id="8-ueactorpool角色对象池"><a class="markdownIt-Anchor" href="#8-ueactorpool角色对象池"></a> 8. UEActorPool角色对象池</h2><p>插件类型：对象池管理<br />一句话推荐：开源免费且好用的对象池管理插件。<br />下载地址：<a href="https://github.com/TheEmidee/UEActorPool">UEActorPool</a></p><p><img src="94f49c61a72b4e47b9e5ccc39ebf8c54.png" alt="" /></p><h2 id="9-easy-logger"><a class="markdownIt-Anchor" href="#9-easy-logger"></a> 9. Easy Logger</h2><p>插件类型：调试日志打印<br />一句话推荐：虚幻引擎原生的UE_LOG不太好用，每次在新项目中写自定义的日志函数又太麻烦，用这个插件正好！<br />下载地址：<a href="https://www.fab.com/listings/114d5dcb-59ae-48fb-a31f-aa8e9066c3cd">Easy Logger</a></p><p><img src="594483bdee95491aa1759db9043f0288.png" alt="" /><br /><img src="2eeadefbd21b4af8bc68f00fe18de2a6.png" alt="" /></p><h2 id="10advancedsessionsplugin增强型会话插件"><a class="markdownIt-Anchor" href="#10advancedsessionsplugin增强型会话插件"></a> 10.AdvancedSessionsPlugin增强型会话插件</h2><p>AdvancedSessionsPlugin 是一个为 Unreal Engine 4（UE4）开发的插件，主要用于提升和扩展游戏内会话管理的功能。该项目的编程语言以 C++ 为主，辅以其他语言，为开发者提供了一个强大的工具来管理在线游戏中的玩家会话。</p><h3 id="核心功能"><a class="markdownIt-Anchor" href="#核心功能"></a> 核心功能</h3><ul><li>会话管理：允许开发者轻松创建、管理和维护游戏中的玩家会话。</li><li>跨平台支持：确保插件在所有支持 UE4 的平台上都能运行，包括 PC、游戏主机和移动设备。</li><li>高级特性：提供一系列高级功能，如玩家匹配、会话查找和会话配置等。</li><li>安全性：加强了会话的安全性，防止恶意行为和作弊。</li></ul><h3 id="最近更新的功能"><a class="markdownIt-Anchor" href="#最近更新的功能"></a> 最近更新的功能</h3><ul><li>改进的匹配算法：优化了玩家匹配的过程，提高了匹配的速度和准确性。</li><li>增强的会话配置选项：提供了更多的会话配置选项，让开发者可以更灵活地定制游戏会话。</li><li>性能优化：对插件的性能进行了全面优化，减少了资源消耗，提高了运行效率。</li><li>错误修复：修复了之前版本中的一些已知错误和问题，提高了插件的稳定性和可靠性。</li></ul><p>下载地址：<a href="https://github.com/mordentral/AdvancedSessionsPlugin">AdvancedSessionsPlugin</a></p>]]></content>
    
    
    <summary type="html">UE5编辑器辅助加强_插件搜集</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>UE5摄像机组件使用详解</title>
    <link href="http://www.formeasy.cc/2025/11/02/UE/UE5%E6%91%84%E5%83%8F%E6%9C%BA%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.formeasy.cc/2025/11/02/UE/UE5%E6%91%84%E5%83%8F%E6%9C%BA%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-11-02T00:50:41.000Z</published>
    <updated>2025-11-02T01:09:37.269Z</updated>
    
    <content type="html"><![CDATA[<p>摄像机是游戏开发中的重要组件之一，通过摄像机可以观察整个关卡，切换摄像机的视角可以实现不同的功能，如实现第一人称和第三人称视角。本文通过样例演示如何通控制两个摄像机的切换实现视角的变化。</p><h3 id="1添加摄像头"><a class="markdownIt-Anchor" href="#1添加摄像头"></a> 1，添加摄像头</h3><p>（1）新建一个“Actor”类蓝图并命名为“BP_CameraComponent”，并将其添加到关卡中。</p><p><img src="2025060415242665395.png" alt="" /></p><p>（2）双击打开&quot;BP_CameraComponent&quot; 蓝图，在“组件” 面板中单击“添加”按钮添加一个摄像机组件。若视口中出现摄像机模型，则代表加成功。</p><p><img src="2025060415264480815.png" alt="" /></p><p>（3）编译并保存后回到关卡中、从“内容浏览器”面板中拖曳 BP_CameraComponent 蓝图到关卡中，选择蓝图后，视口右下角会出现摄像机的视角。</p><p><img src="2025060415310284912.png" alt="" /></p><p>（4）打开“BP_CameraComponent”蓝图后再次添加一个摄像机组件，让两个摄像机存在于同一张蓝图中。</p><p><img src="2025060415364998638.png" alt="" /></p><p>（5）选择新建的摄像机、按 W 键进入“选择并平移对象”模式并移动摄像机，再按 E 键进入“选择并旋转对象”模式并略微旋转摄像机。从而让两个摄像头看到不同的视角。</p><p><img src="202506041539045426.png" alt="" /></p><p>（6）因为默认只能开启一个摄像机，所以为了防止出现问题，在“细节”面板中取消勾选“Camera1”的“自动启用”选项。</p><p><img src="2025060415411465395.png" alt="" /></p><h3 id="2编写蓝图逻辑"><a class="markdownIt-Anchor" href="#2编写蓝图逻辑"></a> 2，编写蓝图逻辑</h3><p>（1）打开“BP_CameraComponent”蓝图的事件图表，添加如下逻辑，实现按下 F 键时可以交替激活两个摄像机。</p><p><img src="2025060415585629753.png" alt="" /></p><p>（2）打开关卡蓝图，添加如下逻辑。其作用是在游戏开始时，将玩家的视角切换到指定的摄像机组件（BP_CameraComponent）上。</p><p>提示：Blend Time = 0.0 表示立即切换，没有过渡动画。</p><p><img src="2025060416055112646.png" alt="" /></p><h3 id="3运行测试"><a class="markdownIt-Anchor" href="#3运行测试"></a> 3，运行测试</h3><p>（1）运行后默认显示第 1 个摄像机的视角</p><p><img src="2025060416084225656.png" alt="" /></p><p>（2）按 F 键后切换为第 2 个摄像机的视角，再次按 F 键后回到第 1 个摄像机的视角。</p><p><img src="2025060416090791417.png" alt="" /></p>]]></content>
    
    
    <summary type="html">UE5摄像机组件使用详解</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>VR项目优化设置</title>
    <link href="http://www.formeasy.cc/2025/10/31/UE/VR%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E8%AE%BE%E7%BD%AE/"/>
    <id>http://www.formeasy.cc/2025/10/31/UE/VR%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E8%AE%BE%E7%BD%AE/</id>
    <published>2025-10-31T01:04:11.000Z</published>
    <updated>2025-10-31T01:09:35.589Z</updated>
    
    <content type="html"><![CDATA[<p>在创建针对特定VR平台的新项目时，请在 <strong>游戏（Games）</strong> 类别下选择 <strong>虚拟现实应用（VR Template）</strong>。VR模板提供了在虚幻引擎5中开发VR项目所需要的初始内容。</p><p>如果不想使用VR模板，可以用以下设置，新建一个空白C++或蓝图项目。</p><ul><li>质量预设：可缩放</li><li>光线追踪：禁用</li><li>初学者内容：禁用</li></ul><p><img src="projectsettings.png" alt="" /></p><p>这些设置会创建一个虚幻引擎项目，并启用最少的渲染功能。这样可以确保项目一开始就有良好的帧率，你只要添加需要的渲染功能即可。</p><p>在创建项目后，设置以下项目设置，以改善应用的性能：</p><ul><li>进入 <strong>编辑 &gt; 项目设置 &gt; 描述</strong>，并启用 <strong>以VR启动</strong>。</li><li>在 <strong>编辑 &gt; 项目设置 &gt; 渲染 &gt;前向渲染器</strong> 中，启用前向着色。</li><li>在 <strong>编辑 &gt; 项目设置 &gt; 渲染 &gt; 默认设置</strong> 中，将 <strong>抗锯齿方法</strong> 设置为多重采样抗锯齿。</li><li>在 <strong>编辑 &gt; 项目设置 &gt; 渲染（Rendering）&gt; VR</strong> 中，启用实例化立体。<br />*　对于移动设备VR体验，在 <strong>编辑 &gt; 项目设置 &gt; 渲染 &gt; VR（Edit &gt; Project Settings &gt; Rendering &gt; VR）</strong> 中启用移动多视图。<ul><li>将移动HDR（Mobile HDR）设置为False</li></ul></li></ul><h2 id="vr-ini设置"><a class="markdownIt-Anchor" href="#vr-ini设置"></a> VR .ini设置</h2><p>以下表格描述了部分主机变量，以及VR项目的推荐值。</p><table><thead><tr><th><strong>控制台变量</strong></th><th><strong>推荐值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>vr.PixelDensity</strong></td><td>1</td><td><strong>1</strong> 是HMD目前使用的理想分辨率。较低的值会导致运行速度更快，但也会造成欠采样（更为模糊）。超过 <strong>1</strong> 时运行速度较慢，同时会超采样（更为清晰）。</td></tr><tr><td><strong>r.SeparateTranslucency</strong></td><td>0</td><td>由于填充帧限制，对移动VR体验来说开销较大。建议禁用该功能。</td></tr><tr><td><strong>r.HZBOcclusion</strong></td><td>0</td><td>层级Z缓冲遮挡部分。</td></tr></tbody></table><p>以下.ini设置摘自虚幻引擎4支持的VR演示<a href="https://www.unrealengine.com/marketplace/en-US/product/showdown-demo">《Showdown》</a>。你可以使用这些设置作为起点，将它们复制到项目的 <strong>Config/DefaultEngine.ini</strong> 文件中的 <strong>SystemSettings</strong> 下。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[SystemSettings]</span><br><span class="line"></span><br><span class="line">vr.PixelDensity=1</span><br><span class="line">r.SeparateTranslucency=0</span><br><span class="line">r.HZBOcclusion=0</span><br><span class="line">r.MotionBlurQuality=0</span><br><span class="line">r.PostProcessAAQuality=3</span><br><span class="line">r.BloomQuality=1</span><br><span class="line">r.EyeAdaptationQuality=0</span><br><span class="line">r.AmbientOcclusionLevels=0</span><br><span class="line">r.SSR.Quality=1</span><br><span class="line">r.DepthOfFieldQuality=0</span><br><span class="line">r.SceneColorFormat=2</span><br><span class="line">r.TranslucencyVolumeBlur=0</span><br><span class="line">r.TranslucencyLightingVolumeDim=4</span><br><span class="line">r.MaxAnisotropy=8</span><br><span class="line">r.LensFlareQuality=0</span><br><span class="line">r.SceneColorFringeQuality=0</span><br><span class="line">r.FastBlurThreshold=0</span><br><span class="line">r.SSR.MaxRoughness=0.1</span><br><span class="line">r.rhicmdbypass=0</span><br><span class="line">sg.EffectsQuality=2</span><br><span class="line">sg.PostProcessQuality=0</span><br></pre></td></tr></table></figure><h2 id="vr帧率优化"><a class="markdownIt-Anchor" href="#vr帧率优化"></a> VR帧率优化</h2><p>大部分VR应用都会执行自己的流程来控制VR帧率。因此，需要在虚幻引擎4中禁用多个会影响VR应用的一般项目设置。</p><p>请跟随以下步骤，禁用虚幻引擎的一般帧率设置：</p><ol><li><p>在编辑器主菜单中，选择 编辑 &gt; 项目设置，打开项目设置窗口。</p></li><li><p>在项目设置窗口中，在引擎部分中选择一般设置。</p></li><li><p>在帧率部分下：</p></li></ol><ul><li><p>禁用平滑帧率。</p></li><li><p>禁用使用固定帧率。</p></li><li><p>将自定义时间步设置为None。</p></li></ul><p><img src="framerate.png" alt="" /></p><h2 id="vr世界场景缩放"><a class="markdownIt-Anchor" href="#vr世界场景缩放"></a> VR世界场景缩放</h2><p>为了在VR平台上保障最佳的用户体验，确保世界场景缩放的正确是最重要的方式之一。错误的缩放可能导致用户遭遇各类感官问题，甚至可能引发晕眩。在VR中，物体距离玩家摄像机0.75米至3.5米时观看效果最佳。在虚幻引擎4中，1个虚幻单位（UU）等于1厘米（CM）。这意味着在虚幻引擎中放置物体时，它们在距离玩家摄像机（使用VR时）75至350虚幻单位时观看效果最佳。</p><table><thead><tr><th><strong>距离</strong></th><th><strong>虚幻单位距离</strong></th></tr></thead><tbody><tr><td>1 厘米</td><td>1 虚幻单位</td></tr><tr><td>1 米</td><td>100 虚幻单位</td></tr><tr><td>1 千米</td><td>100,000 虚幻单位</td></tr></tbody></table><p>可以在 <strong>世界场景设置</strong> 中找到 <strong>世界到米</strong> 变量，用它调整世界的缩放。这个数字的升降会使用户感觉自己在世界场景中相应地变大或缩小。假设你使用1虚幻单位=1厘米来构建内容，将 <strong>世界到米</strong> 设置为 <strong>10</strong> 会使世界看起来非常广阔，将其设置为 <strong>1000</strong> 则会使世界变得非常狭小。</p><p><img src="worldscale.png" alt="" /></p><h2 id="vr与模拟晕眩症"><a class="markdownIt-Anchor" href="#vr与模拟晕眩症"></a> VR与模拟晕眩症</h2><p>晕眩是一种在沉浸式体验中影响用户的晕动症。下表介绍的最佳实践能够限制用户在VR中体验到的不适感。</p><ul><li><strong>保持帧率：</strong> 低帧率可能导致晕眩。尽可能地优化项目，就能改善用户的体验。下表罗列了XR平台的推荐帧率。</li></ul><table><thead><tr><th><strong>HMD设备</strong></th><th><strong>目标帧率</strong></th></tr></thead><tbody><tr><td>Oculus Rift S</td><td>90</td></tr><tr><td>Oculus Quest 1</td><td>72</td></tr><tr><td>Oculus Quest 2</td><td>视情况：72/80/90/120</td></tr><tr><td>HTC Vive</td><td>90</td></tr><tr><td>HTC Vive Pro</td><td>90</td></tr><tr><td>Valve Index</td><td>最低90，最高144</td></tr><tr><td>HP Reverb</td><td>90</td></tr><tr><td>Windows Mixed Reality VR</td><td>90</td></tr><tr><td>PSVR</td><td>视情况：60/120、90/90和120/120</td></tr></tbody></table><p>*</p><ul><li><p><strong>用户测试：</strong> 让不同的用户进行测试，监控他们在VR应用中体验到的不适感，以避免出现晕眩。</p></li><li><p><strong>让用户控制摄像机：</strong> 电影摄像机和其他使玩家无法控制摄像机移动的设计是沉浸式体验不适感的罪魁祸首。应当尽量避免使用头部摇动和摄像机抖动等摄像机效果，如果用户无法控制它们，就可能产生不适感。</p></li><li><p><strong>视野（FOV）必须和设备匹配：</strong> FOV值是通过设备的SDK和内部配置设置的，并且与头显和镜头的物理几何体匹配。因此，FOV无法在虚幻引擎中更改，用户也不得修改。如果FOV值经过了更改，那么在你转动头部时，世界场景就会产生扭曲，并引起不适感。</p></li><li><p><strong>使用较暗的光照和颜色，并避免产生拖尾</strong> 在设计VR元素时，你使用的光照与颜色应当比平常更为暗淡。在VR中，强烈鲜明的光照会导致用户更快出现晕眩。使用偏冷的色调和昏暗的光照，就能避免用户产生不适感，还能避免屏幕中的亮色和暗色区域之间产生拖尾。</p></li><li><p><strong>移动速度不应该变化：</strong> 用户一开始就应当是全速移动，而不是逐渐加快至全速。</p></li><li><p><strong>避免使用会大幅影响用户所见内容的后期处理效果：</strong> 避免使用景深和动态模糊等后期处理效果，以免用户产生不适感。</p></li><li><p>应避免动态模糊和景深等视觉效果。</p></li><li><p>考虑角色高度、宽度、速度和摄像机位置等因素，需要针对VR角色对它们进行轻微修改。</p></li></ul><h2 id="vr摄像机设置"><a class="markdownIt-Anchor" href="#vr摄像机设置"></a> VR摄像机设置</h2><p>虚幻引擎4中的VR摄像机设置完全取决于VR体验是否为坐式或站式：</p><ul><li><strong>坐式体验：</strong> 你需要人工抬高角色站立时的摄像机原点，将 <strong>视线水平</strong> 设置为Pawn碰撞胶囊体 <strong>圆柱体高度</strong> 负值的一半。</li></ul><p><img src="vr_seated_experience.png" alt="" /></p><ul><li><strong>站式体验：</strong> 确保摄像机原点设置为 <strong>0</strong>，相对于通常摆放在地面上的Pawn根部。在Pawn底部的场景组件上附加一个摄像机组件，使其位于地面水平。</li></ul><p><img src="vr_standing_experience.png" alt="" /> <img src="trackingorigin.png" alt="" /></p><h2 id="vr内容注意事项"><a class="markdownIt-Anchor" href="#vr内容注意事项"></a> VR内容注意事项</h2><p>在创建VR内容时，你需要注意的是，用户可以从多个角度观看内容。请注意下列事项：</p><ul><li><p><strong>比例（Scale）：</strong> VR场景中的物体比例应尽可能地模拟真实情况。物体过大或过小可能会导致用户产生困惑，或者产生晕眩。</p></li><li><p><strong>多边形面缺失：</strong> 在非沉浸式体验中，物体上玩家无法看到的多边形面通常会被移除。然而，在VR体验中，玩家可以更自由地环顾四周，如果缺失多边形，可能会导致用户看到不该看到的对象。</p></li><li><p><strong>光照类型：</strong> 在VR项目中始终要使用静态光源和光照贴图，这是渲染开销最低的方案。如果你需要使用动态光照，一定要尽量少用动态光源，并且确保它们不会相互接触。</p></li><li><p><strong>VR和VFX：</strong> 部分VFX效果，例如使用SubUV纹理来模拟火焰或烟雾，在VR中的观看效果不佳。你依然需要使用静态网格体来模拟爆炸和烟迹等效果，不能使用2D粒子。近场效果和距离摄像机很近的效果在VR中表现良好，但必须使用静态网格体粒子组成。</p></li><li><p><strong>VR和透明度：</strong> 在3D图形中，渲染透明度的开销极其昂贵，因为一般来说，透明效果每帧都需要重新计算一下，以检查是否有所变化。由于要重新评估，在VR中渲染透明度的开销变得过于昂贵，得不偿失。不过为了避免这个问题，你可以使用 <strong>DitherTemporalAA</strong> 材质函数。该材质函数可以让材质看似使用了透明效果，还能避免自排序等常见的透明度问题。 <img src="vr_dither_trans_aa.png" alt="" /></p><ul><li><strong>尽可能以假乱真：</strong> 以取巧的方式模拟出动态阴影或动态光照等开销高昂的渲染效果，这样可以尽可能节省性能。在Showdown中，让角色逐帧投射动态阴影的开销过于昂贵，因此项目中取消了动态阴影。然而，这也让角色在移动时如同在漂浮一般。为了解决该问题，我们使用了仿制的模糊阴影，它们能根据角色与场景中物体的距离，动态地调节位置和强度。这样角色在靠近地面（或其他物体）时就仿佛投下了阴影。</li></ul></li><li><p><img src="vr_fake_shadow_material.png" alt="" /></p></li></ul><h2 id="已知局限"><a class="markdownIt-Anchor" href="#已知局限"></a> 已知局限</h2><p>下表列出了可能因HMD设计而无法在VR中获得预期效果的功能，以及可能的解决方案。</p><ul><li><p><strong>屏幕空间反射（SSR）：</strong> 虽然SSR能够在VR中生效，但其产生的反射可能与真实世界中的反射不匹配。除了SSR之外，你还可以使用反射探头，它们的开销较低，也较不容易出现反射匹配的问题。</p></li><li><p><strong>屏幕空间全局光照：</strong> 屏幕空间技术可以在HMD中的两只眼睛之间产生显示差异。这些差异可能会导致用户不适。</p></li><li><p><strong>光线追踪：</strong> 目前使用光线追踪的VR应用程序无法保持所需的分辨率和帧速率来获得舒适的VR体验。</p></li><li><p><strong>用户界面：</strong> 2D UI在立体渲染中不受支持，因为它在立体视图中效果不佳。应改用放置在3D世界中的控件组件来代替2D UI。</p></li></ul><h3 id="法线贴图问题"><a class="markdownIt-Anchor" href="#法线贴图问题"></a> 法线贴图问题</h3><p>在VR中查看对象上的法线贴图时，应该会注意到它们未能达到以前该有的效果。这是因为法线贴图不会考虑双目显示问题或运动视差。因此，使用VR设备查看时，法线贴图通常看起来很扁平。但是，这并不意味着不应该或不需要使用法线贴图；只是意味着需要更加仔细评估是否可以更好地从几何体产生法线贴图中的数据。下面将介绍一种可以用来代替法线贴图的技术。</p><ul><li><strong>视差贴图：</strong> 视差贴图会考虑法线贴图中所没有的深度线索，从而将法线贴图提升到一个新的水平。视差贴图着色器可以更好地显示深度信息，使对象看起来比实际具有更多细节。这是因为无论从哪个角度看，视差贴图都会自行校正，从观察者的视点显示正确的深度信息。视差贴图的最佳用途是用于鹅卵石小径和具有精细细节的表面等。</li></ul>]]></content>
    
    
    <summary type="html">VR项目优化设置</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>window下的qt5.14.2配置vs2022</title>
    <link href="http://www.formeasy.cc/2025/10/31/Qt/window%E4%B8%8B%E7%9A%84qt5.14.2%E9%85%8D%E7%BD%AEvs2022/"/>
    <id>http://www.formeasy.cc/2025/10/31/Qt/window%E4%B8%8B%E7%9A%84qt5.14.2%E9%85%8D%E7%BD%AEvs2022/</id>
    <published>2025-10-31T00:36:45.000Z</published>
    <updated>2025-10-31T00:46:11.167Z</updated>
    
    <content type="html"><![CDATA[<p>已知qt5.14.2和vs202不兼容，无法自动扫描到vs的编译器。但由于团队协作原因，必须使用qt5.14.2，并且第三方库又依赖vs2022。其实qt5.15.2是支持vs2022的，如果能够用qt5.15.2，还是建议使用qt5.15.2及以上。如果换不了，那看下面吧。</p><p>首先可以下载qt5.14.2版本和vs2022，安装包如下：</p><blockquote><p>通过网盘分享的文件：qt-opensource-windows-x86-5.14.2.exe<br />链接: <a href="https://pan.baidu.com/s/1XK0vaVbik5XOPpQ63H0%5C_dg">https://pan.baidu.com/s/1XK0vaVbik5XOPpQ63H0\_dg</a> 提取码: nhxy<br />通过网盘分享的文件：VisualStudioSetup.exe<br />链接: <a href="https://pan.baidu.com/s/1NlhvO8QjMukXGh8qS2W68Q">https://pan.baidu.com/s/1NlhvO8QjMukXGh8qS2W68Q</a> 提取码: dt4y</p></blockquote><p>其中vs安装的工具集和Windows SDK安装选择如下（为了方便后面可能会用到不同版本，我基本都安装了）<br /><img src="52e6ee44f84d495c902e93b36d77bb9c.png" alt="" /><br /><img src="41210ee474e048b6bc767ffad6500ae1.png" alt="" /><br />上面安装完之后就需要在qt creator中配置了，由于5.14.2不支持vs2022,那么编译器和版本都需要手动配置了。</p><p><img src="22d827e781344e4e9a120dc361dffda9.png" alt="" /></p><ul><li>配置kit环境中，还需要选择对应的qt版本，这里也手动添加版本。</li></ul><blockquote><p>通过网盘分享的文件：Qt.zip<br />链接: <a href="https://pan.baidu.com/s/1TcZd2T0cmszSbj7Ko3dpzg">https://pan.baidu.com/s/1TcZd2T0cmszSbj7Ko3dpzg</a> 提取码: gjcv</p></blockquote><p><img src="77d917a886e04e06b949d36a3617c6d7.png" alt="" /></p><ul><li><p>添加完编译器和版本后，来配置kits，如图配置。<br /><img src="66b68adb64e144868d18fc2d0d9bf06d.png" alt="" /></p></li><li><p>到这里，kit就配置好了，选择该kit重新构件运行即可。</p></li><li><p>如果接下来遇到找不到库的类似问题，可尝试在项目中添加环境变量，这一步的变量我是从别人能正常启动的项目拿来的，若有些和读者电脑不一样，跳过即可，具体每一个有什么作用，还没细究，读者自行配置。建议先全部配置看项目是否能运行，若能运行再一个个删除查找原因。</p></li></ul><p>添加LIB变量:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\lib;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\lib\x64;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\atlmfc\lib\x64;C:\Program Files (x86)\Windows Kits\10\Lib\10.0.22621.0\um\x64;C:\Program Files (x86)\Windows Kits\10\Lib\10.0.22621.0\ucrt\x64</span><br></pre></td></tr></table></figure><p>添加INCLUDE变量:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\atlmfc\include;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\VS\include;C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um;C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\winrt;C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt;C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\shared;C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\cppwinrt</span><br></pre></td></tr></table></figure><p>另外，若出现unable to create a debugging engine错误，可以查看下面链接。</p><blockquote><p><a href="https://b3logfile.com/pdf/article/1592296047699.pdf">https://b3logfile.com/pdf/article/1592296047699.pdf</a></p></blockquote><ul><li>最后贴一个自己的项目配置</li></ul><p><img src="b6836c3b4c7348f5a8fa6b39bba69191.png" alt="" /></p><p><img src="326a1fc4e87949a78980733bc433cc61.png" alt="" /></p>]]></content>
    
    
    <summary type="html">window下的qt5.14.2配置vs2022</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Qt" scheme="http://www.formeasy.cc/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【UE5 C++】C++代码调用蓝图方法或事件</title>
    <link href="http://www.formeasy.cc/2025/10/30/UE/%E3%80%90UE5%20C++%E3%80%91C++%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E8%93%9D%E5%9B%BE%E6%96%B9%E6%B3%95%E6%88%96%E4%BA%8B%E4%BB%B6/"/>
    <id>http://www.formeasy.cc/2025/10/30/UE/%E3%80%90UE5%20C++%E3%80%91C++%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E8%93%9D%E5%9B%BE%E6%96%B9%E6%B3%95%E6%88%96%E4%BA%8B%E4%BB%B6/</id>
    <published>2025-10-30T02:04:30.000Z</published>
    <updated>2025-10-30T02:08:51.630Z</updated>
    
    <content type="html"><![CDATA[<p>此方法为：先创建C++类MyTest，再以MyTest类为父类创建蓝图；在其他类中，可以通过MyTest调用蓝图对应方法。</p><h3 id="1创建c代码"><a class="markdownIt-Anchor" href="#1创建c代码"></a> 1.创建c++代码</h3><p>通过UE创建继承自Actor的C++代码<br /><img src="842ec38aa1ab8e1241a3f3efa326a638.png" alt="" /><br /><img src="e1e55aac2ae7facd8cf7e6be598afe08.png" alt="" /></p><h3 id="2添加可以在ue中重写方法的说明"><a class="markdownIt-Anchor" href="#2添加可以在ue中重写方法的说明"></a> 2.添加可以在UE中重写方法的说明</h3><p>需使用声明：UFUNCTION(BlueprintNativeEvent, BlueprintCallable)</p><p>BlueprintNativeEvent表示在 c++ 中定义事件，可以在UE中实现，c++ 中必须实现。<br />如果UE中实现了，则覆盖c++中逻辑。</p><p>BlueprintCallable 表示可以在蓝图中调用。</p><p>完整代码 .h文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//添加可以在UE中重写方法</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintNativeEvent, BlueprintCallable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Play</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Play_Implementation</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure><p>.cpp文件增加方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyTest::Play_Implementation</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中.h文件的 virtual void Play_Implementation();可以不写，写是为了方便实用快捷键创建.cpp中的实现。</p><p>.cpp文件中必须实现Play_Implementation。<br />后缀为官方定义的不可更改。不然.h中的Play()会报错。</p><p><strong>注：可以填参数int32，<sub>但我测试FString类型无法添加</sub> 。 传递FString类型 要使用：const FString&amp; str</strong></p><p><strong>注：增加了此代码后，需要重写通过编辑器编译进入UE，不然可能不会出现步骤2中的可选事件</strong></p><h3 id="2创建蓝图类"><a class="markdownIt-Anchor" href="#2创建蓝图类"></a> 2.创建蓝图类</h3><p>以MyTest为末班，创建蓝图类。<br /><img src="23756da69ec24a09064e03a32e4c397e.png" alt="" /><br />打开蓝图类，鼠标移动到左侧FUNCTIONS菜单上，可以出现下拉菜单，可以发现刚才出现了刚才定义的Play。<br /><img src="61a50015e339b8dfff83af7e3f09f0d7.png" alt="" /><br />点击Play，可以发现生成了一个事件。<br />可以对其进行连线，以便进一步在C++中调用。<br /><img src="c8a1f2f6699008c28efd718fa868f67c.png" alt="" /></p><h3 id="3调用测试"><a class="markdownIt-Anchor" href="#3调用测试"></a> 3.调用测试</h3><p>到此，只要获取到该蓝图的Actor，Cast获取MyTest，即可调用声明的Play方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AMyTest* myTestActor = <span class="built_in">Cast</span>&lt;AMyTest&gt;(Actor);</span><br><span class="line"><span class="keyword">if</span>(myTestActor)</span><br><span class="line">&#123;</span><br><span class="line">myTestActor-&gt;<span class="built_in">Play</span>(<span class="number">99</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：Actor为创建出来的蓝图对象，自行获取</strong></p>]]></content>
    
    
    <summary type="html">【UE5 C++】C++代码调用蓝图方法或事件</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>UE5判断当前是否为VR环境</title>
    <link href="http://www.formeasy.cc/2025/10/30/UE/UE5%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E6%98%AF%E5%90%A6%E4%B8%BAVR%E7%8E%AF%E5%A2%83/"/>
    <id>http://www.formeasy.cc/2025/10/30/UE/UE5%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E6%98%AF%E5%90%A6%E4%B8%BAVR%E7%8E%AF%E5%A2%83/</id>
    <published>2025-10-30T01:04:11.000Z</published>
    <updated>2025-11-02T08:37:58.227Z</updated>
    
    <content type="html"><![CDATA[<p>在Unreal Engine 5 (UE5) 中，如果想判断当前场景是否处于虚拟现实（VR）模式，可以使用几种不同的方法来实现这一功能。<br />以下是一些常见的方法：</p><ul><li><ol><li>使用 GEngine 和 GIsEditor</li></ol></li><li><ol start="2"><li>使用 FVRPluginFunctionLibrary</li></ol></li><li><ol start="3"><li>使用 IModularFeatures 和 FVRPlugin</li></ol></li><li><ol start="4"><li>使用蓝图（Blueprint）</li></ol></li></ul><h2 id="第一种方法使用-gengine-和-giseditor"><a class="markdownIt-Anchor" href="#第一种方法使用-gengine-和-giseditor"></a> 第一种方法:使用 GEngine 和 GIsEditor</h2><p>可以通过检查 GEngine 的 IsStereoscopicPass 函数或者使用 GIsEditor 来判断是否处于 VR 模式。这种方法通常在运行时使用。</p><h3 id="1创建一个基于蓝图函数库的c类myblueprintfunctionlibrary"><a class="markdownIt-Anchor" href="#1创建一个基于蓝图函数库的c类myblueprintfunctionlibrary"></a> 1.创建一个基于蓝图函数库的C++类(MyBlueprintFunctionLibrary)</h3><p>过程参照 UE5 蓝图调用C++函数方式 文章</p><h3 id="2在-xxxbuildcs-文件中添加模块依赖"><a class="markdownIt-Anchor" href="#2在-xxxbuildcs-文件中添加模块依赖"></a> 2.在 XXX.Build.cs 文件中添加模块依赖</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PublicDependencyModuleNames.<span class="built_in">AddRange</span>(<span class="keyword">new</span> string[]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Core&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CoreUObject&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Engine&quot;</span>,</span><br><span class="line">    <span class="string">&quot;InputCore&quot;</span>,</span><br><span class="line">    <span class="string">&quot;HeadMountedDisplay&quot;</span>  <span class="comment">// 大小写敏感！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3在myblueprintfunctionlibrary类中添加如下代码"><a class="markdownIt-Anchor" href="#3在myblueprintfunctionlibrary类中添加如下代码"></a> 3.在MyBlueprintFunctionLibrary类中添加如下代码</h3><p>在MyBlueprintFunctionLibrary.h添加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">IsInVRMode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>在MyBlueprintFunctionLibrary.cpp添加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HeadMountedDisplayTypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IXRTrackingSystem.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IHeadMountedDisplay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/Engine.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UMyBlueprintFunctionLibrary::IsInVRMode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> GEngine &amp;&amp; GEngine-&gt;XRSystem.<span class="built_in">IsValid</span>() &amp;&amp; GEngine-&gt;XRSystem-&gt;<span class="built_in">IsHeadTrackingAllowed</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4在游戏初始时的蓝图中引用函数"><a class="markdownIt-Anchor" href="#4在游戏初始时的蓝图中引用函数"></a> 4.在游戏初始时的蓝图中引用函数</h3><p>返回true为是在VR模型运行</p><h2 id="第二种方法使用-fvrpluginfunctionlibrary"><a class="markdownIt-Anchor" href="#第二种方法使用-fvrpluginfunctionlibrary"></a> 第二种方法:使用 FVRPluginFunctionLibrary</h2><p>UE5 提供了 FVRPluginFunctionLibrary 类，可以使用它来查询 VR 状态。首先确保项目启用了 VR 支持，并且在项目设置中正确配置了 VR 插件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HeadMountedDisplayFunctionLibrary.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsInVRMode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否处于 VR 模式</span></span><br><span class="line">    <span class="keyword">return</span> UHeadMountedDisplayFunctionLibrary::<span class="built_in">IsHeadMountedDisplayEnabled</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三种方法使用-imodularfeatures-和-fvrplugin"><a class="markdownIt-Anchor" href="#第三种方法使用-imodularfeatures-和-fvrplugin"></a> 第三种方法:使用 IModularFeatures 和 FVRPlugin</h2><p>UE5 中，通过查询模组功能来获取 VR 插件的状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Modules/ModuleManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IXRTrackingSystem.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IXRSystem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsInVRMode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取 XRSystem 模块</span></span><br><span class="line">    <span class="keyword">if</span> (IXRSystem* XRSystem = FModuleManager::<span class="built_in">Get</span>().<span class="built_in">LoadModuleChecked</span>&lt;IXRSystem&gt;(<span class="string">&quot;XRSystem&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> XRSystem-&gt;<span class="built_in">IsHeadTrackingAllowed</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四种方法使用蓝图blueprint"><a class="markdownIt-Anchor" href="#第四种方法使用蓝图blueprint"></a> 第四种方法:使用蓝图（Blueprint）</h2><p>在蓝图编辑器中使用“Is Head Mounted Display Enabled”节点。</p><ul><li>1.在事件图中添加一个“条件”节点。</li><li>2.从“Head Mounted Display”类别中拖拽“Is Head Mounted Display Enabled”节点到条件节点。</li><li>3.根据这个节点的输出连接其他逻辑。</li></ul><p>以上方法建议第一种。</p>]]></content>
    
    
    <summary type="html">UE5判断当前是否为VR环境</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>UE5 蓝图调用C++函数方式</title>
    <link href="http://www.formeasy.cc/2025/10/30/UE/UE5%20%E8%93%9D%E5%9B%BE%E8%B0%83%E7%94%A8C++%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.formeasy.cc/2025/10/30/UE/UE5%20%E8%93%9D%E5%9B%BE%E8%B0%83%E7%94%A8C++%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F/</id>
    <published>2025-10-30T01:04:11.000Z</published>
    <updated>2025-10-31T08:55:27.495Z</updated>
    
    <content type="html"><![CDATA[<p>本文要记录两种方式蓝图调用C++函数：</p><h2 id="一-蓝图调用actor类的函数"><a class="markdownIt-Anchor" href="#一-蓝图调用actor类的函数"></a> 一、蓝图调用Actor类的函数</h2><h3 id="11-创建一个基于actor类"><a class="markdownIt-Anchor" href="#11-创建一个基于actor类"></a> 1.1 创建一个基于Actor类：</h3><p><img src="wechat_2025-10-30_085751_471.png" alt="" /></p><p><img src="wechat_2025-10-30_085844_432.png" alt="" /></p><h3 id="12-创建后内容浏览器中添加c类并自动打开vs"><a class="markdownIt-Anchor" href="#12-创建后内容浏览器中添加c类并自动打开vs"></a> 1.2 创建后，内容浏览器中添加C++类，并自动打开VS</h3><p>在新建的类下添加如下代码：</p><p>代码的方法为获取本机IP</p><p>.h</p><p><img src="wechat_2025-10-30_090020_363.png" alt="" /></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyActor.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C_MP_LOBBY_API</span> AMyActor : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Sets default values for this actor&#x27;s properties</span></span><br><span class="line"><span class="built_in">AMyActor</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function">FString <span class="title">ShowIP</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>.cpp</p><p><img src="wechat_2025-10-30_090342_384.png" alt="" /></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyActor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/AllowWindowsPlatformTypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/PreWindowsApi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/GameEngine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/PostWindowsApi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/HideWindowsPlatformTypes.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AMyActor::<span class="built_in">AMyActor</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyActor::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyActor::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FString <span class="title">AMyActor::ShowIP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WSADATA Wsadata;</span><br><span class="line"><span class="type">char</span> name[<span class="number">255</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">0</span>), &amp;Wsadata))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gethostname</span>(name, <span class="built_in">sizeof</span>(name)))</span><br><span class="line">&#123;</span><br><span class="line">hostent* host = <span class="built_in">gethostbyname</span>(name);</span><br><span class="line"><span class="keyword">if</span> (host != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">FString a = <span class="built_in">inet_ntoa</span>(*(<span class="keyword">struct</span> in_addr*)*host-&gt;h_addr_list);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">TEXT</span>(<span class="string">&quot;%s&quot;</span>), a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">TEXT</span>(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-编写代码后进行编译"><a class="markdownIt-Anchor" href="#14-编写代码后进行编译"></a> 1.4 编写代码后，进行编译</h3><h3 id="15-调用actor类的两种方法"><a class="markdownIt-Anchor" href="#15-调用actor类的两种方法"></a> 1.5 调用Actor类的两种方法</h3><h4 id="1-关卡蓝图中调用"><a class="markdownIt-Anchor" href="#1-关卡蓝图中调用"></a> 1) 关卡蓝图中调用</h4><p>将创建的c++类拖拽到场景中，世界大纲便会出现此Actor</p><p><img src="wechat_2025-10-30_092639_415.png" alt="" /></p><p>打开关卡蓝图，获到Actor类，并调用Show IP函数，如下：</p><p><img src="wechat_2025-10-30_093009_086.png" alt="" /></p><h4 id="2-创建蓝图类并调用"><a class="markdownIt-Anchor" href="#2-创建蓝图类并调用"></a> 2) 创建蓝图类并调用</h4><p>创建一个蓝图类（在内容浏览器右键），选取父类为当前的c++Actor类</p><p><img src="wechat_2025-10-30_093351_427.png" alt="" /></p><p>起名比如BP_Actor,双击打开，编写如下：</p><p><img src="wechat_2025-10-30_093730_788.png" alt="" /></p><p>效果同上</p><h2 id="二-蓝图调用蓝图函数库"><a class="markdownIt-Anchor" href="#二-蓝图调用蓝图函数库"></a> 二、蓝图调用蓝图函数库</h2><p><strong>注意：此方法创建出的子类中的方法必须为静态！</strong></p><h3 id="21-创建一个基于蓝图函数库"><a class="markdownIt-Anchor" href="#21-创建一个基于蓝图函数库"></a> 2.1 创建一个基于蓝图函数库：</h3><p><img src="wechat_2025-10-30_094508_149.png" alt="" /></p><p><img src="wechat_2025-10-30_094701_710.png" alt="" /></p><h3 id="22-创建后内容浏览器中创建了蓝图函数库c类并自动打开vs"><a class="markdownIt-Anchor" href="#22-创建后内容浏览器中创建了蓝图函数库c类并自动打开vs"></a> 2.2 创建后，内容浏览器中创建了蓝图函数库C++类，并自动打开VS</h3><p>编写代码</p><p><strong>注意：函数声明前需加static</strong></p><p>.h代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kismet/BlueprintFunctionLibrary.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyBlueprintFunctionLibrary.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C_MP_LOBBY_API</span> UMyBlueprintFunctionLibrary : <span class="keyword">public</span> UBlueprintFunctionLibrary</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function"><span class="type">static</span> FString <span class="title">ShowIP</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>.cpp代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyBlueprintFunctionLibrary.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/AllowWindowsPlatformTypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/PreWindowsApi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/GameEngine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/PostWindowsApi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/HideWindowsPlatformTypes.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FString <span class="title">UMyBlueprintFunctionLibrary::ShowIP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WSADATA Wsadata;</span><br><span class="line"><span class="type">char</span> name[<span class="number">255</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">0</span>), &amp;Wsadata))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gethostname</span>(name, <span class="built_in">sizeof</span>(name)))</span><br><span class="line">&#123;</span><br><span class="line">hostent* host = <span class="built_in">gethostbyname</span>(name);</span><br><span class="line"><span class="keyword">if</span> (host != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">FString a = <span class="built_in">inet_ntoa</span>(*(<span class="keyword">struct</span> in_addr*)*host-&gt;h_addr_list);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">TEXT</span>(<span class="string">&quot;%s&quot;</span>), a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">TEXT</span>(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写后进行编译</p><h3 id="23-使用蓝图函数库c类"><a class="markdownIt-Anchor" href="#23-使用蓝图函数库c类"></a> 2.3 使用蓝图函数库C++类</h3><p>这种方法使用函数比较简单，因为蓝图函数库是全局的，只要在蓝图中直接引用函数即可</p><p><img src="wechat_2025-10-30_100209_911.png" alt="" /></p><p>提示：如果出现“未能找到类型或命名空间名 unrealbuildtool 是否缺少using指令或程序集引用”错误</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确用法（.Build.cs）</span></span><br><span class="line"><span class="keyword">using</span> UnrealBuildTool; <span class="comment">// 仅在此处使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProject</span> : ModuleRules</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProject</span><span class="params">(ReadOnlyTargetRules Target)</span> : base(Target)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        PublicDependencyModuleNames.<span class="built_in">AddRange</span>(<span class="keyword">new</span> string[] &#123; </span><br><span class="line">            <span class="string">&quot;Core&quot;</span>, </span><br><span class="line">            <span class="string">&quot;CoreUObject&quot;</span>, </span><br><span class="line">            <span class="string">&quot;Engine&quot;</span>, </span><br><span class="line">            <span class="string">&quot;BlueprintGraph&quot;</span> <span class="comment">// 若使用蓝图函数库，需添加此模块依赖</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再删除Intermediate和Binaries目录后，重新编译</p>]]></content>
    
    
    <summary type="html">UE5 蓝图调用C++函数方式</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>UE给场景添加VR组件进行虚拟漫游</title>
    <link href="http://www.formeasy.cc/2025/10/27/UE/UE%E7%BB%99%E5%9C%BA%E6%99%AF%E6%B7%BB%E5%8A%A0VR%E7%BB%84%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%99%9A%E6%8B%9F%E6%BC%AB%E6%B8%B8/"/>
    <id>http://www.formeasy.cc/2025/10/27/UE/UE%E7%BB%99%E5%9C%BA%E6%99%AF%E6%B7%BB%E5%8A%A0VR%E7%BB%84%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%99%9A%E6%8B%9F%E6%BC%AB%E6%B8%B8/</id>
    <published>2025-10-27T07:34:47.000Z</published>
    <updated>2025-10-29T07:02:05.188Z</updated>
    
    <content type="html"><![CDATA[<p>将ue5工程，添加VR组件进行虚拟漫游，步骤如下；</p><h3 id="1添加vr虚拟现实库"><a class="markdownIt-Anchor" href="#1添加vr虚拟现实库"></a> 1.添加VR虚拟现实库</h3><p><img src="wechat_2025-10-27_152843_721.png" alt="" /></p><p><img src="wechat_2025-10-27_152940_712.png" alt="" /></p><p>添加后，内容浏览器中会多出VRSpectator和VRTemplate两个目录</p><p>另外，确认插件是否启用了openxr插件。</p><h3 id="2添加vr摄像头vrpawn"><a class="markdownIt-Anchor" href="#2添加vr摄像头vrpawn"></a> 2.添加VR摄像头（VRPawn）</h3><p><img src="wechat_2025-10-27_153112_253.png" alt="" /></p><p>将VRTemplate目录的Blueprints目录下中VRPawn拖到场景中，并调整位置。</p><h3 id="3项目设置中以vr启动"><a class="markdownIt-Anchor" href="#3项目设置中以vr启动"></a> 3.项目设置中以VR启动</h3><p><img src="wechat_2025-10-27_153207_454.png" alt="" /></p><h3 id="4安装并打开steamvr软件进行设置"><a class="markdownIt-Anchor" href="#4安装并打开steamvr软件进行设置"></a> 4.安装并打开SteamVR软件进行设置</h3><ul><li>启动SteamVR桌面客户端</li><li>打开 设置 -&gt; 开发者</li><li>查看“当前 OpenXR Runtime“状态</li><li>若不是 SteamVR，点击【设置为OpenXR Runtime】</li></ul><p>最后，UE5启动时，以VR预览的方式启动即可。</p><p>参考资料：<a href="https://www.bilibili.com/video/BV1yM4y177dv/?vd_source=16559409b3ad61518421a045daa8639d">https://www.bilibili.com/video/BV1yM4y177dv/?vd_source=16559409b3ad61518421a045daa8639d</a></p>]]></content>
    
    
    <summary type="html">UE给场景添加VR组件进行虚拟漫游</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>UE场景光照变桔黄Nanite缺失项目设置问题</title>
    <link href="http://www.formeasy.cc/2025/10/27/UE/UE%E5%9C%BA%E6%99%AF%E5%85%89%E7%85%A7%E5%8F%98%E6%A1%94%E9%BB%84Nanite%E7%BC%BA%E5%A4%B1%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://www.formeasy.cc/2025/10/27/UE/UE%E5%9C%BA%E6%99%AF%E5%85%89%E7%85%A7%E5%8F%98%E6%A1%94%E9%BB%84Nanite%E7%BC%BA%E5%A4%B1%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/</id>
    <published>2025-10-27T06:22:08.000Z</published>
    <updated>2025-10-27T06:28:16.188Z</updated>
    
    <content type="html"><![CDATA[<p>今天新建虚幻引擎项目时 , 编辑器右下角收到这个提示 ,<br /><img src="95a2b49c35b24dcfafde349d94c2b860.png" alt="" /></p><blockquote><p>缺失项目设置！ 使用Nanite资产需要Shader Model 6（SM6）。请在此启用： 项目设置-&gt; 平台-&gt;<br />Windows-&gt;D3D12目标着色器格式如未启用，Nanite资产将无法正常显示。</p></blockquote><p>并且打开场景时，场景光照变桔黄：<br /><img src="wechat_2025-10-27_142115_580.png" alt="" /></p><p>如何解决呢? 很简单</p><p>编辑 - 项目设置 - 平台 - Windows<br />D3D12 Targeted Shader Formats <code>开启 SM6</code><br />目标RHI 设置成 <code>DirectX 12</code><br /><img src="e6ffae4d7323433f8ad7a61ace8c635d.png" alt="" /></p><p>那么用UE5做游戏到底要不要开Nanite?<br />还是那句话 , 能开尽量开 , 官方也推荐开</p><p>应该将Nanite用于哪些类型的网格体？<br /><code>一般来说，能启用时应该尽量启用Nanite</code>。启用了Nanite的静态网格体通常可以更快地渲染，占用的内存和磁盘空间会更少。</p><p>具体来说，如果网格体满足以下条件，则尤其适合使用Nanite：</p><p>包含很多三角形，或屏幕上三角形非常小<br />场景中有很多实例<br />是其他Nanite几何体的主要遮挡物<br />使用虚拟阴影贴图投射阴影<br />不过有一个例外，那就是天空球之类的对象：它的三角形在屏幕上显得很大，不会遮挡任何东西，并且场景中只有一个。通常，这种例外很少见，并且让它们启用Nanite导致的性能损失很小，所以只要Nanite支持，就不必过度担心是否应该不开启Nanite。</p><p>官方文档原话:<br /><img src="122b3461b2e246c6a48f5c7c5d613961.png" alt="" /></p><p>Nanite支持的平台<br />Nanite目前支持PlayStation 5、Xbox Series S|X、以及符合以下显卡要求的PC（需要使用最新显卡驱动并<code>支持DirectX 12</code>）：<br />● NVIDIA：Maxwell显卡或更新版本的显卡<br />● AMD：GCN显卡或更新版本的显卡<br />● 凡是支持DirectX 12 Agility SDK的较新版Windows 10（高于版本1909.1350）和Windows 11都受支持。<br />○ Windows 10版本<code>1909</code> — 修订版号应该超过或等于.1350。<br />○ Windows 10版本2004和20H2 — 修订版号应该超过或等于.789。<br />○ DirectX 12（带着色器模型6.6原子），或Vulkan（VK_KHR_shader_atomic_int64）<br />● <code>最新显卡驱动程序</code></p><p>数据大小<br />Nanite能够实现<code>大量微观细节</code>，这可能会让人认为几何体数据会大量增加，导致玩家的游戏包大小和下载数据增加。然而，现实并没有那么可怕。事实上，Nanite的网格体格式要比标准的静态网格体格式小得多，因为Nanite有专门的网格体编码格式。</p><p>例如，对虚幻引擎5示例《古代山谷》来说，平均而言，Nanite网格体的每个输入三角形会消耗14.4字节。这意味着平均一个拥有100万三角形的Nanite网格体，在磁盘上需要约13.8兆字节（MB）。</p>]]></content>
    
    
    <summary type="html">UE场景光照变桔黄Nanite缺失项目设置问题</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>UE5 局域网联机，寻找会话失败</title>
    <link href="http://www.formeasy.cc/2025/10/27/UE/UE5%20%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%EF%BC%8C%E5%AF%BB%E6%89%BE%E4%BC%9A%E8%AF%9D%E5%A4%B1%E8%B4%A5/"/>
    <id>http://www.formeasy.cc/2025/10/27/UE/UE5%20%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%EF%BC%8C%E5%AF%BB%E6%89%BE%E4%BC%9A%E8%AF%9D%E5%A4%B1%E8%B4%A5/</id>
    <published>2025-10-27T05:34:25.000Z</published>
    <updated>2025-10-27T05:50:50.777Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1关闭防火墙"><a class="markdownIt-Anchor" href="#1关闭防火墙"></a> 1.关闭防火墙</h3><h3 id="2在项目名buildcs脚本中添加该行添加后关闭编辑器重新生成解决方案"><a class="markdownIt-Anchor" href="#2在项目名buildcs脚本中添加该行添加后关闭编辑器重新生成解决方案"></a> 2.在【项目名.Build.cs】脚本中添加该行，添加后关闭编辑器，重新生成解决方案。</h3><p><img src="9cf42465ce02c20396dcaa295ba0e67f.png" alt="" /></p><h3 id="3检查是否在同一个c类子网"><a class="markdownIt-Anchor" href="#3检查是否在同一个c类子网"></a> 3.检查是否在同一个C类子网</h3><p>一般是存在多块网卡（安装虚拟机）或是启用了Hyper-V，先禁用网卡或关闭Hyper-V。</p><ul><li>安装VMware会自动添加VMware Network Adapter VMnet1和VMware Network Adapter VMnet8网卡。</li><li>安装VirtualBox会自动添加VirtualBox Host-Only Ethernet Adapter网卡。</li><li>安装Hyper-V会自动添加Hyper-V Virtual Ethernet Adapter网卡。</li></ul><p>详细参考 <a href="https://forums.unrealengine.com/t/cant-find-session-in-lan/375836/12">https://forums.unrealengine.com/t/cant-find-session-in-lan/375836/12</a></p><hr /><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料：</h3><p>1.<a href="https://forums.unrealengine.com/t/cant-find-session-in-lan/375836/12" title="Can't find session in LAN - Programming &amp; Scripting / Multiplayer &amp; Networking - Epic Developer Community Forums (unrealengine.com)">Can’t find session in LAN - Programming &amp; Scripting / Multiplayer &amp; Networking - Epic Developer Community Forums (unrealengine.com)</a><br /><img src="ea00e43c0f9ba10a684359889e548414.png" alt="" /></p><p>2.<a href="https://unreal.gg-labs.com/wiki-archives/networking/how-to-use-sessions-in-c++" title="How To Use Sessions In C++ | 4.24 | UE4: Guidebook (gg-labs.com)">How To Use Sessions In C++ | 4.24 | UE4: Guidebook (gg-labs.com)</a><br /><img src="64f1144736af2c94b25ea0e28cba648d.png" alt="" /></p><p>3.<a href="https://www.reddit.com/r/unrealengine/comments/11a2s4s/lyra_session_browser_cannot_find_sessions_lan_wifi/" title="Lyra - 会话浏览器找不到会话 （LAN WIFI） ： r/unrealengine (reddit.com)">Lyra - 会话浏览器找不到会话 （LAN WIFI） ： r/unrealengine (reddit.com)</a><br /><img src="e8fcd78fd791909404d93d88d1cc1f6d.png" alt="" /></p><h3 id="尝试解决办法"><a class="markdownIt-Anchor" href="#尝试解决办法"></a> 尝试解决办法</h3><p>全部都做一遍，其中可能有若干个步骤多余。</p>]]></content>
    
    
    <summary type="html">UE5 局域网联机，寻找会话失败</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>UE Gameplay 框架总结</title>
    <link href="http://www.formeasy.cc/2025/10/27/UE/UE%20Gameplay%20%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://www.formeasy.cc/2025/10/27/UE/UE%20Gameplay%20%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</id>
    <published>2025-10-27T00:37:47.000Z</published>
    <updated>2025-10-27T00:48:19.039Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了游戏开发中几个重要的概念：GameInstance用于保存临时全局数据，GameMode管理游戏规则和类信息，DefaultPawn提供基础操作，PlayerController连接客户端与服务器，以及GameState和PlayerState负责全局数据管理和玩家状态同步。</p><h2 id="各个模块"><a class="markdownIt-Anchor" href="#各个模块"></a> 各个模块</h2><h3 id="gameinstance游戏实例"><a class="markdownIt-Anchor" href="#gameinstance游戏实例"></a> <strong>GameInstance（<strong>游戏实例</strong>）</strong></h3><blockquote><ul><li>实例里的数据不会随着关卡的切换而消失。</li><li>作用是为游戏保存临时的全局数据（并不是所有的全局变量都存在<strong>GameInstance</strong>中，如玩家的信息应该存在<strong>PlayerState</strong>，游戏的一些信息存在<strong>GameState</strong>），或者自定义需要在全局使用的逻辑（慎重，<strong>GameInstance</strong> 的臃肿会导致卡顿）。</li><li>通常情况下一个Game中应该只有一个<strong>GameInstance</strong>(UE也是提供了多个GameInstance协同的扩展的，但是一次Game只能有一个GameInstance生效)</li><li>GameInstance的生命周期就是从游戏进程启动到游戏进程结束</li></ul></blockquote><h4 id="gameinstance主要处理"><a class="markdownIt-Anchor" href="#gameinstance主要处理"></a> <strong>GameInstance主要处理：</strong></h4><blockquote><ul><li>UWorld、ULevel之间的切换</li><li>全局配置</li><li>GameMode的切换</li></ul></blockquote><h3 id="gamemode-游戏规则"><a class="markdownIt-Anchor" href="#gamemode-游戏规则"></a> <strong>GameMode</strong> （游戏规则）</h3><blockquote><ul><li>仅在当前Level生效，一个Level一次只能对应一个GameMode，但是一个GameMode可以用在多个Level中</li><li>仅存在服务器中，客户端没有</li></ul></blockquote><h4 id="gamemode主要处理"><a class="markdownIt-Anchor" href="#gamemode主要处理"></a> <strong>GameMode</strong>主要处理：</h4><blockquote><ul><li>Class登记：记录GameMode中各种类的信息</li><li>Spawn：创建Pawn和PlayerController等</li><li>游戏进度：游戏暂停重启的逻辑</li><li>过场动画逻辑</li><li>多人游戏的步调同步</li></ul></blockquote><h2 id="defaultpawn-默认pawn"><a class="markdownIt-Anchor" href="#defaultpawn-默认pawn"></a> <strong>DefaultPawn</strong> （默认Pawn）</h2><blockquote><ul><li>自带DefualtPawnMovement、CollisionComponent、StaticMeshCompnent三件套（Pawn没有这些，Pawn提供了接口没有具体实现）</li><li>服务端和客户端都存在一份，同时保持同步。</li><li>在 GameMode 中修改。</li></ul></blockquote><h4 id="defaultpawn主要处理"><a class="markdownIt-Anchor" href="#defaultpawn主要处理"></a> <strong>DefaultPawn主要处理：</strong></h4><blockquote><ul><li>提供基础的操作，保证Game运行</li></ul></blockquote><h3 id="hud"><a class="markdownIt-Anchor" href="#hud"></a> <strong>HUD</strong></h3><blockquote><ul><li>实现一些简单的界面元素（文本，点），复杂的要使用UMG，但是HUD开销更小</li><li>只存在于客户端</li></ul></blockquote><h3 id="playercontroller"><a class="markdownIt-Anchor" href="#playercontroller"></a> <strong>PlayerController</strong></h3><blockquote><ul><li>拥有 Pawn 并设置其行为规则</li><li>服务器上拥有所有玩家的PlayerController，而本地客户端则只有当前玩家的 PlayerController 。</li><li>关联了客户端和服务端，通过该类，客户端可以向服务端发送请求</li></ul></blockquote><h4 id="playercontroller-主要处理"><a class="markdownIt-Anchor" href="#playercontroller-主要处理"></a> <strong>PlayerController</strong> 主要处理：</h4><blockquote><ul><li>Camera管理</li><li>Input输入响应</li><li>UPlayer关联</li><li>HUD显示</li><li>Level切换</li><li>Voice音源监听</li></ul></blockquote><h3 id="gamestate"><a class="markdownIt-Anchor" href="#gamestate"></a> <strong>GameState</strong></h3><blockquote><ul><li>数据的全局管理（用于存储游戏相关数据）</li><li>服务端和客户端都存在一份，它包含要复制到游戏中的每个客户端的信息</li><li>通常用来保持数据的同步，也可将其中的部分数据设置为不同步。</li></ul></blockquote><h4 id="gamestate主要处理"><a class="markdownIt-Anchor" href="#gamestate主要处理"></a> <strong>GameState主要处理：</strong></h4><blockquote><ul><li>保存游戏数据，如任务进度，游戏活动等。</li></ul></blockquote><h3 id="playerstate"><a class="markdownIt-Anchor" href="#playerstate"></a> <strong>PlayerState</strong></h3><blockquote><ul><li>数据的全局管理（用于存储角色相关数据）</li><li>该类需要通过 PlayerController 来访问</li><li>所有玩家的 PlayerState存在于所有机器上（与 PlayerController 不同），并且可以将数据从服务器复制到客户端以保持同步</li><li>PlayerState的生命周期为一整个Level的生命周期</li></ul></blockquote><h4 id="playerstate-主要处理"><a class="markdownIt-Anchor" href="#playerstate-主要处理"></a> <strong>PlayerState</strong> 主要处理：</h4><blockquote><ul><li>保存玩家数据，客户端可以存在多个PlayerState对象，不同的PlayerState保存不同玩家的状态</li></ul></blockquote>]]></content>
    
    
    <summary type="html">UE Gameplay 框架总结</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL5.6-5.7-8.0版本授权用户远程连接</title>
    <link href="http://www.formeasy.cc/2025/10/24/MySQL/MySQL5.6-5.7-8.0%E7%89%88%E6%9C%AC%E6%8E%88%E6%9D%83%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    <id>http://www.formeasy.cc/2025/10/24/MySQL/MySQL5.6-5.7-8.0%E7%89%88%E6%9C%AC%E6%8E%88%E6%9D%83%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</id>
    <published>2025-10-24T13:42:07.000Z</published>
    <updated>2025-10-24T13:51:35.032Z</updated>
    
    <content type="html"><![CDATA[<p><strong>修改配置文件</strong><br />找到 MySQL 的配置文件 my.cnf(或 my.ini),通常位于 /etc/mysql/ 或者 /etc/my.cnf，使用文本编辑器打开文件，找到 [mysqld] 部分，添加如下内容：</p><p>bind-address = 0.0.0.0<br />这将允许所有 IP 地址的连接，如果你想限制只允许特定 IP 地址连接，可以将 0.0.0.0 替换为特定的 IP 地址。</p><p><strong>MySQL5.6版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span> WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p><strong>MySQL5.7版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p><strong>MySQL8.0版本</strong></p><p>因默认认证插件和权限限制，需多一步 “调整认证方式” 或 “分步骤授权”。<br />MySQL 8 不允许 “创建用户” 和 “授权” 在一条 SQL 中完成，需分开执行：</p><p>1）创建用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;CREATE USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure><p>2）授权示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p>3）修改远程连接用户的加密规则<br />由于 MySQL 8 默认的 caching_sha2_password 插件，部分旧客户端（如 Navicat 11 及以下）不支持，需改为传统插件兼容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure><p>4）刷新权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;flush privileges;</span><br></pre></td></tr></table></figure><p><strong>开放服务器端口</strong><br />所有版本需开放 3306 端口。</p>]]></content>
    
    
    <summary type="html">MySQL5.6-5.7-8.0版本授权用户远程连接</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="MySQL" scheme="http://www.formeasy.cc/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Window环境下安装Redis</title>
    <link href="http://www.formeasy.cc/2025/10/10/Redis/Window%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Redis/"/>
    <id>http://www.formeasy.cc/2025/10/10/Redis/Window%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Redis/</id>
    <published>2025-10-10T06:27:15.000Z</published>
    <updated>2025-10-10T06:33:39.166Z</updated>
    
    <content type="html"><![CDATA[<p>由于 Redis 官方没有提供 Windows 原生版本，这里将介绍几种主流的安装方法。</p><hr /><h3 id="方法一使用微软移植的-redis最推荐-最稳定"><a class="markdownIt-Anchor" href="#方法一使用微软移植的-redis最推荐-最稳定"></a> 方法一：使用微软移植的 Redis（最推荐、最稳定）</h3><p>这是最适合 Windows 的安装方式，由微软团队维护，提供了稳定的安装包。</p><h4 id="下载-redis"><a class="markdownIt-Anchor" href="#下载-redis"></a> 下载 Redis</h4><ol><li><p>访问 Redis 在 GitHub 的发布页面：<br /><strong><a href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></strong></p></li><li><p>找到最新的稳定版。通常文件名格式为 <code>Redis-x64-3.0.504.msi</code>（版本号可能不同）。<strong>下载 <code>.msi</code> 安装文件。</strong></p></li></ol><h4 id="安装-redis"><a class="markdownIt-Anchor" href="#安装-redis"></a> 安装 Redis</h4><ol><li><strong>运行安装程序</strong>：双击下载的 <code>.msi</code> 文件。</li><li><strong>同意许可协议</strong>：勾选 “I accept the terms in the License Agreement”，然后点击 “Next”。</li><li><strong>选择安装路径</strong>：建议保持默认路径（<code>C:\Program Files\Redis\</code>），点击 “Next”。</li><li><strong>配置端口</strong>：默认端口是 <code>6379</code>，保持默认即可，点击 “Next”。</li><li><strong>设置内存限制</strong>：这个设置可以保持默认，点击 “Next”。</li><li><strong>重要配置</strong>：<strong>务必勾选 “Add the Redis installation folder to the PATH environment variable”</strong>（将 Redis 添加到系统环境变量）。这样你就可以在任意命令行窗口中使用 <code>redis-cli</code> 命令了。</li><li><strong>完成安装</strong>：点击 “Install” 开始安装。安装完成后，点击 “Finish”。</li></ol><h4 id="验证安装和服务状态"><a class="markdownIt-Anchor" href="#验证安装和服务状态"></a> 验证安装和服务状态</h4><ol><li><p><strong>打开命令提示符（CMD）或 PowerShell</strong>：按 <code>Win + R</code>，输入 <code>cmd</code> 或 <code>powershell</code>，然后回车。</p></li><li><p><strong>检查 Redis 服务</strong>：Redis 安装后会默认作为 Windows 服务运行。</p><ul><li><p><strong>方法A（图形界面）</strong>：</p><ul><li>按 <code>Win + R</code>，输入 <code>services.msc</code>，回车。</li><li>在服务列表中找到 <code>Redis</code>，其状态应为 “正在运行”。</li></ul></li><li><p><strong>方法B（命令行）</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sc</span> query Redis</span><br></pre></td></tr></table></figure><p>如果看到 <code>STATE</code> 显示为 <code>RUNNING</code>，则表示服务运行正常。</p></li></ul></li><li><p><strong>测试连接</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis<span class="literal">-cli</span></span><br></pre></td></tr></table></figure><p>你会看到命令提示符变成 <code>127.0.0.1:6379&gt;</code>。<br />输入 <code>ping</code>，如果服务器回复 <code>PONG</code>，说明安装成功！</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ping</span><br><span class="line">PONG</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> mykey <span class="string">&quot;Hello Redis&quot;</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get mykey</span><br><span class="line"><span class="string">&quot;Hello Redis&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="keyword">exit</span></span><br></pre></td></tr></table></figure></li></ol><hr /><h3 id="方法二使用-wsl2体验与-linux-一致的环境"><a class="markdownIt-Anchor" href="#方法二使用-wsl2体验与-linux-一致的环境"></a> 方法二：使用 WSL2（体验与 Linux 一致的环境）</h3><p>Windows Subsystem for Linux 2 是在 Windows 上运行原生 Linux 二进制文件的最佳方式。如果你需要进行开发，这是<strong>最推荐</strong>的方法，因为它的行为和 Linux 生产环境完全一致。</p><ol><li><p><strong>安装 WSL2</strong>：</p><ul><li><p>以管理员身份打开 PowerShell 或 Windows 命令提示符，然后运行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span></span><br></pre></td></tr></table></figure></li><li><p>此命令将启用所需的可选功能，默认安装 Ubuntu 发行版，并设置为使用 WSL2。安装后需要重启电脑。</p></li></ul></li><li><p><strong>启动 WSL</strong>：在开始菜单中搜索 “Ubuntu” 并启动。</p></li><li><p><strong>在 WSL 中安装 Redis</strong>：</p><ul><li><p>在 WSL 终端中，执行以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade <span class="literal">-y</span></span><br><span class="line">sudo apt install redis<span class="literal">-server</span> <span class="literal">-y</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>在 WSL 中启动 Redis</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service redis<span class="literal">-server</span> <span class="built_in">start</span></span><br></pre></td></tr></table></figure></li><li><p><strong>连接测试</strong>：</p><ul><li>在 WSL 终端中直接使用 <code>redis-cli</code>。</li><li>如果要从 Windows 主机连接 WSL2 中的 Redis，配置会稍复杂，需要修改 WSL 中 Redis 的绑定地址。对于初学者，建议先在 WSL 内部进行测试。</li></ul></li></ol><hr /><h3 id="方法三使用-chocolatey-包管理器适合喜欢命令行的用户"><a class="markdownIt-Anchor" href="#方法三使用-chocolatey-包管理器适合喜欢命令行的用户"></a> 方法三：使用 Chocolatey 包管理器（适合喜欢命令行的用户）</h3><p>如果你已经安装了 Chocolatey，安装 Redis 会非常简单。</p><ol><li><p><strong>安装 Chocolatey</strong>：如果未安装，请以<strong>管理员身份</strong>打开 PowerShell，执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Bypass <span class="literal">-Scope</span> <span class="keyword">Process</span> <span class="literal">-Force</span>; [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol = [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol <span class="operator">-bor</span> <span class="number">3072</span>; <span class="built_in">iex</span> ((<span class="built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="string">&#x27;https://community.chocolatey.org/install.ps1&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Chocolatey 安装 Redis</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install redis<span class="literal">-64</span></span><br></pre></td></tr></table></figure></li><li><p>安装完成后，Redis 也会作为服务运行。你可以用与方法一相同的方式进行验证。</p></li></ol><hr /><h3 id="windows-下-redis-的基本使用和管理"><a class="markdownIt-Anchor" href="#windows-下-redis-的基本使用和管理"></a> Windows 下 Redis 的基本使用和管理</h3><h4 id="启动停止-redis-服务"><a class="markdownIt-Anchor" href="#启动停止-redis-服务"></a> 启动/停止 Redis 服务</h4><ul><li><p><strong>图形界面（服务管理器）</strong>：<code>services.msc</code>，找到 <code>Redis</code> 服务，进行启动、停止、重启操作。</p></li><li><p><strong>命令行（管理员权限）</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">net stop Redis</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">net <span class="built_in">start</span> Redis</span><br><span class="line"><span class="comment"># 或者使用 sc 命令</span></span><br><span class="line"><span class="built_in">sc</span> stop Redis</span><br><span class="line"><span class="built_in">sc</span> <span class="built_in">start</span> Redis</span><br></pre></td></tr></table></figure></li></ul><h4 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h4><ul><li><p><strong>配置文件位置</strong>：默认安装在 <code>C:\Program Files\Redis\</code> 目录下，文件名是 <code>redis.windows-service.conf</code>（对于服务）或 <code>redis.windows.conf</code>（对于临时启动）。</p></li><li><p><strong>常见配置修改</strong>：</p><ul><li><p><strong>绑定 IP</strong>：默认只允许本地（<code>127.0.0.1</code>）连接。要允许远程连接，需要编辑配置文件，找到 <code>bind</code> 行，修改为 <code>bind 0.0.0.0</code>。<strong>（注意：这有安全风险，务必设置密码防火墙！）</strong></p></li><li><p><strong>设置密码</strong>：找到 <code># requirepass foobared</code> 行，取消注释并将 <code>foobared</code> 改为你的强密码。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass your_strong_password_here</span><br></pre></td></tr></table></figure></li><li><p><strong>数据文件目录</strong>：<code>dir ./</code> 指定了 RDB 和 AOF 文件的存储位置，通常是安装目录下。</p></li></ul></li><li><p><strong>修改配置后，必须重启 Redis 服务才能生效。</strong></p></li></ul><h4 id="连接有密码的-redis"><a class="markdownIt-Anchor" href="#连接有密码的-redis"></a> 连接有密码的 Redis</h4><p>如果设置了密码，连接方式如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式1：先连接，再认证</span></span><br><span class="line">redis<span class="literal">-cli</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; AUTH your_password</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2：连接时直接指定密码</span></span><br><span class="line">redis<span class="literal">-cli</span> <span class="literal">-a</span> your_password</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式3（更安全，避免密码出现在历史命令中）</span></span><br><span class="line">redis<span class="literal">-cli</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; AUTH your_password</span><br></pre></td></tr></table></figure><h4 id="数据持久化文件"><a class="markdownIt-Anchor" href="#数据持久化文件"></a> 数据持久化文件</h4><p>Redis 的数据会保存在安装目录下（例如 <code>C:\Program Files\Redis\</code>），文件名为：</p><ul><li><strong>RDB 快照</strong>：<code>dump.rdb</code></li><li><strong>AOF 日志</strong>：<code>appendonly.aof</code>（如果开启）</li></ul><hr /><h3 id="使用-gui-工具管理-redis推荐"><a class="markdownIt-Anchor" href="#使用-gui-工具管理-redis推荐"></a> 使用 GUI 工具管理 Redis（推荐）</h3><p>对于不习惯命令行的用户，可以使用图形化界面工具，非常方便。</p><ol><li><p><strong>RedisInsight</strong>（官方推荐，免费）：</p><ul><li><strong>下载地址</strong>：<a href="https://redis.io/redisinsight/">https://redis.io/redisinsight/</a></li><li>功能强大，支持可视化查看数据、执行命令、性能分析等。</li></ul></li><li><p><strong>Another Redis Desktop Manager</strong>（开源，流行）：</p><ul><li><strong>下载地址</strong>：<a href="https://github.com/qishibo/AnotherRedisDesktopManager/releases">https://github.com/qishibo/AnotherRedisDesktopManager/releases</a></li><li>界面美观，响应迅速，非常受开发者欢迎。</li></ul></li><li><p><strong>FastoRedis</strong>（功能全面）：</p><ul><li><strong>下载地址</strong>：<a href="https://fastoredis.com/">https://fastoredis.com/</a></li><li>支持多种数据库模式。</li></ul></li></ol><h3 id="总结与建议"><a class="markdownIt-Anchor" href="#总结与建议"></a> 总结与建议</h3><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>MSI 安装包</strong></td><td><strong>最简单、稳定，一键安装成服务</strong></td><td>版本可能稍旧</td><td><strong>Windows 桌面用户、快速入门</strong></td></tr><tr><td><strong>WSL2</strong></td><td><strong>与 Linux 环境 100% 一致，版本新</strong></td><td>需要开启 WSL，配置稍复杂</td><td><strong>开发者、需要与生产环境保持一致</strong></td></tr><tr><td><strong>Chocolatey</strong></td><td>命令行安装，方便自动化</td><td>需要先安装 Chocolatey</td><td>喜欢包管理器、自动化脚本的用户</td></tr></tbody></table><p><strong>对于绝大多数 Windows 用户，我强烈推荐使用【方法一：微软移植的 MSI 安装包】</strong>，它省去了所有复杂的配置，开箱即用，是体验 Redis 最快的方式。</p>]]></content>
    
    
    <summary type="html">Window环境下安装Redis</summary>
    
    
    
    <category term="数据库" scheme="http://www.formeasy.cc/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="http://www.formeasy.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java快速开发框架大比拼：Jeesite 、jeecgBoot、smartAdmin、若依全方位解析</title>
    <link href="http://www.formeasy.cc/2025/10/07/Other/Java%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E5%A4%A7%E6%AF%94%E6%8B%BC%EF%BC%9AJeesite%20%E3%80%81jeecgBoot%E3%80%81smartAdmin%E3%80%81%E8%8B%A5%E4%BE%9D%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.formeasy.cc/2025/10/07/Other/Java%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E5%A4%A7%E6%AF%94%E6%8B%BC%EF%BC%9AJeesite%20%E3%80%81jeecgBoot%E3%80%81smartAdmin%E3%80%81%E8%8B%A5%E4%BE%9D%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E6%9E%90/</id>
    <published>2025-10-07T14:16:42.000Z</published>
    <updated>2025-10-07T14:25:30.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-引言"><a class="markdownIt-Anchor" href="#一-引言"></a> <strong>一、引言</strong></h3><p>在 Java 开发领域，快速开发框架的出现极大地提高了开发效率，降低了开发成本。Jeesite、jeecgBoot、smartAdmin 和若依作为当下流行的快速开发框架，各自有着独特的特性。本文将对这四个框架进行详细的对比分析，涵盖它们的特点、优势与劣势、适用场景、使用技巧以及实际案例，帮助开发者根据项目需求做出最佳选择。</p><p><img src="911b7b057788d21493e66a10c6d05835.png" alt="" /></p><h3 id="二-jeesite-框架剖析"><a class="markdownIt-Anchor" href="#二-jeesite-框架剖析"></a> <strong><strong>二、Jeesite</strong> <strong>框架剖析</strong></strong></h3><h4 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> <strong>特点</strong></h4><p>Jeesite 是一个基于 Spring Boot、Spring MVC、MyBatis 等主流框架开发的开源 Java 快速开发平台。它提供了丰富的功能模块，如用户管理、角色管理、菜单管理等基础模块，同时支持多数据源、代码生成等实用功能。该框架采用了经典的 MVC 架构，使得代码结构清晰，易于维护。</p><h4 id="优势"><a class="markdownIt-Anchor" href="#优势"></a> <strong>优势</strong></h4><p><strong>1.成熟稳定</strong>：经过多年的发展和社区维护，Jeesite 在稳定性方面表现出色，能够满足企业级项目对系统稳定性的高要求。</p><p><strong>2.文档完善</strong>：拥有详细的官方文档，从入门教程到高级特性的使用说明一应俱全，对于新手开发者非常友好，能够快速上手开发。</p><p><strong>3.扩展性强</strong>：通过模块化的设计，开发者可以方便地根据项目需求添加或删除功能模块，对不同规模和复杂度的项目都有很好的适应性。</p><h4 id="劣势"><a class="markdownIt-Anchor" href="#劣势"></a> <strong>劣势</strong></h4><p><strong>1.学习曲线较陡</strong>：对于没有太多 Java 开发经验的初学者来说，框架的复杂性可能导致学习成本较高，需要花费一定时间来理解框架的整体架构和运行机制。</p><p><strong>2.界面设计相对传统</strong>：在前端界面设计方面，Jeesite 可能缺乏一些现代感和时尚感，对于对界面美观度要求较高的项目，可能需要进行较多的二次开发。</p><h4 id=""><a class="markdownIt-Anchor" href="#"></a> </h4><p><img src="37e28767b270116a7bfd1231745bafaa.jpeg" alt="" /></p><h4 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> <strong>适用场景</strong></h4><p><strong>1.企业级信息管理系统</strong>：如企业内部的办公自动化系统、资源管理系统等，这些系统对稳定性和扩展性要求较高，Jeesite 能够很好地满足需求。</p><p><strong>2.中大型项目开发</strong>：由于其强大的功能和良好的扩展性，适合用于开发规模较大、业务逻辑复杂的项目，帮助团队高效完成开发任务。</p><h4 id="使用技巧"><a class="markdownIt-Anchor" href="#使用技巧"></a> <strong>使用技巧</strong></h4><p><strong>1.利用代码生成器</strong>：Jeesite 的代码生成器可以根据数据库表结构自动生成 Java 代码和前端页面代码，大大提高开发效率。开发者可以根据项目需求对生成的代码进行定制化修改。</p><p><strong>2.合理配置多数据源</strong>：如果项目涉及多个数据库的操作，合理配置多数据源能够确保数据的高效读写。可以在配置文件中清晰地定义不同数据源的连接信息，并在代码中通过注解等方式指定使用的数据源。</p><h4 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> <strong>案例</strong></h4><p>某大型制造企业的生产管理系统采用 Jeesite 框架进行开发。该系统涵盖了生产计划管理、物料采购管理、库存管理等多个模块。通过 Jeesite 的多数据源功能，系统能够与企业现有的财务系统、销售系统等进行数据交互，实现了企业生产运营的全面信息化管理。在开发过程中，利用代码生成器快速生成了大量基础代码，缩短了开发周期，并且系统上线后运行稳定，满足了企业的业务需求。</p><p><img src="16e4215a401f0cb2973a9fe3d0e84e77.jpeg" alt="" /></p><h3 id="三-jeecgboot-框架解读"><a class="markdownIt-Anchor" href="#三-jeecgboot-框架解读"></a> <strong><strong>三、JeecgBoot</strong> <strong>框架解读</strong></strong></h3><h4 id="特点-2"><a class="markdownIt-Anchor" href="#特点-2"></a> <strong>特点</strong></h4><p>JeecgBoot 是一款基于代码生成器的快速开发平台，基于 Spring Boot、MyBatis-Plus 等技术构建。它的代码生成功能非常强大，支持单表、一对多、树表等多种模式的代码生成。同时，JeecgBoot 还集成了丰富的前端组件库，如 Element UI，使得前端开发更加便捷高效。</p><h4 id="优势-2"><a class="markdownIt-Anchor" href="#优势-2"></a> <strong>优势</strong></h4><p><strong>1.快速开发</strong>：强大的代码生成功能可以快速生成项目所需的后端代码和前端页面，极大地提高了开发速度，尤其适合对项目交付时间要求较高的场景。</p><p><strong>2.丰富的插件和扩展</strong>：框架提供了众多插件，如工作流插件、报表插件等，可以方便地集成到项目中，满足不同业务场景的需求，减少了开发人员的重复劳动。</p><p><strong>3.良好的前端体验</strong>：基于 Element UI 的前端设计，界面美观大方，交互性强，能够为用户提供良好的使用体验，对于注重用户体验的项目来说是一个不错的选择。</p><h4 id="劣势-2"><a class="markdownIt-Anchor" href="#劣势-2"></a> <strong>劣势</strong></h4><p><strong>1.定制化难度</strong>：虽然代码生成功能方便，但对于一些复杂的业务逻辑和特殊需求，可能需要对生成的代码进行大量修改，定制化过程相对复杂，需要开发者对框架有较深入的理解。</p><p><strong>2.依赖较多</strong>：框架集成了多个第三方库和插件，可能会导致项目的依赖关系较为复杂，在版本升级或维护过程中可能会出现一些兼容性问题。</p><h4 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> </h4><p><img src="b2df04c3962e581310136ef219a54e95.png" alt="" /></p><h4 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> </h4><h4 id="适用场景-2"><a class="markdownIt-Anchor" href="#适用场景-2"></a> <strong>适用场景</strong></h4><p><strong>1.快速原型开发</strong>：对于需要快速搭建项目原型，验证业务想法的场景，JeecgBoot 的快速开发特性能够快速生成可用的系统框架，为后续的开发工作奠定基础。</p><p><strong>2.中小项目开发</strong>：在业务逻辑不是特别复杂的中小项目中，JeecgBoot 可以充分发挥其快速开发的优势，帮助团队快速完成项目开发，降低开发成本。</p><h4 id="使用技巧-2"><a class="markdownIt-Anchor" href="#使用技巧-2"></a> <strong>使用技巧</strong></h4><p><strong>1.熟练掌握代码生成配置</strong>：仔细配置代码生成的参数，如表名、字段类型、关联关系等，以生成符合项目需求的高质量代码。可以通过自定义模板来进一步定制生成代码的风格和结构。</p><p><strong>2.合理使用插件</strong>：根据项目业务需求，有选择性地使用框架提供的插件。在使用插件前，充分了解插件的功能和使用方法，确保其与项目的兼容性和稳定性。</p><h4 id="案例-2"><a class="markdownIt-Anchor" href="#案例-2"></a> <strong>案例</strong></h4><p>一家互联网创业公司在开发一款在线教育平台时采用了 JeecgBoot 框架。由于项目时间紧迫，需要快速搭建平台的基本架构。通过 JeecgBoot 的代码生成功能，开发团队迅速生成了用户管理、课程管理、订单管理等模块的后端代码和前端页面。同时，利用工作流插件实现了课程审核流程的自动化。该平台在短时间内上线，并获得了用户的良好反馈，帮助创业公司快速占领了市场份额。</p><p><img src="0dd4394d238e0c8d84600739fc4be1aa.png" alt="" /></p><h3 id="四-smartadmin-框架分析"><a class="markdownIt-Anchor" href="#四-smartadmin-框架分析"></a> <strong><strong>四、SmartAdmin</strong> <strong>框架分析</strong></strong></h3><h4 id="特点-3"><a class="markdownIt-Anchor" href="#特点-3"></a> <strong>特点</strong></h4><p>SmartAdmin 是一个轻量级的 Java 快速开发框架，基于 Spring Boot 和 Vue.js 技术栈。它强调简洁高效的开发理念，提供了简洁的代码结构和丰富的工具类。在权限管理方面，SmartAdmin 有着独特的设计，能够灵活地实现不同用户角色的权限控制。</p><h4 id="优势-3"><a class="markdownIt-Anchor" href="#优势-3"></a> <strong>优势</strong></h4><p><strong>1.轻量级设计</strong>：框架体积小，启动速度快，资源消耗低，适合对性能要求较高的项目，尤其是在一些资源受限的环境中也能稳定运行。</p><p><strong>2.前后端分离架构</strong>：采用流行的前后端分离架构，前端基于 Vue.js 开发，使得前后端开发人员可以并行工作，提高开发效率。同时，前后端分离也有利于系统的维护和扩展。</p><p><strong>3.灵活的权限管理</strong>：提供了强大而灵活的权限管理功能，可以根据用户角色、部门等多种维度进行权限分配，满足不同项目复杂的权限需求。</p><h4 id="劣势-3"><a class="markdownIt-Anchor" href="#劣势-3"></a> <strong>劣势</strong></h4><p><strong>1.功能相对较少</strong>：与一些功能全面的大型框架相比，SmartAdmin 的功能模块相对较少，对于一些业务复杂、需要大量功能集成的项目，可能需要进行较多的二次开发来补充功能。</p><p><strong>2.社区活跃度有限</strong>：目前其社区活跃度相对不高，在遇到问题时，可能较难从社区获取及时有效的解决方案，一定程度上增加了开发和维护的难度。</p><h4 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> </h4><h4 id="适用场景-3"><a class="markdownIt-Anchor" href="#适用场景-3"></a> <strong>适用场景</strong></h4><p><strong>1.小型 Web 应用开发</strong>：如小型企业官网、个人博客、小型电商平台等，这些项目对功能复杂度要求不高，SmartAdmin 的轻量级和高效开发特性能够快速实现项目需求。</p><p><strong>2.对性能要求高的系统</strong>：在一些对系统性能和响应速度要求苛刻的场景下，如实时数据处理系统、高并发访问的应用等，SmartAdmin 的轻量级设计能够保证系统的高效运行。</p><h4 id="使用技巧-3"><a class="markdownIt-Anchor" href="#使用技巧-3"></a> <strong>使用技巧</strong></h4><p><strong>1.优化前端代码</strong>：由于采用 Vue.js 进行前端开发，开发者可以通过优化前端代码结构、使用 Vue 的性能优化技巧等方式，进一步提高前端页面的加载速度和用户体验。</p><p><strong>2.合理配置权限</strong>：根据项目的实际业务需求，细致地进行权限配置。可以利用 SmartAdmin 提供的权限管理工具，对不同用户角色的操作权限进行精准控制，确保系统的安全性。</p><h4 id="案例-3"><a class="markdownIt-Anchor" href="#案例-3"></a> <strong>案例</strong></h4><p>某小型电商创业公司开发一款移动端电商应用的后台管理系统时选择了 SmartAdmin 框架。由于公司资源有限，且对系统性能和开发速度有较高要求，SmartAdmin 的轻量级和前后端分离特性满足了这些需求。开发团队快速搭建了系统的后端服务，并利用 Vue.js 开发了简洁易用的前端管理界面。通过灵活的权限管理功能，实现了不同岗位员工（如管理员、客服、运营人员等）的权限控制。该系统上线后运行稳定，为电商业务的顺利开展提供了有力支持。</p><h3 id="五-若依框架探讨"><a class="markdownIt-Anchor" href="#五-若依框架探讨"></a> <strong><strong>五、若依框架探讨</strong></strong></h3><h4 id="特点-4"><a class="markdownIt-Anchor" href="#特点-4"></a> <strong>特点</strong></h4><p>若依是一个基于 Spring Boot 和 Vue.js 的开源快速开发平台，致力于为企业级开发提供一站式解决方案。它提供了丰富的功能模块，包括用户管理、部门管理、菜单管理、数据权限等。若依注重代码的简洁性和可维护性，采用了流行的技术架构，易于上手和扩展。</p><p><img src="37e4d408b30a578dbca203154887721f.png" alt="" /></p><h4 id="优势-4"><a class="markdownIt-Anchor" href="#优势-4"></a> <strong>优势</strong></h4><p><strong>1.功能全面</strong>：涵盖了企业级开发中常见的各种功能模块，开发者可以直接使用这些模块进行项目开发，减少了从头开发基础功能的时间和工作量。</p><p><strong>2.代码简洁易读</strong>：框架的代码风格简洁明了，遵循良好的编程规范，使得代码的可读性和可维护性都很高。对于团队开发来说，有利于新成员快速理解和融入项目。</p><p><strong>3.持续更新和社区支持</strong>：若依的开发者团队持续对框架进行更新和优化，修复漏洞和添加新功能。同时，活跃的社区为开发者提供了交流和学习的平台，遇到问题时能够及时获得帮助。</p><h4 id="劣势-4"><a class="markdownIt-Anchor" href="#劣势-4"></a> <strong>劣势</strong></h4><p><strong>1.系统复杂度</strong>：由于功能全面，框架本身的复杂度相对较高，对于一些简单项目来说，可能会引入过多不必要的依赖和复杂性，增加了项目的维护成本。</p><p><strong>2.部分功能定制困难</strong>：在某些情况下，对于一些特殊业务需求，对框架中已有的功能模块进行定制可能会比较困难，需要对框架的底层代码有深入了解才能进行修改。</p><h4 id="适用场景-4"><a class="markdownIt-Anchor" href="#适用场景-4"></a> <strong>适用场景</strong></h4><p><strong>1.大型企业级项目</strong>：适合开发大型企业的综合管理系统，如企业资源计划（ERP）系统、客户关系管理（CRM）系统等，能够充分发挥其功能全面和稳定性高的优势。</p><p><strong>2.通用型后台管理系统</strong>：若依的功能模块和架构设计非常适合开发通用型的后台管理系统，开发者可以根据具体项目需求对现有模块进行定制和扩展，快速搭建出满足业务需求的管理平台。</p><h4 id="使用技巧-4"><a class="markdownIt-Anchor" href="#使用技巧-4"></a> <strong>使用技巧</strong></h4><p><strong>1.合理利用已有模块</strong>：在项目开发过程中，充分分析若依提供的功能模块，尽可能复用已有的功能，减少重复开发。对于需要定制的部分，可以在已有模块的基础上进行适当修改。</p><p><strong>2.关注社区动态</strong>：积极参与若依的社区讨论，关注框架的更新动态和其他开发者分享的经验技巧。通过社区可以获取到更多关于框架优化和使用的信息，提高开发效率和项目质量。</p><h4 id="案例-4"><a class="markdownIt-Anchor" href="#案例-4"></a> <strong>案例</strong></h4><p>某大型金融企业在进行内部管理系统升级时采用了若依框架。该系统需要整合多个业务部门的功能，包括财务管理、风险管理、人力资源管理等。若依丰富的功能模块和强大的扩展性满足了企业的需求。开发团队在若依的基础上，通过定制化开发，快速搭建了一套符合企业业务流程的综合管理系统。系统上线后，稳定运行，提高了企业内部的管理效率和协同工作能力，得到了企业用户的高度认可。</p><p><img src="d3668f1da1d0a05f9721d96d6516fe13.png" alt="" /></p><h3 id="六-对比总结"><a class="markdownIt-Anchor" href="#六-对比总结"></a> <strong><strong>六、对比总结</strong></strong></h3><table><tbody><tr><td><p><strong>框架名称</strong></p></td><td><p><strong>特点</strong></p></td><td><p><strong>优势</strong></p></td><td><p><strong>劣势</strong></p></td><td><p><strong>适用场景</strong></p></td></tr><tr><td><p>Jeesite</p></td><td><p>基于主流<span data-tit="框架" data-pretit="框架">框架</span>，MVC&nbsp;架构，功能模块丰富</p></td><td><p>成熟稳定、文档完善、扩展性强</p></td><td><p>学习曲线较陡、界面设计传统</p></td><td><p>企业级信息<span data-tit="管理系统" data-pretit="管理系统">管理系统</span>、中大型项目</p></td></tr><tr><td><p>JeecgBoot</p></td><td><p>基于代码<span data-tit="生成器" data-pretit="生成器">生成器</span>，集成前端组件库</p></td><td><p>快速开发、插件丰富、前端体验好</p></td><td><p>定制化难度大、依赖较多</p></td><td><p>快速原型开发、中小项目</p></td></tr><tr><td><p>SmartAdmin</p></td><td><p>轻量级，前后端分离，权限管理灵活</p></td><td><p>轻量级设计、前后端分离、权限管理灵活</p></td><td><p>功能相对较少、社区活跃度有限</p></td><td><p>小型&nbsp;Web&nbsp;应用、对性能要求高的系统</p></td></tr><tr><td><p>若依</p></td><td><p>功能全面，代码简洁，社区活跃</p></td><td><p>功能全面、代码简洁易读、持续更新和社区支持</p></td><td><p>系统复杂度高、部分功能定制困难</p></td><td><p>大型企业级项目、通用型<span data-tit="后台管理系统" data-pretit="后台管理系统">后台管理系统</span></p></td></tr></tbody></table><h3 id="七-结论"><a class="markdownIt-Anchor" href="#七-结论"></a> <strong><strong>七、结论</strong></strong></h3><p>Jeesite、jeecgBoot、smartAdmin 和若依这四个 Java 快速开发框架都有各自的特点和优势，也存在一定的劣势。在选择框架时，开发者需要综合考虑项目的规模、业务复杂度、性能要求、开发时间等因素。对于大型企业级项目，若依和 Jeesite 可能是较好的选择；对于快速原型开发和中小项目，JeecgBoot 更具优势；而对于小型 Web 应用和对性能要求高的系统，SmartAdmin 则是不错的选项。希望通过本文的对比分析，能够帮助开发者在实际项目中做出更合适的框架选择，提高开发效率，打造出高质量的 Java 应用系统。</p><p><strong>若依地址：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/y_project/RuoYi</span><br></pre></td></tr></table></figure><p><strong>Jeesite地址：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/thinkgem/jeesite</span><br></pre></td></tr></table></figure><p><strong>JeecgBoot地址：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/jeecg/JeecgBoot</span><br></pre></td></tr></table></figure><p><strong>SmartAdmin地址：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/lab1024/smart-admin</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java快速开发框架大比拼：Jeesite 、jeecgBoot、smartAdmin、若依全方位解析</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Other" scheme="http://www.formeasy.cc/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>Redis 同步机制解析</title>
    <link href="http://www.formeasy.cc/2025/10/05/Redis/Redis%20%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.formeasy.cc/2025/10/05/Redis/Redis%20%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</id>
    <published>2025-10-05T14:21:03.000Z</published>
    <updated>2025-10-05T14:42:18.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-redis-同步机制的核心与价值"><a class="markdownIt-Anchor" href="#一-redis-同步机制的核心与价值"></a> 一、Redis 同步机制的核心与价值</h2><h3 id="11-核心需求数据备份与读写分离"><a class="markdownIt-Anchor" href="#11-核心需求数据备份与读写分离"></a> 1.1 核心需求：数据备份与读写分离</h3><h4 id="数据备份"><a class="markdownIt-Anchor" href="#数据备份"></a> 数据备份</h4><p>在实际生产环境中，单机Redis实例存在多种风险：</p><ul><li>服务器硬件故障导致数据永久丢失</li><li>操作系统崩溃导致内存数据未持久化</li><li>误操作删除关键数据</li></ul><p>通过同步机制建立主从架构，可以实现：</p><ol><li><strong>多副本存储</strong>：数据至少存在于2个节点（1主1从），典型配置为1主2从</li><li><strong>容灾恢复</strong>：当主节点故障时，可快速提升从节点为新主节点</li><li><strong>数据持久化保障</strong>：结合RDB和AOF持久化策略，即使主节点完全损坏，从节点也能提供完整的数据恢复点</li></ol><p><strong>示例场景</strong>：电商平台商品库存数据，通过同步机制确保即使主节点宕机，从节点也能继续提供服务，避免超卖。</p><h4 id="读写分离"><a class="markdownIt-Anchor" href="#读写分离"></a> 读写分离</h4><p>Redis的主从架构天然支持读写分离：</p><ul><li><strong>主节点(Master)</strong>：处理所有写入操作（SET, INCR等）和部分关键读请求</li><li><strong>从节点(Slave)</strong>：处理90%以上的读请求（GET, HGET等），支持配置多个从节点实现水平扩展</li></ul><p><strong>优势体现</strong>：</p><ul><li>提升系统整体吞吐量：读性能随从节点数量线性增长</li><li>降低主节点负载：将CPU密集型操作（如复杂Lua脚本）分流到从节点</li><li>实现地域就近访问：在不同机房部署从节点，减少网络延迟</li></ul><p><strong>典型应用</strong>：</p><ul><li>社交平台：主节点处理发帖/点赞等写操作，从节点处理信息流展示</li><li>内容管理系统：主节点处理内容更新，从节点处理内容查询</li></ul><h3 id="12-关键目标高效-可靠-低延迟"><a class="markdownIt-Anchor" href="#12-关键目标高效-可靠-低延迟"></a> 1.2 关键目标：高效、可靠、低延迟</h3><h4 id="高效性实现"><a class="markdownIt-Anchor" href="#高效性实现"></a> 高效性实现</h4><p>Redis采用智能复制策略平衡效率：</p><ol><li><p><strong>全量复制</strong>：</p><ul><li>初次连接时执行</li><li>通过RDB快照完成</li><li>优化措施：支持无盘复制（diskless replication）</li></ul></li><li><p><strong>增量复制</strong>：</p><ul><li>基于复制积压缓冲区（repl-backlog-buffer）</li><li>默认大小1MB，可根据网络质量调整</li><li>仅传输变更命令，大幅减少带宽占用</li></ul></li></ol><p><strong>配置建议</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size 16mb  # 提升缓冲区大小应对网络不稳定</span><br><span class="line">repl-diskless-sync yes  # 启用无盘复制加速全量同步</span><br></pre></td></tr></table></figure><h4 id="可靠性保障"><a class="markdownIt-Anchor" href="#可靠性保障"></a> 可靠性保障</h4><p>Redis通过多种机制确保同步可靠性：</p><ul><li><strong>断点续传</strong>：基于复制偏移量（replication offset）记录同步进度</li><li><strong>心跳检测</strong>：主从定期（默认10秒）PING-PONG通信</li><li><strong>自动重连</strong>：网络恢复后自动重新建立同步连接</li><li><strong>数据校验</strong>：使用CRC64校验和验证数据一致性</li></ul><h4 id="低延迟优化"><a class="markdownIt-Anchor" href="#低延迟优化"></a> 低延迟优化</h4><p>为实现毫秒级同步延迟，Redis采用：</p><ol><li><strong>TCP长连接</strong>：避免频繁建立连接的开销</li><li><strong>异步复制</strong>：主节点不等待从节点ACK继续处理请求</li><li><strong>延迟监控</strong>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO replication  # 查看master_repl_offset和slave_repl_offset差值</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>硬件优化</strong>：<ul><li>主从节点部署在同一可用区减少网络延迟</li><li>使用高性能网卡（如10Gbps）</li></ul></li></ol><p><strong>性能指标</strong>：</p><ul><li>同机房延迟：通常&lt;1ms</li><li>跨机房延迟：取决于网络质量，通常&lt;10ms</li><li>极端情况下可配置WAIT命令实现同步写（牺牲性能换取更强一致性）</li></ul><h2 id="二-基础同步主从复制master-slave-replication"><a class="markdownIt-Anchor" href="#二-基础同步主从复制master-slave-replication"></a> 二、基础同步：主从复制（Master-Slave Replication）</h2><p>主从复制是 Redis 同步机制的基石，所有高级同步（哨兵、集群）均基于此扩展。其核心逻辑是通过主节点(Master)和从节点(Slave)的协作，实现数据的分布式存储和读写分离。从节点主动连接主节点，复制主节点的数据集，并实时同步主节点的写操作。这种架构设计不仅提高了系统的可用性，还能有效分担主节点的读请求压力。</p><h3 id="21-主从复制的三个核心阶段"><a class="markdownIt-Anchor" href="#21-主从复制的三个核心阶段"></a> 2.1 主从复制的三个核心阶段</h3><p>主从复制全流程分为&quot;建立连接&quot;、“数据同步”、&quot;命令传播&quot;三个阶段，缺一不可。这三个阶段构成了一个完整的数据同步生命周期，确保主从节点之间的数据最终一致性。</p><h4 id="阶段-1建立连接握手阶段"><a class="markdownIt-Anchor" href="#阶段-1建立连接握手阶段"></a> 阶段 1：建立连接（握手阶段）</h4><p>从节点通过配置<code>slaveof &lt;master-ip&gt; &lt;master-port&gt;</code>（Redis 5.0 后推荐使用更符合现代语义的<code>replicaof</code>）触发连接流程，具体步骤如下：</p><ol><li><p><strong>初始化连接</strong>：</p><ul><li>从节点启动后，向主节点发送<code>SYNC</code>命令（Redis 2.8 前）或更先进的<code>PSYNC</code>命令（Redis 2.8 后，支持增量复制）</li><li>主节点收到命令后，首先验证从节点的<code>requirepass</code>（若配置）与自身<code>masterauth</code>是否一致</li><li>验证通过后，主节点返回<code>+OK</code>响应</li></ul></li><li><p><strong>建立通信通道</strong>：</p><ul><li>主节点创建一个专门的&quot;复制客户端&quot;（用于向从节点发送数据）</li><li>从节点创建&quot;复制监听器&quot;（用于接收主节点发送的数据）</li><li>双方完成TCP连接初始化，为后续数据传输做好准备</li></ul></li><li><p><strong>连接确认</strong>：</p><ul><li>从节点会定期发送<code>PING</code>命令检测连接状态</li><li>主节点响应<code>PONG</code>确认连接正常</li></ul></li></ol><h4 id="阶段-2数据同步全量-增量复制"><a class="markdownIt-Anchor" href="#阶段-2数据同步全量-增量复制"></a> 阶段 2：数据同步（全量 / 增量复制）</h4><p>这是同步的核心阶段，分为两种模式：全量复制（首次同步或从节点断线过久）和增量复制（从节点短期断线后恢复）。选择哪种模式取决于从节点的同步状态和断开时间。</p><h5 id="221-全量复制从-0-到-1-复制完整数据集"><a class="markdownIt-Anchor" href="#221-全量复制从-0-到-1-复制完整数据集"></a> 2.2.1 全量复制：从 0 到 1 复制完整数据集</h5><p>当遇到以下情况时会触发全量复制：</p><ul><li>从节点是全新节点，从未同步过数据</li><li>从节点的<code>replid</code>（主节点标识）与主节点不一致</li><li>从节点的复制偏移量<code>offset</code>不在主节点的复制积压缓冲区范围内</li></ul><p><strong>全量复制详细流程</strong>：</p><ol><li><p><strong>发起请求</strong>：</p><ul><li>从节点发送<code>PSYNC ? -1</code>命令（表示请求全量复制）</li></ul></li><li><p><strong>主节点准备RDB</strong>：</p><ul><li>主节点接收到请求后，执行<code>bgsave</code>命令在后台生成RDB快照文件</li><li>在生成RDB期间，主节点会缓存所有写操作（如<code>SET</code>、<code>HSET</code>）到&quot;复制积压缓冲区&quot;</li></ul></li><li><p><strong>传输RDB文件</strong>：</p><ul><li>RDB生成完成后，主节点通过专用连接将RDB文件分块传输给从节点</li><li>传输过程中使用TCP滑动窗口机制优化网络传输效率</li></ul></li><li><p><strong>从节点加载数据</strong>：</p><ul><li>从节点收到RDB文件后，首先安全地清空自身数据集</li><li>然后将RDB文件加载到内存中，重建数据库</li></ul></li><li><p><strong>同步缓冲命令</strong>：</p><ul><li>主节点发送完RDB后，将&quot;复制积压缓冲区&quot;中的写操作按顺序发送给从节点</li><li>从节点执行这些命令，确保与主节点数据完全一致</li></ul></li></ol><p><strong>性能考量</strong>：</p><ul><li>RDB生成过程会fork子进程，可能导致短暂延迟</li><li>网络传输大数据量可能成为瓶颈</li><li>从节点加载RDB时会出现服务暂停</li><li>建议在业务低峰期执行全量复制，并确保网络带宽充足</li></ul><h5 id="222-增量复制仅同步断线期间的增量数据"><a class="markdownIt-Anchor" href="#222-增量复制仅同步断线期间的增量数据"></a> 2.2.2 增量复制：仅同步断线期间的增量数据</h5><p>当从节点短期断线（如网络闪断）后重新连接，且主节点的&quot;复制积压缓冲区&quot;仍保留断线期间的写操作时，触发增量复制。这种模式显著提高了同步效率。</p><p><strong>增量复制详细流程</strong>：</p><ol><li><p><strong>重新连接</strong>：</p><ul><li>从节点重新连接主节点时，发送<code>PSYNC &lt;replid&gt; &lt;offset&gt;</code>命令</li><li><code>replid</code>是主节点标识，<code>offset</code>是从节点最后一次同步的位置</li></ul></li><li><p><strong>主节点验证</strong>：</p><ul><li>主节点验证<code>replid</code>是否与自身一致</li><li>检查<code>offset</code>是否在&quot;复制积压缓冲区&quot;的有效范围内（缓冲区保留[master_offset - backlog_size, master_offset]的操作）</li></ul></li><li><p><strong>执行增量同步</strong>：</p><ul><li>验证通过后，主节点仅将<code>offset</code>之后的写操作从缓冲区发送给从节点</li><li>从节点执行这些增量命令，快速追上主节点数据状态</li></ul></li></ol><p><strong>增量复制的关键条件</strong>：</p><ol><li>从节点需正确记录上一次同步的<code>replid</code>和<code>offset</code>（存储在<code>replica.conf</code>中）</li><li>主节点的&quot;复制积压缓冲区&quot;需足够大，能够容纳断线期间的写操作</li><li>断线时间未超过<code>repl-backlog-ttl</code>（默认3600秒），避免缓冲区被清空</li></ol><p><strong>优化建议</strong>：</p><ul><li>对于写操作频繁的场景，适当增大<code>repl-backlog-size</code></li><li>监控从节点的复制延迟，及时发现潜在问题</li><li>定期检查复制积压缓冲区的使用情况</li></ul><h4 id="阶段-3命令传播实时同步写操作"><a class="markdownIt-Anchor" href="#阶段-3命令传播实时同步写操作"></a> 阶段 3：命令传播（实时同步写操作）</h4><p>数据同步完成后，主从进入&quot;命令传播&quot;阶段，这是维持数据一致性的关键环节。主节点每执行一次写命令，都会将该命令发送给所有从节点，从节点执行相同命令，确保数据实时同步。</p><p><strong>命令传播的详细机制</strong>：</p><ol><li><p><strong>写命令传播流程</strong>：</p><ul><li>客户端向主节点发送写命令（如<code>SET key value</code>）</li><li>主节点执行命令并修改本地数据</li><li>主节点将命令封装为Redis协议格式，发送给所有从节点</li><li>从节点接收并执行相同命令</li></ul></li><li><p><strong>性能优化策略</strong>：</p><ul><li>主节点采用&quot;异步发送&quot;模式：写命令执行后立即返回客户端，随后异步将命令发送给从节点</li><li>从节点通过<code>repl-disable-tcp-nodelay</code>配置控制TCP特性：<ul><li>默认<code>no</code>（关闭TCP_NODELAY）：TCP会缓冲小数据包，减少网络请求数，但可能增加毫秒级延迟</li><li>设为<code>yes</code>（开启TCP_NODELAY）：写命令立即发送，延迟降低，但网络请求数增加</li></ul></li></ul></li><li><p><strong>复制偏移量监控</strong>：</p><ul><li>主从节点都会维护复制偏移量<code>offset</code></li><li>通过<code>INFO replication</code>可以查看主从节点的<code>master_repl_offset</code>和<code>slave_repl_offset</code></li><li>两者的差值反映了复制延迟</li></ul></li></ol><h3 id="22-主从复制的核心配置"><a class="markdownIt-Anchor" href="#22-主从复制的核心配置"></a> 2.2 主从复制的核心配置</h3><h4 id="主节点配置"><a class="markdownIt-Anchor" href="#主节点配置"></a> 主节点配置</h4><table><thead><tr><th>配置项</th><th>示例值</th><th>说明</th><th>推荐设置</th></tr></thead><tbody><tr><td><code>bind</code></td><td><code>0.0.0.0</code></td><td>允许从节点远程连接</td><td>生产环境建议绑定具体IP</td></tr><tr><td><code>protected-mode</code></td><td><code>no</code></td><td>关闭保护模式</td><td>必须关闭才能远程连接</td></tr><tr><td><code>port</code></td><td><code>6379</code></td><td>主节点服务端口</td><td>默认6379，可修改</td></tr><tr><td><code>requirepass</code></td><td><code>Str0ngP@ss</code></td><td>主节点访问密码</td><td>生产环境必须设置</td></tr><tr><td><code>masterauth</code></td><td><code>Str0ngP@ss</code></td><td>主从同步验证密码</td><td>需与从节点密码一致</td></tr><tr><td><code>repl-backlog-size</code></td><td><code>32mb</code></td><td>复制积压缓冲区大小</td><td>写频繁场景建议增大</td></tr><tr><td><code>repl-backlog-ttl</code></td><td><code>3600</code></td><td>缓冲区保留时间</td><td>默认3600秒(1小时)</td></tr></tbody></table><h4 id="从节点配置"><a class="markdownIt-Anchor" href="#从节点配置"></a> 从节点配置</h4><table><thead><tr><th>配置项</th><th>示例值</th><th>说明</th><th>推荐设置</th></tr></thead><tbody><tr><td><code>replicaof</code></td><td><code>192.168.1.1 6379</code></td><td>指定主节点地址</td><td>Redis 5.0+使用</td></tr><tr><td><code>slaveof</code></td><td><code>192.168.1.1 6379</code></td><td>Redis 5.0前使用</td><td>已弃用</td></tr><tr><td><code>requirepass</code></td><td><code>Str0ngP@ss</code></td><td>从节点密码</td><td>需与主节点masterauth一致</td></tr><tr><td><code>replica-read-only</code></td><td><code>yes</code></td><td>从节点只读模式</td><td>默认开启，防止误写</td></tr><tr><td><code>repl-disable-tcp-nodelay</code></td><td><code>yes</code></td><td>TCP优化选项</td><td>延迟敏感场景开启</td></tr></tbody></table><h4 id="配置验证方法"><a class="markdownIt-Anchor" href="#配置验证方法"></a> 配置验证方法</h4><ol><li><strong>主节点检查</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a yourpassword info replication</span><br></pre></td></tr></table></figure><p>查看<code>connected_slaves</code>是否为预期的从节点数量，以及每个从节点的状态信息。</p><ol start="2"><li><strong>从节点检查</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a yourpassword info replication</span><br></pre></td></tr></table></figure><p>确认<code>master_host</code>和<code>master_port</code>是否正确，<code>master_link_status</code>是否为<code>up</code>（表示连接正常）。</p><ol start="3"><li><strong>复制延迟监控</strong>： 比较主节点的<code>master_repl_offset</code>和从节点的<code>slave_repl_offset</code>，两者的差值即为复制延迟。</li></ol><h4 id="常见问题处理"><a class="markdownIt-Anchor" href="#常见问题处理"></a> 常见问题处理</h4><ol><li><p><strong>连接失败</strong>：</p><ul><li>检查防火墙设置</li><li>验证密码配置是否正确</li><li>确认主节点<code>bind</code>配置允许远程连接</li></ul></li><li><p><strong>同步中断</strong>：</p><ul><li>检查网络连接状态</li><li>查看日志文件定位问题</li><li>适当增大<code>repl-timeout</code>（默认60秒）</li></ul></li><li><p><strong>性能优化</strong>：</p><ul><li>对于大型数据集，考虑在低峰期执行全量同步</li><li>适当调整<code>repl-backlog-size</code>避免频繁全量同步</li><li>监控复制延迟，及时发现性能瓶颈</li></ul></li></ol><h2 id="三-高可用同步哨兵模式sentinel"><a class="markdownIt-Anchor" href="#三-高可用同步哨兵模式sentinel"></a> 三、高可用同步：哨兵模式（Sentinel）</h2><h3 id="31-哨兵模式的核心角色与架构"><a class="markdownIt-Anchor" href="#31-哨兵模式的核心角色与架构"></a> 3.1 哨兵模式的核心角色与架构</h3><p>哨兵模式是一个分布式系统，由以下三部分组成：</p><ol><li><p><strong>哨兵节点（Sentinel）</strong>：</p><ul><li>独立的Redis进程，不存储业务数据</li><li>主要职责：<ul><li>持续监控主从节点健康状态</li><li>检测到主节点故障时自动触发故障转移</li><li>通知客户端主从拓扑变更</li><li>充当服务发现的配置中心</li></ul></li></ul></li><li><p><strong>主节点（Master）</strong>：</p><ul><li>与普通Redis主节点功能相同</li><li>需要响应哨兵的监控请求</li><li>向哨兵报告其从节点列表</li></ul></li><li><p><strong>从节点（Slave）</strong>：</p><ul><li>与普通Redis从节点功能相同</li><li>自动被哨兵发现并监控</li><li>在故障转移时可能被提升为新主节点</li></ul></li></ol><p><strong>架构设计要点</strong>：</p><ul><li><p>哨兵节点数量必须≥3且为奇数（推荐3或5个）</p><ul><li>原因：避免脑裂，确保故障转移需要&quot;多数哨兵同意&quot;的机制能正常工作</li><li>示例：3个哨兵时，至少需要2个哨兵达成共识才能执行故障转移</li></ul></li><li><p>主从节点数量可根据业务需求灵活配置</p><ul><li>典型配置：1主2从+3哨兵（适合中小规模应用）</li><li>大型系统可能采用：1主5从+5哨兵</li></ul></li></ul><h3 id="32-哨兵模式的同步逻辑故障转移流程"><a class="markdownIt-Anchor" href="#32-哨兵模式的同步逻辑故障转移流程"></a> 3.2 哨兵模式的同步逻辑（故障转移流程）</h3><h4 id="步骤1监控sentinel-monitoring"><a class="markdownIt-Anchor" href="#步骤1监控sentinel-monitoring"></a> 步骤1：监控（Sentinel Monitoring）</h4><p>哨兵节点通过以下机制实现全面监控：</p><ol><li><strong>初始配置</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 192.168.1.1 6379 2</span><br></pre></td></tr></table></figure><ul><li><code>mymaster</code>：主节点别名</li><li><code>192.168.1.1:6379</code>：主节点地址</li><li><code>2</code>：判定客观下线需要的哨兵票数</li></ul><ol start="2"><li><p><strong>健康检查机制</strong>：</p><ul><li>每1秒发送<code>PING</code>命令到所有被监控节点<ul><li>正常响应：返回<code>PONG</code></li></ul></li><li>每10秒发送<code>INFO replication</code>到主节点<ul><li>获取从节点列表及其复制状态</li><li>自动发现新增的从节点</li></ul></li></ul></li><li><p><strong>哨兵集群通信</strong>：</p><ul><li>使用Redis的Pub/Sub功能</li><li>每2秒通过<code>__sentinel__:hello</code>频道广播节点状态</li><li>维护哨兵之间的共识状态</li></ul></li></ol><h4 id="步骤2主观下线与客观下线"><a class="markdownIt-Anchor" href="#步骤2主观下线与客观下线"></a> 步骤2：主观下线与客观下线</h4><ol><li><p><strong>主观下线（SDOWN）</strong>：</p><ul><li>触发条件：单个哨兵在<code>down-after-milliseconds</code>（默认30秒）内未收到主节点的有效响应</li><li>处理动作：该哨兵将主节点标记为&quot;主观下线&quot;</li></ul></li><li><p><strong>客观下线（ODOWN）</strong>：</p><ul><li>触发流程：<ul><li>发起投票：哨兵发送<code>SENTINEL is-master-down-by-addr</code>命令询问其他哨兵</li><li>收集响应：等待其他哨兵回复（包含它们对主节点状态的判断）</li><li>达成共识：当≥<code>quorum</code>个哨兵同意主节点不可用时，标记为&quot;客观下线&quot;</li></ul></li><li>示例：配置<code>quorum=2</code>时，需要至少2个哨兵确认主节点故障</li></ul></li></ol><h4 id="步骤3选举新主节点"><a class="markdownIt-Anchor" href="#步骤3选举新主节点"></a> 步骤3：选举新主节点</h4><p>选举过程采用多级排序策略：</p><ol><li><p><strong>第一优先级：replica-priority</strong></p><ul><li>配置项：<code>replica-priority</code>（默认100）</li><li>规则：数值越小优先级越高</li><li>应用场景：可以手动指定某些从节点优先被选为主节点</li></ul></li><li><p><strong>第二优先级：复制偏移量（offset）</strong></p><ul><li>比较各从节点与主节点的数据同步进度</li><li>选择复制进度最接近原主节点的从节点</li><li>确保数据丢失最少</li></ul></li><li><p><strong>第三优先级：runid</strong></p><ul><li>Redis实例启动时生成的唯一标识</li><li>按字典序选择runid较小的节点</li><li>作为最终裁决条件</li></ul></li></ol><h4 id="步骤4故障转移执行"><a class="markdownIt-Anchor" href="#步骤4故障转移执行"></a> 步骤4：故障转移执行</h4><p>完整的故障转移流程：</p><ol><li><strong>提升新主</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF NO ONE</span><br></pre></td></tr></table></figure><ul><li>取消新主节点的从属关系</li><li>使其开始接受写请求</li></ul><ol start="2"><li><strong>重配置从节点</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLICAOF &lt;new-master-ip&gt; &lt;new-master-port&gt;</span><br></pre></td></tr></table></figure><ul><li>所有从节点开始同步新主节点的数据</li><li>采用增量复制或全量复制（取决于复制偏移量）</li></ul><ol start="3"><li><p><strong>旧主节点处理</strong>：</p><ul><li>当旧主节点恢复后，自动被配置为新主节点的从节点</li><li>通过<code>INFO replication</code>命令可以验证复制关系</li></ul></li><li><p><strong>客户端通知</strong>：</p><ul><li>哨兵通过<code>+switch-master</code>事件通知客户端</li><li>客户端应实现自动重连机制</li></ul></li></ol><h3 id="33-哨兵模式的核心配置实战"><a class="markdownIt-Anchor" href="#33-哨兵模式的核心配置实战"></a> 3.3 哨兵模式的核心配置（实战）</h3><h4 id="关键配置详解"><a class="markdownIt-Anchor" href="#关键配置详解"></a> 关键配置详解</h4><table><thead><tr><th>配置项</th><th>说明</th><th>推荐值</th></tr></thead><tbody><tr><td><code>port 26379</code></td><td>哨兵服务端口</td><td>通常保持默认</td></tr><tr><td><code>sentinel monitor &lt;name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</code></td><td>定义监控的主节点</td><td>根据网络环境调整</td></tr><tr><td><code>sentinel down-after-milliseconds &lt;name&gt; 30000</code></td><td>主观下线判定时间</td><td>生产环境建议30-60秒</td></tr><tr><td><code>sentinel failover-timeout &lt;name&gt; 180000</code></td><td>故障转移超时时间</td><td>根据网络延迟调整</td></tr><tr><td><code>sentinel parallel-syncs &lt;name&gt; 1</code></td><td>并行同步数量</td><td>较大集群可适当增加</td></tr></tbody></table><h4 id="配置示例"><a class="markdownIt-Anchor" href="#配置示例"></a> 配置示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel.conf</span></span><br><span class="line">port 26379</span><br><span class="line">sentinel monitor mycluster 10.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mycluster 50000</span><br><span class="line">sentinel failover-timeout mycluster 120000</span><br><span class="line">sentinel auth-pass mycluster MySecurePassword</span><br><span class="line">sentinel parallel-syncs mycluster 2</span><br></pre></td></tr></table></figure><h4 id="运维检查清单"><a class="markdownIt-Anchor" href="#运维检查清单"></a> 运维检查清单</h4><ol><li><strong>启动哨兵</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /etc/redis/sentinel.conf</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>监控命令</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 26379 sentinel masters  <span class="comment"># 查看所有监控的主节点</span></span><br><span class="line">redis-cli -p 26379 sentinel slaves mymaster  <span class="comment"># 查看指定主节点的从节点 </span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>故障模拟测试</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模拟主节点宕机</span></span><br><span class="line">redis-cli -p 6379 DEBUG <span class="built_in">sleep</span> 60</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 观察哨兵日志</span></span><br><span class="line"><span class="built_in">tail</span> -f /var/log/redis/sentinel.log</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>客户端配置</strong>：</p><ul><li>应配置连接所有哨兵节点地址</li><li>实现自动故障转移处理逻辑</li><li>示例Java客户端配置：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JedisSentinelPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisSentinelPool</span>(<span class="string">&quot;mymaster&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;(Arrays.asList(</span><br><span class="line">        <span class="string">&quot;sentinel1:26379&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sentinel2:26379&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sentinel3:26379&quot;</span>)));</span><br></pre></td></tr></table></figure><h2 id="四-分布式同步redis-cluster集群模式"><a class="markdownIt-Anchor" href="#四-分布式同步redis-cluster集群模式"></a> 四、分布式同步：Redis Cluster（集群模式）</h2><h3 id="41-集群模式的核心概念"><a class="markdownIt-Anchor" href="#41-集群模式的核心概念"></a> 4.1 集群模式的核心概念</h3><h4 id="分片机制详解"><a class="markdownIt-Anchor" href="#分片机制详解"></a> 分片机制详解</h4><p>Redis Cluster 使用 CRC16 算法计算 key 的哈希值，然后对 16384 取模得到对应的哈希槽。例如：</p><ul><li>key “user:1001” 的 CRC16 值为 12345，则哈希槽为 12345 % 16384 = 12345</li><li>key “product:2002” 的 CRC16 值为 54321，则哈希槽为 54321 % 16384 = 54321</li></ul><p>哈希槽分配示例：</p><ul><li>3 节点集群：节点1(0-5460)、节点2(5461-10922)、节点3(10923-16383)</li><li>5 节点集群：每个节点约 3276 个槽</li></ul><h4 id="主从复制架构"><a class="markdownIt-Anchor" href="#主从复制架构"></a> 主从复制架构</h4><p>每个主节点可以配置多个从节点，形成多副本保护。从节点会：</p><ul><li>实时同步主节点数据</li><li>在主节点故障时参与选举</li><li>可配置为可读副本分担读压力</li></ul><h4 id="客户端重定向机制"><a class="markdownIt-Anchor" href="#客户端重定向机制"></a> 客户端重定向机制</h4><p>当客户端访问错误节点时，会收到两种重定向响应：</p><ol><li><strong>MOVED</strong>：永久重定向，表示槽已迁移到指定节点</li><li><strong>ASK</strong>：临时重定向，发生在集群扩容/缩容期间</li></ol><h3 id="42-集群模式的同步逻辑"><a class="markdownIt-Anchor" href="#42-集群模式的同步逻辑"></a> 4.2 集群模式的同步逻辑</h3><h4 id="421-分片内同步优化"><a class="markdownIt-Anchor" href="#421-分片内同步优化"></a> 4.2.1 分片内同步优化</h4><ol><li><p><strong>集群感知复制</strong>：</p><ul><li>从节点加入时通过 <code>CLUSTER MEET</code> 发现拓扑</li><li>只同步所属分片的槽数据</li><li>定期交换集群状态信息</li></ul></li><li><p><strong>读写分离配置</strong>：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 允许从节点处理读请求</span><br><span class="line">cluster-replica-ok yes</span><br></pre></td></tr></table></figure><p>启用后，从节点可以：</p><ul><li>响应本地持有的槽的读请求</li><li>其他槽请求仍返回 MOVED</li></ul><h4 id="422-故障转移流程详解"><a class="markdownIt-Anchor" href="#422-故障转移流程详解"></a> 4.2.2 故障转移流程详解</h4><ol><li><p><strong>故障检测阶段</strong>：</p><ul><li>从节点每秒发送 PING</li><li>超时后标记主节点为 <code>PFail</code> (Possible Failure)</li><li>收集其他节点的确认信息</li></ul></li><li><p><strong>选举投票规则</strong>：</p><ul><li>每个主节点有且只有一票</li><li>从节点按以下条件竞选：<ul><li>复制偏移量最新</li><li>节点运行时间最长</li><li>节点ID字典序最小</li></ul></li></ul></li><li><p><strong>数据同步阶段</strong>：</p><ul><li>新主节点生成新的复制ID</li><li>其他从节点执行部分重同步(PSYNC)</li><li>故障期间写入使用故障转移标记</li></ul></li></ol><h3 id="43-集群模式的核心配置与实战"><a class="markdownIt-Anchor" href="#43-集群模式的核心配置与实战"></a> 4.3 集群模式的核心配置与实战</h3><h4 id="配置参数详解"><a class="markdownIt-Anchor" href="#配置参数详解"></a> 配置参数详解</h4><table><thead><tr><th>配置项</th><th>推荐值</th><th>说明</th></tr></thead><tbody><tr><td>cluster-require-full-coverage</td><td>no</td><td>允许部分槽不可用时集群仍可服务</td></tr><tr><td>cluster-migration-barrier</td><td>1</td><td>主节点最少从节点数才开始迁移</td></tr><tr><td>cluster-replica-no-failover</td><td>no</td><td>从节点是否参与故障转移</td></tr></tbody></table><h4 id="集群搭建完整流程"><a class="markdownIt-Anchor" href="#集群搭建完整流程"></a> 集群搭建完整流程</h4><ol><li><strong>准备阶段</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建6个实例配置</span></span><br><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> &#123;6379..6384&#125;; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p /redis/<span class="variable">$&#123;port&#125;</span></span><br><span class="line">  <span class="built_in">cp</span> redis.conf /redis/<span class="variable">$&#123;port&#125;</span>/</span><br><span class="line">  sed -i <span class="string">&quot;s/port 6379/port <span class="variable">$&#123;port&#125;</span>/&quot;</span> /redis/<span class="variable">$&#123;port&#125;</span>/redis.conf</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>启动节点</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动所有节点</span></span><br><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> &#123;6379..6384&#125;; <span class="keyword">do</span></span><br><span class="line">  redis-server /redis/<span class="variable">$&#123;port&#125;</span>/redis.conf</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>创建集群</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create \</span><br><span class="line">  127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 \</span><br><span class="line">  127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 \</span><br><span class="line">  --cluster-replicas 1 \</span><br><span class="line">  --cluster-yes</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>验证集群</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查集群状态</span></span><br><span class="line">redis-cli -p 6379 cluster nodes | grep master</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 测试数据分布</span></span><br><span class="line">redis-cli -c -p 6379 <span class="built_in">set</span> foo bar</span><br></pre></td></tr></table></figure><h4 id="生产环境建议"><a class="markdownIt-Anchor" href="#生产环境建议"></a> 生产环境建议</h4><ol><li><p><strong>节点规划</strong>：</p><ul><li>至少3个物理机部署</li><li>每个物理机部署主从节点对</li><li>预留30%内存用于故障转移</li></ul></li><li><p><strong>监控指标</strong>：</p><ul><li>槽分布均衡性</li><li>节点间延迟</li><li>故障转移次数</li><li>集群状态变化</li></ul></li><li><p><strong>运维操作</strong>：</p><ul><li>使用 <code>redis-cli --cluster reshard</code> 进行槽迁移</li><li>定期执行 <code>CLUSTER REPLICATE</code> 调整拓扑</li><li>备份时使用 <code>CLUSTER SAVECONFIG</code></li></ul></li></ol><h2 id="五-redis-同步机制的常见问题与优化方案"><a class="markdownIt-Anchor" href="#五-redis-同步机制的常见问题与优化方案"></a> 五、Redis 同步机制的常见问题与优化方案</h2><h3 id="51-问题1全量复制频繁触发"><a class="markdownIt-Anchor" href="#51-问题1全量复制频繁触发"></a> 5.1 问题1：全量复制频繁触发</h3><h4 id="现象表现"><a class="markdownIt-Anchor" href="#现象表现"></a> 现象表现</h4><p>从节点频繁断开与重连，每次重连都触发全量复制(RDB文件传输)，导致主节点CPU和网络带宽占用过高，影响正常业务请求处理。监控中可观察到主节点CPU使用率周期性飙升，网络出口流量激增。</p><h4 id="原因分析"><a class="markdownIt-Anchor" href="#原因分析"></a> 原因分析</h4><ol><li><strong>复制缓冲区过期</strong>：从节点断线时间超过repl-backlog-ttl(默认3600秒)后，复制积压缓冲区被清空，无法支持增量复制</li><li><strong>缓冲区容量不足</strong>：复制积压缓冲区(repl-backlog-size)设置过小(默认16MB)，断线期间的写操作超出缓冲区容量</li><li><strong>主节点标识变更</strong>：主节点runid因重启等原因变更，导致从节点保存的replid与主节点不一致</li><li><strong>网络环境不稳定</strong>：网络抖动或带宽不足导致连接频繁中断</li></ol><h4 id="优化方案"><a class="markdownIt-Anchor" href="#优化方案"></a> 优化方案</h4><ol><li><p><strong>调整缓冲区参数</strong>：</p><ul><li>将repl-backlog-size从16MB调整为64-128MB(根据业务写入量计算：缓冲区大小=平均写入速率×最大预期断线时间)</li><li>将repl-backlog-ttl从3600秒延长至86400秒(1天)</li></ul></li><li><p><strong>保障主节点稳定性</strong>：</p><ul><li>主节点配置appendonly yes，开启AOF持久化</li><li>使用config set命令动态调整参数，避免重启</li><li>部署主节点高可用方案(如哨兵)</li></ul></li><li><p><strong>网络优化</strong>：</p><ul><li>主从节点部署在同一机房或可用区</li><li>使用专线连接跨机房节点</li><li>避免在网络拥堵时段进行部署或维护</li></ul></li><li><p><strong>监控与告警</strong>：</p><ul><li>监控info replication中的connected_slaves和master_repl_offset</li><li>设置全量复制次数阈值告警</li></ul></li></ol><h3 id="52-问题2从节点同步延迟高"><a class="markdownIt-Anchor" href="#52-问题2从节点同步延迟高"></a> 5.2 问题2：从节点同步延迟高</h3><h4 id="现象表现-2"><a class="markdownIt-Anchor" href="#现象表现-2"></a> 现象表现</h4><p>从节点数据与主节点差距较大，通过info replication查看master_repl_offset与slave_repl_offset差值持续增大，从节点读取到旧数据。在电商秒杀等高并发场景下，可能导致库存超卖等问题。</p><h4 id="原因分析-2"><a class="markdownIt-Anchor" href="#原因分析-2"></a> 原因分析</h4><ol><li><strong>主节点写入压力大</strong>：QPS过高导致命令传播不及时</li><li><strong>TCP缓冲延迟</strong>：repl-disable-tcp-nodelay设为no(默认)时，TCP会缓冲数据导致延迟</li><li><strong>从节点性能瓶颈</strong>：<ul><li>CPU资源不足，无法及时处理命令</li><li>内存不足，频繁触发swap</li><li>磁盘IO性能差(RDB加载慢)</li></ul></li><li><strong>从节点数量过多</strong>：单个主节点挂载过多从节点(&gt;5个)</li></ol><h4 id="优化方案-2"><a class="markdownIt-Anchor" href="#优化方案-2"></a> 优化方案</h4><ol><li><p><strong>网络传输优化</strong>：</p><ul><li>从节点配置repl-disable-tcp-nodelay yes</li><li>调整TCP内核参数(net.ipv4.tcp_slow_start_after_idle=0)</li></ul></li><li><p><strong>架构优化</strong>：</p><ul><li>使用Redis Cluster分散写入压力</li><li>实现读写分离，将读请求分散到多个从节点</li><li>限制单个主节点的从节点数量(建议≤5)</li></ul></li><li><p><strong>硬件升级</strong>：</p><ul><li>为从节点配置多核CPU(≥8核)</li><li>使用SSD替代HDD</li><li>增加内存容量，避免swap</li></ul></li><li><p><strong>监控措施</strong>：</p><ul><li>实时监控slave_repl_offset差值</li><li>设置延迟阈值告警(如&gt;100MB)</li></ul></li></ol><h3 id="53-问题3主从数据不一致"><a class="markdownIt-Anchor" href="#53-问题3主从数据不一致"></a> 5.3 问题3：主从数据不一致</h3><h4 id="现象表现-3"><a class="markdownIt-Anchor" href="#现象表现-3"></a> 现象表现</h4><p>主节点执行写命令后，部分从节点未同步该命令，导致主从数据差异。通过redis-cli的diff命令可以检测到不一致的键值，在金融交易等场景可能导致严重问题。</p><h4 id="原因分析-3"><a class="markdownIt-Anchor" href="#原因分析-3"></a> 原因分析</h4><ol><li><strong>异步复制特性</strong>：Redis默认采用异步复制，主节点宕机可能导致数据丢失</li><li><strong>从节点误写入</strong>：replica-read-only配置为no(默认yes)时，从节点可能被误写入</li><li><strong>网络分区</strong>：部分从节点长时间无法连接主节点</li><li><strong>命令传播失败</strong>：主节点在命令传播过程中崩溃</li></ol><h4 id="优化方案-3"><a class="markdownIt-Anchor" href="#优化方案-3"></a> 优化方案</h4><ol><li><strong>一致性配置</strong>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-replicas-to-write 2</span><br><span class="line">min-replicas-max-lag 10</span><br></pre></td></tr></table></figure><p>表示至少2个从节点延迟不超过10秒才允许写入</p><ol start="2"><li><p><strong>从节点保护</strong>：</p><ul><li>强制所有从节点配置replica-read-only yes</li><li>定期检查从节点配置</li></ul></li><li><p><strong>高可用部署</strong>：</p><ul><li>部署Redis Sentinel自动故障转移</li><li>使用Redis Cluster分区容错</li><li>跨机房部署时考虑网络分区场景</li></ul></li><li><p><strong>数据校验机制</strong>：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群模式检查</span></span><br><span class="line">redis-cli --cluster check &lt;host&gt;:&lt;port&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 主从数据对比</span></span><br><span class="line">redis-cli -h master --scan | <span class="keyword">while</span> <span class="built_in">read</span> key; <span class="keyword">do</span></span><br><span class="line">  diff=$(redis-cli -h master GET <span class="string">&quot;<span class="variable">$key</span>&quot;</span> | diff - &lt;(redis-cli -h slave GET <span class="string">&quot;<span class="variable">$key</span>&quot;</span>))</span><br><span class="line">  [ -n <span class="string">&quot;<span class="variable">$diff</span>&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$key</span>: <span class="variable">$diff</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ol start="5"><li><p><strong>定期修复</strong>：</p><ul><li>设置定时任务校验数据一致性</li><li>发现不一致时触发从节点resync</li></ul></li></ol><h3 id="54-问题4集群模式哈希槽迁移导致同步中断"><a class="markdownIt-Anchor" href="#54-问题4集群模式哈希槽迁移导致同步中断"></a> 5.4 问题4：集群模式哈希槽迁移导致同步中断</h3><h4 id="现象表现-4"><a class="markdownIt-Anchor" href="#现象表现-4"></a> 现象表现</h4><p>在Redis Cluster扩容/缩容时，执行CLUSTER SETSLOT MIGRATING/IMPORTING命令迁移哈希槽过程中，部分从节点同步中断，客户端请求返回MOVED/ASK重定向错误。</p><h4 id="原因分析-4"><a class="markdownIt-Anchor" href="#原因分析-4"></a> 原因分析</h4><ol><li><strong>数据变更频繁</strong>：迁移过程中大量键被修改，增量复制压力大</li><li><strong>网络波动</strong>：迁移期间网络不稳定导致连接中断</li><li><strong>资源竞争</strong>：迁移过程占用大量CPU和网络资源</li><li><strong>配置不一致</strong>：迁移后集群拓扑信息未及时同步</li></ol><h4 id="优化方案-4"><a class="markdownIt-Anchor" href="#优化方案-4"></a> 优化方案</h4><ol><li><p><strong>迁移时机选择</strong>：</p><ul><li>选择业务低峰期(如凌晨2-4点)执行迁移</li><li>监控QPS和系统负载，在负载较低时操作</li></ul></li><li><p><strong>参数调优</strong>：</p><ul><li>迁移前调大repl-backlog-size(如调整为256MB)</li><li>设置cluster-node-timeout(默认15秒)为更合理的值</li></ul></li><li><p><strong>迁移过程控制</strong>：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分批迁移键空间</span></span><br><span class="line">redis-cli --cluster rebalance \</span><br><span class="line">  --cluster-weight node1=1 node2=0 \</span><br><span class="line">  --cluster-use-empty-masters</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>监控与恢复</strong>：</p><ul><li>使用cluster slots实时监控迁移进度</li><li>迁移完成后检查所有节点cluster_state状态</li><li>对同步中断的从节点执行cluster failover强制重新同步</li></ul></li><li><p><strong>客户端处理</strong>：</p><ul><li>客户端实现ASK/MOVED重试逻辑</li><li>使用Redis集群代理屏蔽复杂度</li></ul></li></ol><h2 id="六-redis-同步机制的选型建议"><a class="markdownIt-Anchor" href="#六-redis-同步机制的选型建议"></a> 六、Redis 同步机制的选型建议</h2><h4 id="1-主从复制replication"><a class="markdownIt-Anchor" href="#1-主从复制replication"></a> 1. 主从复制（Replication）</h4><p><strong>适用场景</strong>：</p><ul><li>单机扩展、读写分离</li><li>数据备份容灾</li><li>测试/开发环境</li></ul><p><strong>推荐方案</strong>： 主从复制 + 读写分离（1主多从）</p><p><strong>优势</strong>：</p><ul><li>配置简单（通过replicaof命令即可完成）</li><li>性能开销低（异步复制）</li><li>从节点可分担读请求（如QPS 10万+的场景）</li></ul><p><strong>劣势</strong>：</p><ul><li>主节点宕机需人工切换（需要运维介入）</li><li>可用性较低（无自动故障转移）</li><li>数据延迟（异步复制导致）</li></ul><p><strong>典型应用</strong>： 电商商品详情页缓存、新闻资讯类应用</p><h4 id="2-哨兵模式sentinel"><a class="markdownIt-Anchor" href="#2-哨兵模式sentinel"></a> 2. 哨兵模式（Sentinel）</h4><p><strong>适用场景</strong>：</p><ul><li>高可用需求</li><li>自动故障转移</li><li>7x24小时服务</li></ul><p><strong>推荐方案</strong>： 至少3个哨兵节点+1主2从</p><p><strong>优势</strong>：</p><ul><li>自动监控和故障转移（30秒内完成切换）</li><li>支持通知机制（可通过API对接监控系统）</li><li>配置中心（自动更新客户端连接信息）</li></ul><p><strong>劣势</strong>：</p><ul><li>仅支持单主架构（写入瓶颈）</li><li>无法解决数据分片问题</li><li>脑裂问题需要特殊处理</li></ul><p><strong>配置示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br></pre></td></tr></table></figure><h4 id="3-集群模式cluster"><a class="markdownIt-Anchor" href="#3-集群模式cluster"></a> 3. 集群模式（Cluster）</h4><p><strong>适用场景</strong>：</p><ul><li>大数据量（TB级）</li><li>高并发写入</li><li>需要水平扩展</li></ul><p><strong>推荐方案</strong>： 至少3主3从（官方推荐）</p><p><strong>优势</strong>：</p><ul><li>自动数据分片（16384个slot）</li><li>支持水平扩展（可动态增删节点）</li><li>高可用（主从自动切换）</li></ul><p><strong>劣势</strong>：</p><ul><li>配置复杂（需要规划槽位分配）</li><li>客户端需要支持集群协议</li><li>跨slot操作受限（如事务、Lua脚本）</li></ul><p><strong>性能指标</strong>：</p><ul><li>单节点：8-10万QPS</li><li>集群：线性扩展（如10节点可达80-100万QPS）</li></ul><h4 id="最终建议"><a class="markdownIt-Anchor" href="#最终建议"></a> 最终建议：</h4><h5 id="中小规模业务数据量-10gb读多写少"><a class="markdownIt-Anchor" href="#中小规模业务数据量-10gb读多写少"></a> 中小规模业务（数据量 &lt;10GB，读多写少）</h5><p><strong>方案</strong>：主从复制 + 哨兵模式 <strong>实施要点</strong>：</p><ol><li>部署1主2从架构</li><li>配置3个哨兵节点</li><li>设置合理的down-after-milliseconds（建议5000ms）</li><li>客户端实现自动重连机制</li></ol><h5 id="大规模业务数据量-10gb高并发"><a class="markdownIt-Anchor" href="#大规模业务数据量-10gb高并发"></a> 大规模业务（数据量 &gt; 10GB，高并发）</h5><p><strong>方案</strong>：集群模式 <strong>实施步骤</strong>：</p><ol><li>使用redis-cli --cluster create初始化集群</li><li>确保每个主节点有1-2个从节点</li><li>配置cluster-require-full-coverage为no</li><li>监控集群状态（cluster nodes/cluster info）</li></ol><h5 id="对数据一致性要求极高的业务如金融支付"><a class="markdownIt-Anchor" href="#对数据一致性要求极高的业务如金融支付"></a> 对数据一致性要求极高的业务（如金融支付）</h5><p><strong>增强方案</strong>：</p><ol><li>在集群模式基础上：<ul><li>设置min-replicas-to-write 2</li><li>配置min-replicas-max-lag 10</li></ul></li><li>定期校验：<ul><li>使用redis-check-aof工具</li><li>实现CRC校验机制</li></ul></li><li>建议搭配：<ul><li>持久化采用AOF+fsync everysec</li><li>部署跨机房容灾方案</li></ul></li></ol>]]></content>
    
    
    <summary type="html">Redis 同步机制解析</summary>
    
    
    
    <category term="数据库" scheme="http://www.formeasy.cc/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="http://www.formeasy.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 解锁：C++ 实战深度探索 Set 数据类型</title>
    <link href="http://www.formeasy.cc/2025/10/05/Redis/Redis%20%E8%A7%A3%E9%94%81%EF%BC%9AC++%20%E5%AE%9E%E6%88%98%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%20Set%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.formeasy.cc/2025/10/05/Redis/Redis%20%E8%A7%A3%E9%94%81%EF%BC%9AC++%20%E5%AE%9E%E6%88%98%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%20Set%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-10-05T14:07:35.000Z</published>
    <updated>2025-10-05T14:20:08.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>欢迎来到 Redis Set 的终极指南。如果您曾需要管理一组独一无二的元素集合——无论是用户 ID、文章标签还是邮件地址——并希望以闪电般的速度对其执行强大的集合运算，那么您来对地方了。Redis Set 绝不是一个简单的列表，它是一种精妙的数据结构，将数学中强大的集合理论直接带入您的高性能数据库中。</p><p>在本文中，我们将从最基础的概念讲起，逐步深入到高级的实际应用。我们将使用优秀的 C++ 库 <code>redis-plus-plus</code> 来演示所有示例，并逐行剖析代码。无论您是 C++ 开发者、后端工程师，还是仅仅对 Redis 感到好奇，读完本文，您都将深刻理解是什么让 Set 成为 Redis 中功能最丰富的工具之一。</p><h3 id="redis-set-究竟是什么"><a class="markdownIt-Anchor" href="#redis-set-究竟是什么"></a> Redis Set 究竟是什么？</h3><p>在我们深入代码之前，先来建立一个清晰的思维模型。想象你有一个<strong>魔力袋</strong>，你可以往里面扔东西，但这个袋子有两条非常特殊的规则：</p><ol><li><strong>强制保持唯一</strong>：这个袋子会自动拒绝重复的物品。如果你想把一个标有“A”的弹珠放进一个已经有“A”弹珠的袋子里，它会阻止你，确保袋子里每样东西都只有一个。</li><li><strong>顺序毫不在意</strong>：当你从袋子里往外取东西时，它们的顺序是完全随机的。袋子不记得到底是按什么顺序把东西放进去的。</li></ol><p>这个“魔力袋”正是 Redis Set 的精准比喻：一个<strong>无序的、元素唯一的字符串集合</strong>。这个简单的定义是其强大功能的基石，使其能够以惊人的速度进行成员资格检查、数量统计以及诸如交集、并集等复杂的服务器端运算。</p><hr /><h3 id="第一章基础入门-创建和查看你的第一个-set"><a class="markdownIt-Anchor" href="#第一章基础入门-创建和查看你的第一个-set"></a> 第一章：基础入门 - 创建和查看你的第一个 Set</h3><p>让我们从最基本的操作开始：如何向一个 Set 添加元素，以及如何查看它的全部内容。为此，我们将使用 <code>SADD</code> 和 <code>SMEMBERS</code> 这两个命令。</p><h4 id="sadd向集合中添加成员"><a class="markdownIt-Anchor" href="#sadd向集合中添加成员"></a> <code>SADD</code>：向集合中添加成员</h4><p><code>SADD</code> 是您向 Set 中添加一个或多个元素的主要工具。如果某个元素已经存在，Redis 会优雅地忽略它。该命令的返回值是_新_成功添加的元素的数量。</p><h4 id="smembers获取所有成员"><a class="markdownIt-Anchor" href="#smembers获取所有成员"></a> <code>SMEMBERS</code>：获取所有成员</h4><p><code>SMEMBERS</code> 的功能正如其名：返回指定 Set 中的所有成员。这对于获取整个集合非常有用，但请注意：<strong>在拥有数百万元素的超大 Set 上使用此命令可能会暂时阻塞您的 Redis 服务器</strong>，因为它需要时间来准备所有数据。我们将在后续章节中讨论更安全的替代方案 <code>SSCAN</code>。</p><h4 id="c-实战sadd-与-smembers"><a class="markdownIt-Anchor" href="#c-实战sadd-与-smembers"></a> C++ 实战：<code>sadd</code> 与 <code>smembers</code></h4><p>现在，让我们来分析一段代码，它演示了这些基础操作。</p><p><img src="ecfbf686c86c863f90654a62651e1aeb.png" alt="image.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入必要的头文件...</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个辅助函数，用于打印容器内容</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintContainer</span><span class="params">(<span class="type">const</span> T&amp; container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : container) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(sw::redis::Redis&amp; redis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sadd 和 smembers&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 清空数据库，确保一个干净的测试环境</span></span><br><span class="line">    redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 一次添加一个元素</span></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用初始化列表，一次添加多个元素</span></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key&quot;</span>, &#123;<span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用迭代器，从另一个容器中添加多个元素</span></span><br><span class="line">    std::set&lt;std::string&gt; elems = &#123;<span class="string">&quot;555&quot;</span>, <span class="string">&quot;666&quot;</span>, <span class="string">&quot;777&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 返回值是成功插入了多少个元素</span></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key&quot;</span>, elems.<span class="built_in">begin</span>(), elems.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 现在，让我们获取所有元素 ---</span></span><br><span class="line">    std::set&lt;std::string&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为我们的 C++ set 构建一个插入迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">inserter</span>(result, result.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 Redis set 中获取所有成员，并插入到我们的 C++ set 中</span></span><br><span class="line">    redis.<span class="built_in">smembers</span>(<span class="string">&quot;key&quot;</span>, it);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintContainer</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码剖析"><a class="markdownIt-Anchor" href="#代码剖析"></a> 代码剖析：</h5><ol><li><strong><code>redis.flushall()</code></strong>：我们首先清空整个 Redis 数据库，以确保测试环境的纯净。</li><li><strong>单个元素 <code>sadd</code></strong>：<code>redis.sadd(&quot;key&quot;, &quot;111&quot;);</code> 将字符串 “111” 添加到名为 <code>key</code> 的 Set 中。由于 Set 原本是空的，此命令返回 <code>1</code>。</li><li><strong>初始化列表 <code>sadd</code></strong>：<code>redis.sadd(&quot;key&quot;, &#123;&quot;222&quot;, &quot;333&quot;, &quot;444&quot;&#125;);</code> 展示了 <code>redis-plus-plus</code> 库的一个便捷特性，允许您一次性添加多个元素。这比发送三个独立的命令效率更高。此调用将返回 <code>3</code>。</li><li><strong>基于迭代器的 <code>sadd</code></strong>：在这里，我们先填充了一个 C++ 的 <code>std::set</code>，然后使用它的迭代器（<code>elems.begin()</code>, <code>elems.end()</code>）将其所有元素添加到 Redis 的 Set 中。这对于将现有 C++ 容器中的数据同步到 Redis 非常有用。</li><li><strong>使用 <code>smembers</code> 获取数据</strong>：<ul><li>我们创建了一个 <code>std::set&lt;string&gt; result;</code> 来存放从 Redis 返回的数据。在客户端使用 <code>std::set</code> 是一个绝佳选择，因为它不仅 mirroring（镜像）了 Redis Set 的唯一性，还能自动对元素进行排序，便于我们进行可预测的展示。</li><li><code>auto it = std::inserter(result, result.end());</code> 是至关重要的一行。我们需要一种方式告诉 <code>redis-plus-plus</code> 应该把接收到的元素_放在哪里_。<code>inserter</code> 是一种特殊的迭代器，当你给它赋值时，它会调用其关联容器的 <code>insert()</code> 方法。</li><li><code>redis.smembers(&quot;key&quot;, it);</code> 执行命令。<code>redis-plus-plus</code> 获取 <code>key</code> 中的所有成员，并使用我们的迭代器 <code>it</code> 将它们逐一插入到 <code>result</code> 集合中。</li></ul></li></ol><h5 id="c-关键概念inserter-vs-back_inserter"><a class="markdownIt-Anchor" href="#c-关键概念inserter-vs-back_inserter"></a> C++ 关键概念：<code>inserter</code> vs <code>back_inserter</code></h5><p>在原始笔记中，有一个关键的区别被强调了出来：</p><ul><li><code>std::back_inserter</code> 创建一个调用 <code>push_back()</code> 的迭代器。它适用于 <code>std::vector</code>, <code>std::list</code>, <code>std::deque</code> 等容器。</li><li><code>std::set</code> <strong>没有</strong> <code>push_back()</code> 方法，因为它需要维护内部的排序。因此，对于 <code>std::set</code>，我们<strong>必须</strong>使用 <code>std::inserter</code>，它会调用 <code>insert()</code> 方法。</li></ul><h5 id="预测输出"><a class="markdownIt-Anchor" href="#预测输出"></a> 预测输出：</h5><p><code>PrintContainer</code> 函数将打印 <code>result</code> 集合的内容。由于 <code>std::set</code> 会对其元素进行排序，输出将是按字母/数字顺序排列的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sadd 和 smembers</span><br><span class="line">111 222 333 444 555 666 777</span><br></pre></td></tr></table></figure><hr /><h3 id="第二章深入探索-检查与修改你的-set"><a class="markdownIt-Anchor" href="#第二章深入探索-检查与修改你的-set"></a> 第二章：深入探索 - 检查与修改你的 Set</h3><p>既然我们知道了如何构建一个 Set，接下来让我们学习如何查询它的属性并执行基本的修改。这些命令是 Set 日常操作的核心，并且它们都快得令人难以置信。</p><h4 id="sismember这个元素存在吗-时间复杂度-o1"><a class="markdownIt-Anchor" href="#sismember这个元素存在吗-时间复杂度-o1"></a> <code>SISMEMBER</code>：这个元素存在吗？ (时间复杂度 O(1))</h4><p>这是 Set 命令库中最强大的命令之一。<code>SISMEMBER</code> 检查一个特定元素是否是 Set 的成员。如果存在，返回 <code>1</code> (true)；如果不存在，返回 <code>0</code> (false)。它的性能是 <strong>O(1)</strong>，这意味着其速度是恒定的，不依赖于 Set 的大小。无论是在一个有10个元素的 Set 还是在一个有1000万个元素的 Set 中检查成员资格，花费的时间都是相同的。</p><h5 id="c-实战sismember"><a class="markdownIt-Anchor" href="#c-实战sismember"></a> C++ 实战：<code>sismember</code></h5><p><img src="9713b0a2a8a3beabcac12fcee436e93a.png" alt="image.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">(sw::redis::Redis&amp; redis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sismember&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key&quot;</span>, &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 &quot;111&quot; 是否是集合的成员</span></span><br><span class="line">    <span class="type">bool</span> result = redis.<span class="built_in">sismember</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result:&quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>剖析</strong>：我们创建一个 Set，然后使用 <code>sismember</code> 检查 “111” 是否存在。<code>redis-plus-plus</code> 库非常方便地将 Redis 返回的 <code>1</code> 或 <code>0</code> 直接映射为了 C++ 的 <code>bool</code> 类型。因为 “111” 确实在 Set 中，<code>result</code> 将为 <code>true</code>。</li><li><strong>应用场景</strong>：<ul><li><strong>标签系统</strong>：检查一篇博客文章是否已经被标记为 “DevOps”。</li><li><strong>权限控制</strong>：检查一个 <code>userID</code> 是否在 <code>admin_users</code> 这个 Set 中。</li><li><strong>唯一性事件</strong>：检查用户是否已经执行了某个一次性操作（例如，“voted_on_poll_123”）。</li></ul></li><li><strong>预测输出</strong>：当 <code>bool true</code> 被输出到 <code>cout</code> 时，通常会显示为 <code>1</code>。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sismember</span><br><span class="line">result:1</span><br></pre></td></tr></table></figure><h4 id="scard集合里有多少元素-时间复杂度-o1"><a class="markdownIt-Anchor" href="#scard集合里有多少元素-时间复杂度-o1"></a> <code>SCARD</code>：集合里有多少元素？ (时间复杂度 O(1))</h4><p><code>SCARD</code> 代表 “Set Cardinality”（集合基数），它简单地返回一个 Set 中元素的数量。与 <code>SISMEMBER</code> 一样，这也是一个 <strong>O(1)</strong> 操作。Redis 内部维护了一个计数器，所以它不需要遍历所有元素就能告诉你总数。</p><h5 id="c-实战scard"><a class="markdownIt-Anchor" href="#c-实战scard"></a> C++ 实战：<code>scard</code></h5><p><img src="dc1d1e20840d157e1a1af23995505fcf.png" alt="image.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">(sw::redis::Redis&amp; redis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;scard&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向集合中添加4个唯一元素</span></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key&quot;</span>, &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取集合中的元素个数</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = redis.<span class="built_in">scard</span>(<span class="string">&quot;key&quot;</span>); <span class="comment">// 返回 4</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result:&quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>剖析</strong>：我们添加了四个元素，然后调用 <code>scard</code>。命令返回了计数 <code>4</code>。</li><li><strong>应用场景</strong>：<ul><li><strong>在线用户</strong>：跟踪已登录的独立用户数量。</li><li><strong>点赞计数</strong>：快速显示一张照片获得的独立点赞数。</li><li><strong>数据分析</strong>：统计今天访问网站的独立 IP 地址数量。</li></ul></li><li><strong>预测输出</strong>：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scard</span><br><span class="line">result:4</span><br></pre></td></tr></table></figure><h4 id="spop随机移除并返回一个元素"><a class="markdownIt-Anchor" href="#spop随机移除并返回一个元素"></a> <code>SPOP</code>：随机移除并返回一个元素</h4><p><code>SPOP</code> 是一个既有趣又实用的命令。它会从 Set 中<strong>随机</strong>选择一个元素，将其<strong>移除</strong>，然后<strong>返回</strong>给你。这是一种“破坏性读取”，因为元素在被读取后就从集合中消失了。</p><h5 id="c-实战spop"><a class="markdownIt-Anchor" href="#c-实战spop"></a> C++ 实战：<code>spop</code></h5><p><img src="d468a41d718f4bc1c582e2922f375a16.png" alt="image.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">(sw::redis::Redis&amp; redis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;spop&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key&quot;</span>, &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机弹出一个元素，spop 的返回值是 Optional&lt;string&gt;</span></span><br><span class="line">    <span class="keyword">auto</span> result = redis.<span class="built_in">spop</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 因为返回值是 Optional，我们通过 .value() 来获取原始的 string 内容</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;result:&quot;</span> &lt;&lt; result.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;result is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>剖析</strong>：<ul><li><code>auto result = redis.spop(&quot;key&quot;);</code> 执行命令。</li><li><code>redis-plus-plus</code> 将返回值包装在 <code>sw::redis::Optional&lt;std::string&gt;</code> 中。这是因为如果你对一个空 Set 执行 <code>spop</code>，Redis 会返回 <code>nil</code>（空）。<code>Optional</code> 类型可以优雅地处理这种情况，避免空指针等问题。</li><li><code>if (result)</code> 检查 <code>Optional</code> 对象是否真的包含一个值。在我们的例子中，由于 Set 非空，它肯定会弹出一个元素，所以条件为真。</li><li><code>result.value()</code> 从 <code>Optional</code> 中提取出实际的 <code>std::string</code> 值。</li></ul></li><li><strong>核心特性：随机性</strong>：<code>SPOP</code> 最大的特点就是随机。这意味着每次运行这段代码，得到的结果都可能不同。它非常适合需要随机处理任务的场景。</li><li><strong>应用场景</strong>：<ul><li><strong>抽奖系统</strong>：从参与用户 Set 中随机抽取一名中奖者。</li><li><strong>任务队列</strong>：从待处理任务池中随机分配一个任务给工作进程。</li><li><strong>在线匹配</strong>：从等待匹配的玩家池中随机抽取一个进行游戏。</li></ul></li><li><strong>预测输出</strong>：输出是<strong>不确定</strong>的，可能是以下四种情况之一：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 可能的输出 1</span><br><span class="line">spop</span><br><span class="line">result:111</span><br><span class="line"></span><br><span class="line">// 可能的输出 2</span><br><span class="line">spop</span><br><span class="line">result:333</span><br></pre></td></tr></table></figure><hr /><h3 id="第三章集合的威力-集合运算"><a class="markdownIt-Anchor" href="#第三章集合的威力-集合运算"></a> 第三章：集合的威力 - 集合运算</h3><p>这才是 Redis Set 真正大放异彩的地方。Redis 能够在服务器端以极高的效率执行集合的<strong>交集 (intersection)</strong>、<strong>并集 (union)</strong> 和<strong>差集 (difference)</strong> 运算，避免了将大量数据传输到客户端再进行计算的开销。</p><h4 id="交集运算sinter-sinterstore"><a class="markdownIt-Anchor" href="#交集运算sinter-sinterstore"></a> 交集运算：<code>SINTER</code> &amp; <code>SINTERSTORE</code></h4><p>交集运算会找出所有给定的 Set 中<strong>共同存在</strong>的元素。</p><ul><li><code>SINTER</code>: 计算交集并<strong>直接返回</strong>给客户端。</li><li><code>SINTERSTORE</code>: 计算交集，但<strong>不返回</strong>，而是将结果<strong>存储在一个新的目标 Set 中</strong>。</li></ul><h5 id="c-实战sinter-求交集并返回"><a class="markdownIt-Anchor" href="#c-实战sinter-求交集并返回"></a> C++ 实战：<code>sinter</code> (求交集并返回)</h5><p><img src="6b72b60fe1898e72ae64816ea8a5b213.png" alt="image.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test5</span><span class="params">(sw::redis::Redis&amp; redis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里的 cout 应该是 &quot;sinter&quot;，一个小笔误</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sinter&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key1&quot;</span>, &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>&#125;);</span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key2&quot;</span>, &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;444&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    std::set&lt;std::string&gt; result;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">inserter</span>(result, result.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求交集涉及多个 key，我们使用初始化列表来描述</span></span><br><span class="line">    <span class="comment">// 将 &quot;key1&quot; 和 &quot;key2&quot; 的交集插入到 result 中</span></span><br><span class="line">    redis.<span class="built_in">sinter</span>(&#123;<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;key2&quot;</span>&#125;, it);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintContainer</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>剖析</strong>：<ul><li><code>key1</code> 包含 <code>&#123;&quot;111&quot;, &quot;222&quot;, &quot;333&quot;, &quot;444&quot;&#125;</code>。</li><li><code>key2</code> 包含 <code>&#123;&quot;111&quot;, &quot;222&quot;, &quot;444&quot;&#125;</code>。</li><li><code>redis.sinter(&#123;&quot;key1&quot;, &quot;key2&quot;&#125;, it);</code> 命令计算出两个集合的共同成员是 <code>&#123;&quot;111&quot;, &quot;222&quot;, &quot;444&quot;&#125;</code>，并通过迭代器将它们存入 C++ 的 <code>result</code> 集合中。</li></ul></li><li><strong>应用场景</strong>：<ul><li><strong>共同好友</strong>：计算用户A的好友列表和用户B的好友列表的交集。</li><li><strong>内容推荐</strong>：找出同时对 “科幻” 和 “悬疑” 标签感兴趣的用户。</li></ul></li><li><strong>预测输出</strong>：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sinter</span><br><span class="line">111 222 444</span><br></pre></td></tr></table></figure><h5 id="c-实战sinterstore-求交集并存储"><a class="markdownIt-Anchor" href="#c-实战sinterstore-求交集并存储"></a> C++ 实战：<code>sinterstore</code> (求交集并存储)</h5><p><img src="39517223411c5e3c73a08b152ce72cf3.png" alt="image.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test6</span><span class="params">(sw::redis::Redis&amp; redis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sinterstore&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key1&quot;</span>, &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>&#125;);</span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key2&quot;</span>, &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;444&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定一个 destination (&quot;key3&quot;)，将交集结果存储到其中</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> len = redis.<span class="built_in">sinterstore</span>(<span class="string">&quot;key3&quot;</span>, &#123;<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;key2&quot;</span>&#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;len:&quot;</span> &lt;&lt; len &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 &quot;key3&quot; 中的元素以验证结果</span></span><br><span class="line">    std::set&lt;std::string&gt; result;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">inserter</span>(result, result.<span class="built_in">end</span>());</span><br><span class="line">    redis.<span class="built_in">smembers</span>(<span class="string">&quot;key3&quot;</span>, it);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintContainer</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>剖析</strong>：<ul><li><code>redis.sinterstore(&quot;key3&quot;, &#123;&quot;key1&quot;, &quot;key2&quot;&#125;);</code> 计算出交集 <code>&#123;&quot;111&quot;, &quot;222&quot;&#125;</code>，然后将这个结果存入一个全新的 Set <code>key3</code> 中。如果 <code>key3</code> 已存在，它将被覆盖。</li><li>该命令返回新生成的 <code>key3</code> 集合的元素数量，即 <code>2</code>。所以 <code>len</code> 的值为 <code>2</code>。</li><li>后续的 <code>smembers</code> 验证了 <code>key3</code> 的内容确实是正确的交集结果。</li></ul></li><li><strong>应用场景</strong>：当你需要<strong>缓存</strong>或<strong>复用</strong>交集计算结果时，<code>SINTERSTORE</code> 非常有用。例如，为一组用户预先计算出他们共同喜欢的商品列表。</li><li><strong>预测输出</strong>：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore</span><br><span class="line">len:2</span><br><span class="line">111 222</span><br></pre></td></tr></table></figure><hr /><h3 id="第四章超越基础-更多强大的-set-命令"><a class="markdownIt-Anchor" href="#第四章超越基础-更多强大的-set-命令"></a> 第四章：超越基础 - 更多强大的 Set 命令</h3><p>我们已经覆盖了所提供代码中的所有命令，但 Redis Set 的能力远不止于此。为了成为真正的 Set 大师，让我们来了解一下其他一些极其有用的命令。</p><h4 id="并集运算sunion-sunionstore"><a class="markdownIt-Anchor" href="#并集运算sunion-sunionstore"></a> 并集运算：<code>SUNION</code> &amp; <code>SUNIONSTORE</code></h4><p>并集运算返回所有给定集合的全部<strong>不重复</strong>的元素。</p><ul><li><strong>命令</strong>：<code>SUNION key [key ...]</code> 和 <code>SUNIONSTORE destination key [key ...]</code></li><li><strong>应用场景</strong>：<ul><li><strong>好友圈</strong>：获取用户A的好友、用户B的好友和用户C的好友的完整、不重复的列表。</li><li><strong>权限合并</strong>：一个用户属于 “editor” 角色组和 “publisher” 角色组，通过并集可以得到该用户拥有的所有权限的集合。</li></ul></li></ul><h4 id="差集运算sdiff-sdiffstore"><a class="markdownIt-Anchor" href="#差集运算sdiff-sdiffstore"></a> 差集运算：<code>SDIFF</code> &amp; <code>SDIFFSTORE</code></h4><p>差集运算返回那些只存在于<strong>第一个</strong>集合中，但不在任何后续集合中的元素。</p><ul><li><strong>命令</strong>：<code>SDIFF key [key ...]</code> 和 <code>SDIFFSTORE destination key [key ...]</code></li><li><strong>应用场景</strong>：<ul><li><strong>好友推荐</strong>：找出我的好友中，有哪些还不是我朋友A的好友，从而可以向我推荐。</li><li><strong>内容去重</strong>：向用户展示新闻时，从“今日热点”中排除掉他“已读新闻”Set 中的内容。</li></ul></li></ul><h4 id="安全迭代sscan"><a class="markdownIt-Anchor" href="#安全迭代sscan"></a> 安全迭代：<code>SSCAN</code></h4><p>正如前文提到的，<code>SMEMBERS</code> 对于大集合是危险的。<code>SSCAN</code> 提供了安全的替代方案。它使用一个游标 (cursor) 来分批次地返回集合中的元素，每次只返回一小部分，绝不会阻塞服务器。</p><ul><li><strong>命令</strong>：<code>SSCAN key cursor [MATCH pattern] [COUNT count]</code></li><li><strong>工作方式</strong>：你用一个初始为 <code>0</code> 的游标开始第一次调用。Redis 返回下一批元素和一个新的游标。你用这个新的游标进行下一次调用，如此往复，直到返回的游标为 <code>0</code>，表示迭代完成。</li><li><strong>适用场景</strong>：任何需要遍历生产环境中大集合的操作，例如数据迁移、离线分析等。</li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>Redis Set 是一种看似简单却异常强大的数据结构。让我们回顾一下它的核心优势：</p><ul><li><strong>唯一性</strong>：自动处理数据去重，简化了应用逻辑。</li><li><strong>极速性能</strong>：绝大多数核心操作（增、删、查、计数）的时间复杂度都是 O(1)，性能与集合大小无关。</li><li><strong>强大的集合运算</strong>：能够在服务器端原子性地、高效地执行交、并、差集运算，极大地减少了网络开销和客户端的计算压力。</li></ul><p>从简单的在线用户统计，到复杂的社交网络好友关系分析，再到智能推荐系统，Redis Set 都能以其优雅和高效提供坚实的解决方案。希望通过本文的深度解析和 C++ 代码示例，您已经准备好在自己的项目中发挥 Redis Set 的真正威力了。</p>]]></content>
    
    
    <summary type="html">Redis 解锁：C++ 实战深度探索 Set 数据类型</summary>
    
    
    
    <category term="数据库" scheme="http://www.formeasy.cc/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="http://www.formeasy.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SQL 优化实战案例：从慢查询到高性能的完整指南</title>
    <link href="http://www.formeasy.cc/2025/10/05/MySQL/SQL%20%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E4%BB%8E%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/"/>
    <id>http://www.formeasy.cc/2025/10/05/MySQL/SQL%20%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E4%BB%8E%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</id>
    <published>2025-10-05T13:21:30.000Z</published>
    <updated>2025-10-05T13:55:55.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-常见-sql-性能问题概览"><a class="markdownIt-Anchor" href="#一-常见-sql-性能问题概览"></a> 📊 一、常见 SQL 性能问题概览</h2><h3 id="生产环境性能问题分布"><a class="markdownIt-Anchor" href="#生产环境性能问题分布"></a> 🚨 生产环境性能问题分布</h3><p>根据对 1000+ 生产环境慢查询的分析，常见问题比例如下：</p><p>索引问题：45%<br />JOIN优化：25%<br />全表扫描：15%<br />锁竞争：10%<br />其它：5%</p><h3 id="性能问题症状识别"><a class="markdownIt-Anchor" href="#性能问题症状识别"></a> 📈 性能问题症状识别</h3><p><strong>快速诊断指标</strong>：</p><ul><li><p><strong>查询时间</strong> &gt; 1秒：需要优化</p></li><li><p><strong>扫描行数</strong> &gt; 10000行：索引可能失效</p></li><li><p><strong>临时表使用</strong>：需要优化查询或索引</p></li><li><p><strong>文件排序</strong>：添加合适的索引</p></li></ul><h2 id="二-案例一慢查询优化实战"><a class="markdownIt-Anchor" href="#二-案例一慢查询优化实战"></a> ⚡ 二、案例一：慢查询优化实战</h2><h3 id="问题场景电商订单查询缓慢"><a class="markdownIt-Anchor" href="#问题场景电商订单查询缓慢"></a> 🎯 问题场景：电商订单查询缓慢</h3><p><strong>原始慢查询</strong>（执行时间：3.2秒）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1001</span> </span><br><span class="line">  <span class="keyword">AND</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> status <span class="keyword">IN</span> (<span class="string">&#x27;completed&#x27;</span>, <span class="string">&#x27;shipped&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="问题分析过程"><a class="markdownIt-Anchor" href="#问题分析过程"></a> 🔍 问题分析过程</h3><p><strong>执行计划分析</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1001</span> </span><br><span class="line">  <span class="keyword">AND</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> status <span class="keyword">IN</span> (<span class="string">&#x27;completed&#x27;</span>, <span class="string">&#x27;shipped&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>执行计划输出</strong>：</p><pre><code>+----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra                       |+----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+|  1 | SIMPLE      | orders | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 500000 |     1.00 | Using where; Using filesort |+----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+</code></pre><p><strong>问题诊断</strong>：</p><ul><li><p>type: ALL：全表扫描 50 万行数据</p></li><li><p>Using filesort：文件排序，性能杀手</p></li><li><p>缺少合适索引</p></li></ul><h3 id="️-优化方案"><a class="markdownIt-Anchor" href="#️-优化方案"></a> 🛠️ 优化方案</h3><p><strong>创建复合索引</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据查询条件创建最优索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_status_date </span><br><span class="line"><span class="keyword">ON</span> orders(user_id, status, order_date);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 包含所有过滤字段和排序字段</span></span><br></pre></td></tr></table></figure><p><strong>优化后查询</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用覆盖索引优化</span></span><br><span class="line"><span class="keyword">SELECT</span> order_id, user_id, order_date, status, amount</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1001</span> </span><br><span class="line">  <span class="keyword">AND</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> status <span class="keyword">IN</span> (<span class="string">&#x27;completed&#x27;</span>, <span class="string">&#x27;shipped&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="性能对比"><a class="markdownIt-Anchor" href="#性能对比"></a> 📊 性能对比</h3><table><thead><tr><th>策略</th><th>实现方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>无索引查询</strong></td><td>全表扫描 + 文件排序</td><td>实现简单，无需索引维护</td><td>性能极差，数据量大时不可用</td><td>小表查询（数据量 &lt; 1000 行）</td></tr><tr><td><strong>复合索引优化</strong></td><td>创建 <code>(user_id, status, order_date)</code> 复合索引</td><td>查询性能提升 64 倍，减少磁盘 I/O</td><td>需要额外存储空间，写入稍慢</td><td>中大型表，频繁查询条件固定</td></tr></tbody></table><p><strong>优化效果</strong>：</p><ul><li><p><strong>执行时间</strong>：3.2秒 → 0.05秒（<strong>64倍提升</strong>）</p></li><li><p><strong>扫描行数</strong>：500,000行 → 150行（<strong>3333倍提升</strong>）</p></li><li><p><strong>CPU使用</strong>：95% → 5%（<strong>19倍降低</strong>）</p></li></ul><h2 id="三-案例二索引深度优化"><a class="markdownIt-Anchor" href="#三-案例二索引深度优化"></a> 🔍 三、案例二：索引深度优化</h2><h3 id="问题场景用户搜索功能性能瓶颈"><a class="markdownIt-Anchor" href="#问题场景用户搜索功能性能瓶颈"></a> 🎯 问题场景：用户搜索功能性能瓶颈</h3><p><strong>原始查询</strong>（执行时间：2.1秒）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">&#x27;%john%&#x27;</span></span><br><span class="line">   <span class="keyword">OR</span> email <span class="keyword">LIKE</span> <span class="string">&#x27;%john%&#x27;</span></span><br><span class="line">   <span class="keyword">OR</span> phone <span class="keyword">LIKE</span> <span class="string">&#x27;%john%&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">50</span>;</span><br></pre></td></tr></table></figure><h3 id="索引问题分析"><a class="markdownIt-Anchor" href="#索引问题分析"></a> 🔍 索引问题分析</h3><p><strong>现有索引情况</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查现有索引</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> users;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出：</span></span><br><span class="line"><span class="comment">-- INDEX (username)  -- 前缀索引</span></span><br><span class="line"><span class="comment">-- INDEX (email)     -- 前缀索引  </span></span><br><span class="line"><span class="comment">-- INDEX (phone)     -- 前缀索引</span></span><br></pre></td></tr></table></figure><p><strong>执行计划分析</strong>：</p><pre><code>+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra                       |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+|  1 | SIMPLE      | users | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 100000 |    100.00 | Using where; Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+</code></pre><p><strong>问题根源</strong>：</p><ul><li><p>LIKE '%john%'导致索引失效</p></li><li><p>OR 条件合并导致全表扫描</p></li><li><p>多个单列索引未有效利用</p></li></ul><h3 id="️-优化策略"><a class="markdownIt-Anchor" href="#️-优化策略"></a> 🛠️ 优化策略</h3><p><strong>方案一：全文索引优化</strong>（MySQL 5.6+）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建全文索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users </span><br><span class="line"><span class="keyword">ADD</span> FULLTEXT idx_search_fields(username, email, phone);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用全文搜索</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(username, email, phone) AGAINST(<span class="string">&#x27;john&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">50</span>;</span><br></pre></td></tr></table></figure><p><strong>方案二：分词索引优化</strong>（兼容性更好）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加搜索专用字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> search_tags <span class="type">VARCHAR</span>(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> search_tags <span class="operator">=</span> CONCAT(username, <span class="string">&#x27; &#x27;</span>, email, <span class="string">&#x27; &#x27;</span>, phone);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建分词索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_search_tags <span class="keyword">ON</span> users(search_tags(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> search_tags <span class="keyword">LIKE</span> <span class="string">&#x27;john%&#x27;</span> </span><br><span class="line">   <span class="keyword">OR</span> search_tags <span class="keyword">LIKE</span> <span class="string">&#x27;% john%&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">50</span>;</span><br></pre></td></tr></table></figure><h3 id="优化方案对比"><a class="markdownIt-Anchor" href="#优化方案对比"></a> 📊 优化方案对比</h3><table><thead><tr><th>策略</th><th>实现方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>单列索引</strong></td><td>为每个字段创建独立索引</td><td>简单直观，维护方便</td><td>OR 条件无法有效利用，<code>LIKE '%xxx'</code> 模糊查询失效</td><td>精确查询，字段独立使用</td></tr><tr><td><strong>全文索引</strong></td><td>使用 <code>MATCH ... AGAINST</code> 语法</td><td>专业文本搜索，支持相关性排序</td><td>MySQL 5.6+ 才支持，中文分词需额外插件（如 <code>ngram</code>、<code>mmseg</code>）</td><td>大量文本搜索，CMS、论坛、博客系统</td></tr><tr><td><strong>分词索引</strong></td><td>创建搜索专用字段 + 前缀索引</td><td>兼容性好，<code>LIKE 'xxx%'</code> 模糊查询可用</td><td>需要维护额外字段，存在一定数据冗余</td><td>中小规模搜索，对兼容性要求高的业务场景</td></tr></tbody></table><p><strong>优化效果</strong>：</p><ul><li><strong>全文索引方案</strong>：2.1秒 → 0.08秒（<strong>26倍提升</strong>）</li><li><strong>分词索引方案</strong>：2.1秒 → 0.15秒（<strong>14倍提升</strong>）</li></ul><h2 id="四-案例三大表-join-优化"><a class="markdownIt-Anchor" href="#四-案例三大表-join-优化"></a> 🔗 四、案例三：大表 JOIN 优化</h2><h3 id="问题场景电商报表查询超时"><a class="markdownIt-Anchor" href="#问题场景电商报表查询超时"></a> 🎯 问题场景：电商报表查询超时</h3><p><strong>原始查询</strong>（执行时间：12.5秒）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    u.username,</span><br><span class="line">    o.order_id,</span><br><span class="line">    o.amount,</span><br><span class="line">    p.product_name,</span><br><span class="line">    c.category_name</span><br><span class="line"><span class="keyword">FROM</span> users u</span><br><span class="line"><span class="keyword">JOIN</span> orders o <span class="keyword">ON</span> u.user_id <span class="operator">=</span> o.user_id</span><br><span class="line"><span class="keyword">JOIN</span> order_items oi <span class="keyword">ON</span> o.order_id <span class="operator">=</span> oi.order_id</span><br><span class="line"><span class="keyword">JOIN</span> products p <span class="keyword">ON</span> oi.product_id <span class="operator">=</span> p.product_id</span><br><span class="line"><span class="keyword">JOIN</span> categories c <span class="keyword">ON</span> p.category_id <span class="operator">=</span> c.category_id</span><br><span class="line"><span class="keyword">WHERE</span> u.register_date <span class="operator">&gt;=</span> <span class="string">&#x27;2023-01-01&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> o.order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> o.amount <span class="operator">&gt;</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> o.order_date <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="join-问题分析"><a class="markdownIt-Anchor" href="#join-问题分析"></a> 🔍 JOIN 问题分析</h3><p><strong>表数据量分析</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 各表数据量</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="string">&#x27;users&#x27;</span> <span class="keyword">as</span> table_name, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> count <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;orders&#x27;</span>, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span>  </span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;order_items&#x27;</span>, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> order_items</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;products&#x27;</span>, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;categories&#x27;</span>, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> categories;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><pre><code>+------------+---------+| table_name | count   |+------------+---------+| users      | 100,000 || orders     | 1,000,000|| order_items| 5,000,000|| products   | 50,000  || categories | 500     |+------------+---------+</code></pre><p><strong>执行计划分析</strong>：</p><pre><code>+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+---------+----------+----------------------------------------------------+| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                  | rows    | filtered | Extra                                              |+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+---------+----------+----------------------------------------------------+|  1 | SIMPLE      | u     | NULL       | range  | PRIMARY       | PRIMARY | 4       | NULL                 | 50000   |   100.00 | Using index condition; Using temporary; Using filesort ||  1 | SIMPLE      | o     | NULL       | ref    | idx_user_id   | idx_user_id | 5    | db.u.user_id         | 10      |    33.33 | Using where                                        ||  1 | SIMPLE      | oi    | NULL       | ref    | idx_order_id  | idx_order_id | 4    | db.o.order_id       | 5       |   100.00 | NULL                                               ||  1 | SIMPLE      | p     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | db.oi.product_id     | 1       |   100.00 | NULL                                               ||  1 | SIMPLE      | c     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | db.p.category_id    | 1       |   100.00 | NULL                                               |+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+---------+----------+----------------------------------------------------+</code></pre><p><strong>问题诊断</strong>：</p><ul><li><p><strong>驱动表选择不当</strong>：从 50,000 行 users 表开始</p></li><li><p><strong>中间结果集过大</strong>：多次 JOIN 产生大量中间数据</p></li><li><p><strong>排序性能差</strong>：对大量数据排序</p></li></ul><h3 id="️-优化方案-2"><a class="markdownIt-Anchor" href="#️-优化方案-2"></a> 🛠️ 优化方案</h3><p><strong>方案一：优化 JOIN 顺序和索引</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 添加缺失索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_orders_user_date_amount </span><br><span class="line"><span class="keyword">ON</span> orders(user_id, order_date, amount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_users_register_date </span><br><span class="line"><span class="keyword">ON</span> users(register_date, user_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 使用 STRAIGHT_JOIN 强制优化器使用最佳顺序</span></span><br><span class="line"><span class="keyword">SELECT</span> STRAIGHT_JOIN</span><br><span class="line">    u.username,</span><br><span class="line">    o.order_id,</span><br><span class="line">    o.amount,</span><br><span class="line">    p.product_name,</span><br><span class="line">    c.category_name</span><br><span class="line"><span class="keyword">FROM</span> orders o  <span class="comment">-- 从 orders 开始，过滤条件更强</span></span><br><span class="line"><span class="keyword">JOIN</span> users u <span class="keyword">ON</span> o.user_id <span class="operator">=</span> u.user_id</span><br><span class="line"><span class="keyword">JOIN</span> order_items oi <span class="keyword">ON</span> o.order_id <span class="operator">=</span> oi.order_id</span><br><span class="line"><span class="keyword">JOIN</span> products p <span class="keyword">ON</span> oi.product_id <span class="operator">=</span> p.product_id</span><br><span class="line"><span class="keyword">JOIN</span> categories c <span class="keyword">ON</span> p.category_id <span class="operator">=</span> c.category_id</span><br><span class="line"><span class="keyword">WHERE</span> u.register_date <span class="operator">&gt;=</span> <span class="string">&#x27;2023-01-01&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> o.order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> o.amount <span class="operator">&gt;</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> o.order_date <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>方案二：分阶段查询 + 临时表：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 第一阶段：过滤核心数据</span></span><br><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> temp_orders <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> o.order_id, o.user_id, o.amount, o.order_date</span><br><span class="line"><span class="keyword">FROM</span> orders o</span><br><span class="line"><span class="keyword">WHERE</span> o.order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> o.amount <span class="operator">&gt;</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> o.order_date <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1000</span>;  <span class="comment">-- 扩大限制，确保最终有100条</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二阶段：关联其他表</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    u.username,</span><br><span class="line">    t.order_id,</span><br><span class="line">    t.amount,</span><br><span class="line">    p.product_name,</span><br><span class="line">    c.category_name</span><br><span class="line"><span class="keyword">FROM</span> temp_orders t</span><br><span class="line"><span class="keyword">JOIN</span> users u <span class="keyword">ON</span> t.user_id <span class="operator">=</span> u.user_id</span><br><span class="line"><span class="keyword">JOIN</span> order_items oi <span class="keyword">ON</span> t.order_id <span class="operator">=</span> oi.order_id</span><br><span class="line"><span class="keyword">JOIN</span> products p <span class="keyword">ON</span> oi.product_id <span class="operator">=</span> p.product_id</span><br><span class="line"><span class="keyword">JOIN</span> categories c <span class="keyword">ON</span> p.category_id <span class="operator">=</span> c.category_id</span><br><span class="line"><span class="keyword">WHERE</span> u.register_date <span class="operator">&gt;=</span> <span class="string">&#x27;2023-01-01&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t.order_date <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="优化策略对比"><a class="markdownIt-Anchor" href="#优化策略对比"></a> 📊 优化策略对比</h3><table><thead><tr><th>策略</th><th>实现方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>原始 JOIN</strong></td><td>多表直接关联，依赖优化器</td><td>代码简洁，逻辑清晰</td><td>性能不可控，容易触发全表扫描</td><td>小数据量，开发测试环境</td></tr><tr><td><strong>优化 JOIN 顺序</strong></td><td>使用 <code>STRAIGHT_JOIN</code> 强制执行顺序</td><td>性能可控，避免优化器误判</td><td>需要手动分析，硬编码不够灵活</td><td>表关系复杂，优化器选择不佳时</td></tr><tr><td><strong>分阶段查询</strong></td><td>借助临时表 + 分步查询</td><td>内存消耗低，性能更稳定</td><td>代码复杂度高，需要多次查询</td><td>超大数据量，复杂聚合计算</td></tr></tbody></table><p><strong>优化效果：</strong></p><p><strong>优化JOIN顺序</strong>：12.5秒 → 1.2秒（10倍提升）</p><p><strong>分阶段查询</strong>：12.5秒 → 0.8秒（15倍提升）</p><h2 id="五-总结与优化方法论"><a class="markdownIt-Anchor" href="#五-总结与优化方法论"></a> 💡 五、总结与优化方法论</h2><h3 id="sql-优化核心原则"><a class="markdownIt-Anchor" href="#sql-优化核心原则"></a> 🎯 SQL 优化核心原则</h3><p><strong>优化优先级：</strong></p><p>索引优化：</p><ul><li>添加缺失索引</li><li>优化索引结构</li><li>覆盖索引</li></ul><p>查询重写</p><ul><li>减少JOIN</li><li>优化WHERE</li><li>分页优化</li></ul><p>架构调整</p><ul><li>读写分离</li><li>分库分表</li><li>缓存策略</li></ul><h3 id="优化检查清单"><a class="markdownIt-Anchor" href="#优化检查清单"></a> 📝 优化检查清单</h3><p><strong>索引优化检查项：</strong></p><ul><li><p>✅ WHERE 条件字段是否有索引？</p></li><li><p>✅ ORDER BY/GROUP BY 字段是否有索引？</p></li><li><p>✅ 复合索引字段顺序是否最优？</p></li><li><p>✅ 是否使用覆盖索引？</p></li><li><p>✅ 索引选择性是否足够高？</p></li></ul><p><strong>查询优化检查项：</strong></p><ul><li><p>✅ 是否避免 SELECT *？</p></li><li><p>✅ 是否使用 LIMIT 限制返回行数？</p></li><li><p>✅ JOIN 条件是否有索引？</p></li><li><p>✅ 是否避免在 WHERE 中使用函数？</p></li><li><p>✅ 是否合理使用 UNION 替代 OR？</p></li></ul><h3 id="️-整体优化方案对比"><a class="markdownIt-Anchor" href="#️-整体优化方案对比"></a> 🛠️ 整体优化方案对比</h3><table><thead><tr><th>优化维度</th><th>基础方案</th><th>进阶方案</th><th>高级方案</th><th>选择建议</th></tr></thead><tbody><tr><td><strong>索引策略</strong></td><td>单列索引</td><td>复合索引</td><td>覆盖索引</td><td>根据查询频率和字段选择</td></tr><tr><td><strong>查询优化</strong></td><td>减少 SELECT *</td><td>使用 LIMIT</td><td>分页优化</td><td>结合业务需求逐步优化</td></tr><tr><td><strong>JOIN 优化</strong></td><td>添加关联索引</td><td>调整 JOIN 顺序</td><td>分阶段查询</td><td>根据数据量和复杂度选择</td></tr><tr><td><strong>架构优化</strong></td><td>查询优化</td><td>读写分离</td><td>分库分表</td><td>按业务增长阶段实施</td></tr></tbody></table><h3 id="性能监控工具对比"><a class="markdownIt-Anchor" href="#性能监控工具对比"></a> 🔧 性能监控工具对比</h3><table><thead><tr><th>分析工具</th><th>使用方式</th><th>输出内容</th><th>适用阶段</th><th>学习成本</th></tr></thead><tbody><tr><td><strong>EXPLAIN</strong></td><td>EXPLAIN SELECT …</td><td>执行计划详情</td><td>日常开发</td><td>低</td></tr><tr><td><strong>EXPLAIN ANALYZE</strong></td><td>EXPLAIN ANALYZE SELECT …</td><td>实际执行统计</td><td>性能调优</td><td>中</td></tr><tr><td><strong>慢查询日志</strong></td><td>配置 slow_query_log</td><td>慢 SQL 记录</td><td>问题排查</td><td>中</td></tr><tr><td><strong>Performance Schema</strong></td><td>查询系统表</td><td>详细性能指标</td><td>深度优化</td><td>高</td></tr></tbody></table><h3 id="进阶优化策略"><a class="markdownIt-Anchor" href="#进阶优化策略"></a> 🚀 进阶优化策略</h3><p><strong>读写分离架构：</strong></p><p>应用层 -&gt; （写主库 - 读从库1 - 读从库2 - 读从库3） -&gt; 主库</p><p><strong>分库分表策略：</strong></p><p><strong>垂直分表</strong>：将大字段分离到扩展表</p><p><strong>水平分表</strong>：按时间或ID范围拆分</p><p><strong>分库</strong>：按业务模块分离</p><h3 id="持续学习路径"><a class="markdownIt-Anchor" href="#持续学习路径"></a> 📚 持续学习路径</h3><p><strong>推荐学习资源</strong>：</p><ul><li><p>MySQL 官方文档：EXPLAIN 输出详解</p></li><li><p>Percona Toolkit：性能分析工具</p></li><li><p>sys Schema：MySQL 性能监控视图</p></li><li><p>数据库设计范式：从源头避免性能问题</p></li></ul>]]></content>
    
    
    <summary type="html">SQL 优化实战案例：从慢查询到高性能的完整指南</summary>
    
    
    
    <category term="数据库" scheme="http://www.formeasy.cc/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="http://www.formeasy.cc/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>【Redis缓存一致性：如何保证数据库与缓存同步】</title>
    <link href="http://www.formeasy.cc/2025/10/04/Redis/%E3%80%90Redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5%E3%80%91/"/>
    <id>http://www.formeasy.cc/2025/10/04/Redis/%E3%80%90Redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5%E3%80%91/</id>
    <published>2025-10-04T08:11:24.000Z</published>
    <updated>2025-10-04T08:18:28.754Z</updated>
    
    <content type="html"><![CDATA[<p>💡 摘要：是否遇到过缓存数据与数据库不一致的尴尬局面？是否在数据更新后发现用户看到的还是旧数据？缓存一致性是分布式系统中最具挑战性的问题之一，它直接影响到数据的准确性和用户体验。本文将深入探讨Redis缓存一致性的各种解决方案，从简单的更新策略到复杂的最终一致性方案，帮你构建可靠的数据同步体系！</p><hr /><h3 id="一-缓存一致性挑战"><a class="markdownIt-Anchor" href="#一-缓存一致性挑战"></a> 一、缓存一致性挑战</h3><h4 id="1-为什么缓存一致性很难"><a class="markdownIt-Anchor" href="#1-为什么缓存一致性很难"></a> 1. 为什么缓存一致性很难？</h4><p><strong>典型的不一致场景</strong>：</p><ul><li><p>🕒 <strong>时序问题</strong>：缓存更新和数据库更新的顺序</p></li><li><p>⚡ <strong>并发冲突</strong>：多个请求同时更新同一数据</p></li><li><p>🔄 <strong>操作失败</strong>：一个操作成功另一个失败</p></li><li><p>🗑️ <strong>缓存失效</strong>：缓存过期或淘汰导致数据不一致</p></li></ul><p><img src="c1a02890a7ad4c8cb1d6d172adcdb820.png" alt="" /></p><h4 id="2-一致性级别对比"><a class="markdownIt-Anchor" href="#2-一致性级别对比"></a> 2. 一致性级别对比</h4><table><thead><tr><th>一致性级别</th><th>描述</th><th>性能影响</th><th>实现复杂度</th></tr></thead><tbody><tr><td><strong>强一致性</strong></td><td>任何时刻数据一致</td><td>高</td><td>极高</td></tr><tr><td><strong>最终一致性</strong></td><td>一段时间后数据一致</td><td>中</td><td>中</td></tr><tr><td><strong>弱一致性</strong></td><td>不保证数据一致</td><td>低</td><td>低</td></tr></tbody></table><h3 id="二-基础更新策略"><a class="markdownIt-Anchor" href="#二-基础更新策略"></a> 二、基础更新策略</h3><h4 id="1-cache-aside模式旁路缓存"><a class="markdownIt-Anchor" href="#1-cache-aside模式旁路缓存"></a> 1. Cache-Aside模式（旁路缓存）</h4><p><strong>最常用的缓存模式</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_user</span>(<span class="params">user_id</span>):</span><br><span class="line">    <span class="comment"># 1. 先查缓存</span></span><br><span class="line">    user_data = redis.get(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> user_data:</span><br><span class="line">        <span class="keyword">return</span> user_data</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 缓存不存在，查数据库</span></span><br><span class="line">    user_data = db.query(<span class="string">&quot;SELECT * FROM users WHERE id = %s&quot;</span>, user_id)</span><br><span class="line">    <span class="keyword">if</span> user_data:</span><br><span class="line">        <span class="comment"># 3. 写入缓存</span></span><br><span class="line">        redis.setex(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>, <span class="number">3600</span>, user_data)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> user_data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_user</span>(<span class="params">user_id, new_data</span>):</span><br><span class="line">    <span class="comment"># 1. 先更新数据库</span></span><br><span class="line">    db.update(<span class="string">&quot;UPDATE users SET ... WHERE id = %s&quot;</span>, user_id, new_data)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 再删除缓存</span></span><br><span class="line">    redis.delete(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>问题：并发更新可能导致不一致</strong></p><p><img src="1873d601c2a84ae5880db7b618e8a520.png" alt="" /></p><h4 id="2-write-through模式直写"><a class="markdownIt-Anchor" href="#2-write-through模式直写"></a> 2. Write-Through模式（直写）</h4><p><strong>同步更新缓存和数据库</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WriteThroughCache</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, db_client</span>):</span><br><span class="line">        self.redis = redis_client</span><br><span class="line">        self.db = db_client</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self, key, value, expire=<span class="number">3600</span></span>):</span><br><span class="line">        <span class="comment"># 1. 先更新数据库</span></span><br><span class="line">        self.db.update_data(key, value)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 再更新缓存</span></span><br><span class="line">        self.redis.setex(key, expire, value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="comment"># 直接读缓存</span></span><br><span class="line">        <span class="keyword">return</span> self.redis.get(key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">cache = WriteThroughCache(redis, db)</span><br><span class="line">cache.<span class="built_in">set</span>(<span class="string">&quot;user:1001&quot;</span>, user_data)</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：保证强一致性<br /><strong>缺点</strong>：写性能较低，不适合高频写场景</p><h3 id="三-最终一致性方案"><a class="markdownIt-Anchor" href="#三-最终一致性方案"></a> 三、最终一致性方案</h3><h4 id="1-延迟双删策略"><a class="markdownIt-Anchor" href="#1-延迟双删策略"></a> 1. 延迟双删策略</h4><p><strong>解决并发冲突的方案</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_user_with_double_delete</span>(<span class="params">user_id, new_data</span>):</span><br><span class="line">    <span class="comment"># 第一次删除缓存</span></span><br><span class="line">    redis.delete(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新数据库</span></span><br><span class="line">    db.update(<span class="string">&quot;UPDATE users SET ... WHERE id = %s&quot;</span>, user_id, new_data)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 延迟第二次删除</span></span><br><span class="line">    threading.Timer(<span class="number">1.0</span>, <span class="keyword">lambda</span>: redis.delete(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>)).start()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_with_retry</span>(<span class="params">user_id, max_retries=<span class="number">3</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;带重试的查询&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> attempt <span class="keyword">in</span> <span class="built_in">range</span>(max_retries):</span><br><span class="line">        user_data = redis.get(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> user_data:</span><br><span class="line">            <span class="keyword">return</span> user_data</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 缓存不存在，查数据库</span></span><br><span class="line">        user_data = db.query(<span class="string">&quot;SELECT * FROM users WHERE id = %s&quot;</span>, user_id)</span><br><span class="line">        <span class="keyword">if</span> user_data:</span><br><span class="line">            <span class="comment"># 设置缓存</span></span><br><span class="line">            redis.setex(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>, <span class="number">3600</span>, user_data)</span><br><span class="line">            <span class="keyword">return</span> user_data</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 短暂等待后重试</span></span><br><span class="line">        time.sleep(<span class="number">0.1</span> * (<span class="number">2</span> ** attempt))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="2-基于消息队列的异步更新"><a class="markdownIt-Anchor" href="#2-基于消息队列的异步更新"></a> 2. 基于消息队列的异步更新</h4><p><strong>使用消息队列保证最终一致性</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheAsyncUpdater</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.producer = KafkaProducer(</span><br><span class="line">            bootstrap_servers=[<span class="string">&#x27;kafka1:9092&#x27;</span>, <span class="string">&#x27;kafka2:9092&#x27;</span>],</span><br><span class="line">            value_serializer=<span class="keyword">lambda</span> v: json.dumps(v).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_user</span>(<span class="params">self, user_id, new_data</span>):</span><br><span class="line">        <span class="comment"># 1. 只更新数据库</span></span><br><span class="line">        db.update(<span class="string">&quot;UPDATE users SET ... WHERE id = %s&quot;</span>, user_id, new_data)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 发送缓存更新消息</span></span><br><span class="line">        message = &#123;</span><br><span class="line">            <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;cache_update&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;key&#x27;</span>: <span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;data&#x27;</span>: new_data,</span><br><span class="line">            <span class="string">&#x27;timestamp&#x27;</span>: time.time()</span><br><span class="line">        &#125;</span><br><span class="line">        self.producer.send(<span class="string">&#x27;cache-updates&#x27;</span>, message)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者端</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cache_update_consumer</span>():</span><br><span class="line">    consumer = KafkaConsumer(</span><br><span class="line">        <span class="string">&#x27;cache-updates&#x27;</span>,</span><br><span class="line">        bootstrap_servers=[<span class="string">&#x27;kafka1:9092&#x27;</span>, <span class="string">&#x27;kafka2:9092&#x27;</span>],</span><br><span class="line">        value_deserializer=<span class="keyword">lambda</span> m: json.loads(m.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> message <span class="keyword">in</span> consumer:</span><br><span class="line">        data = message.value</span><br><span class="line">        <span class="keyword">if</span> data[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;cache_update&#x27;</span>:</span><br><span class="line">            <span class="comment"># 更新缓存</span></span><br><span class="line">            redis.setex(data[<span class="string">&#x27;key&#x27;</span>], <span class="number">3600</span>, data[<span class="string">&#x27;data&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="四-强一致性方案"><a class="markdownIt-Anchor" href="#四-强一致性方案"></a> 四、强一致性方案</h3><h4 id="1-分布式事务方案"><a class="markdownIt-Anchor" href="#1-分布式事务方案"></a> 1. 分布式事务方案</h4><p><strong>使用2PC实现强一致性</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DistributedTransaction</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, db_client</span>):</span><br><span class="line">        self.redis = redis_client</span><br><span class="line">        self.db = db_client</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_with_2pc</span>(<span class="params">self, key, new_data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;两阶段提交更新&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 阶段一：准备</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 数据库准备</span></span><br><span class="line">            db_transaction = self.db.begin_transaction()</span><br><span class="line">            db_transaction.update(<span class="string">&quot;UPDATE users SET ... WHERE id = %s&quot;</span>, key.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>], new_data)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Redis准备（设置临时状态）</span></span><br><span class="line">            self.redis.setex(<span class="string">f&quot;lock:<span class="subst">&#123;key&#125;</span>&quot;</span>, <span class="number">30</span>, <span class="string">&quot;prepared&quot;</span>)</span><br><span class="line">            self.redis.setex(<span class="string">f&quot;temp:<span class="subst">&#123;key&#125;</span>&quot;</span>, <span class="number">30</span>, new_data)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 阶段二：提交</span></span><br><span class="line">            db_transaction.commit()</span><br><span class="line">            self.redis.setex(key, <span class="number">3600</span>, new_data)</span><br><span class="line">            self.redis.delete(<span class="string">f&quot;lock:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">            self.redis.delete(<span class="string">f&quot;temp:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 回滚</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;db_transaction&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>():</span><br><span class="line">                db_transaction.rollback()</span><br><span class="line">            self.redis.delete(<span class="string">f&quot;lock:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">            self.redis.delete(<span class="string">f&quot;temp:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">raise</span> e</span><br></pre></td></tr></table></figure><h4 id="2-基于binlog的同步方案"><a class="markdownIt-Anchor" href="#2-基于binlog的同步方案"></a> 2. 基于binlog的同步方案</h4><p><strong>使用MySQL binlog同步缓存</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysqlreplication</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinlogSyncService</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client</span>):</span><br><span class="line">        self.redis = redis_client</span><br><span class="line">        self.setup_binlog_stream()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setup_binlog_stream</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;设置binlog监听&quot;&quot;&quot;</span></span><br><span class="line">        stream = pymysqlreplication.BinLogStreamReader(</span><br><span class="line">            connection_settings=&#123;</span><br><span class="line">                <span class="string">&#x27;host&#x27;</span>: <span class="string">&#x27;mysql-master&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;port&#x27;</span>: <span class="number">3306</span>,</span><br><span class="line">                <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;repl&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;passwd&#x27;</span>: <span class="string">&#x27;password&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            server_id=<span class="number">100</span>,</span><br><span class="line">            blocking=<span class="literal">True</span>,</span><br><span class="line">            resume_stream=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> binlogevent <span class="keyword">in</span> stream:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(binlogevent, WriteRowsEvent):</span><br><span class="line">                self.handle_write_event(binlogevent)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(binlogevent, UpdateRowsEvent):</span><br><span class="line">                self.handle_update_event(binlogevent)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(binlogevent, DeleteRowsEvent):</span><br><span class="line">                self.handle_delete_event(binlogevent)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_write_event</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理插入事件&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> event.rows:</span><br><span class="line">            <span class="keyword">if</span> event.table == <span class="string">&#x27;users&#x27;</span>:</span><br><span class="line">                user_id = row[<span class="string">&#x27;values&#x27;</span>][<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">                redis_key = <span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span></span><br><span class="line">                self.redis.setex(redis_key, <span class="number">3600</span>, json.dumps(row[<span class="string">&#x27;values&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_update_event</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理更新事件&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> event.rows:</span><br><span class="line">            <span class="keyword">if</span> event.table == <span class="string">&#x27;users&#x27;</span>:</span><br><span class="line">                user_id = row[<span class="string">&#x27;after_values&#x27;</span>][<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">                redis_key = <span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span></span><br><span class="line">                self.redis.setex(redis_key, <span class="number">3600</span>, json.dumps(row[<span class="string">&#x27;after_values&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_delete_event</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理删除事件&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> event.rows:</span><br><span class="line">            <span class="keyword">if</span> event.table == <span class="string">&#x27;users&#x27;</span>:</span><br><span class="line">                user_id = row[<span class="string">&#x27;values&#x27;</span>][<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">                redis_key = <span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span></span><br><span class="line">                self.redis.delete(redis_key)</span><br></pre></td></tr></table></figure><h3 id="五-读写分离场景的一致性"><a class="markdownIt-Anchor" href="#五-读写分离场景的一致性"></a> 五、读写分离场景的一致性</h3><h4 id="1-主从延迟问题"><a class="markdownIt-Anchor" href="#1-主从延迟问题"></a> 1. 主从延迟问题</h4><p><strong>解决主从延迟导致的脏读</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_with_read_after_write</span>(<span class="params">user_id, write_timestamp=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    读写分离环境下的一致性读取</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> write_timestamp:</span><br><span class="line">        <span class="comment"># 检查主从延迟</span></span><br><span class="line">        slave_lag = get_slave_lag()</span><br><span class="line">        <span class="keyword">if</span> time.time() - write_timestamp &amp;lt; slave_lag + <span class="number">1</span>:  <span class="comment"># 额外1秒缓冲</span></span><br><span class="line">            <span class="comment"># 强制读主库</span></span><br><span class="line">            <span class="keyword">return</span> read_from_master(user_id)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 先尝试读从库</span></span><br><span class="line">    user_data = read_from_slave(user_id)</span><br><span class="line">    <span class="keyword">if</span> user_data:</span><br><span class="line">        <span class="keyword">return</span> user_data</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从库没有，读主库</span></span><br><span class="line">    <span class="keyword">return</span> read_from_master(user_id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_from_master</span>(<span class="params">user_id</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从主库读取&quot;&quot;&quot;</span></span><br><span class="line">    user_data = db_master.query(<span class="string">&quot;SELECT * FROM users WHERE id = %s&quot;</span>, user_id)</span><br><span class="line">    <span class="keyword">if</span> user_data:</span><br><span class="line">        <span class="comment"># 更新缓存</span></span><br><span class="line">        redis.setex(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>, <span class="number">3600</span>, user_data)</span><br><span class="line">    <span class="keyword">return</span> user_data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_from_slave</span>(<span class="params">user_id</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从从库读取&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> db_slave.query(<span class="string">&quot;SELECT * FROM users WHERE id = %s&quot;</span>, user_id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_slave_lag</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取从库延迟&quot;&quot;&quot;</span></span><br><span class="line">    result = db_slave.query(<span class="string">&quot;SHOW SLAVE STATUS&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result[<span class="string">&#x27;Seconds_Behind_Master&#x27;</span>] <span class="keyword">if</span> result <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="六-监控与治理"><a class="markdownIt-Anchor" href="#六-监控与治理"></a> 六、监控与治理</h3><h4 id="1-一致性监控体系"><a class="markdownIt-Anchor" href="#1-一致性监控体系"></a> 1. 一致性监控体系</h4><p><strong>监控关键指标</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConsistencyMonitor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.metrics = &#123;</span><br><span class="line">            <span class="string">&#x27;cache_hits&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;cache_misses&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;stale_reads&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;consistency_errors&#x27;</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_consistency</span>(<span class="params">self, key, db_data, cache_data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查数据一致性&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> db_data != cache_data:</span><br><span class="line">            self.metrics[<span class="string">&#x27;consistency_errors&#x27;</span>] += <span class="number">1</span></span><br><span class="line">            self._repair_inconsistency(key, db_data)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_repair_inconsistency</span>(<span class="params">self, key, correct_data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;修复不一致数据&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            redis.setex(key, <span class="number">3600</span>, correct_data)</span><br><span class="line">            logging.warning(<span class="string">f&quot;Repaired inconsistency for key: <span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logging.error(<span class="string">f&quot;Failed to repair inconsistency: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">track_stale_read</span>(<span class="params">self, key, duration</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;跟踪过期数据读取&quot;&quot;&quot;</span></span><br><span class="line">        self.metrics[<span class="string">&#x27;stale_reads&#x27;</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> duration &amp;gt; <span class="number">5</span>:  <span class="comment"># 5秒以上的旧数据</span></span><br><span class="line">            send_alert(<span class="string">f&quot;Stale data detected: <span class="subst">&#123;key&#125;</span>&quot;</span>, <span class="string">f&quot;Duration: <span class="subst">&#123;duration&#125;</span>s&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_report</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;生成监控报告&quot;&quot;&quot;</span></span><br><span class="line">        total_requests = self.metrics[<span class="string">&#x27;cache_hits&#x27;</span>] + self.metrics[<span class="string">&#x27;cache_misses&#x27;</span>]</span><br><span class="line">        consistency_rate = <span class="number">1</span> - (self.metrics[<span class="string">&#x27;consistency_errors&#x27;</span>] / total_requests) <span class="keyword">if</span> total_requests &amp;gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;consistency_rate&#x27;</span>: <span class="string">f&quot;<span class="subst">&#123;consistency_rate:<span class="number">.3</span>%&#125;</span>&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;stale_reads&#x27;</span>: self.metrics[<span class="string">&#x27;stale_reads&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;total_requests&#x27;</span>: total_requests</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="2-自动修复机制"><a class="markdownIt-Anchor" href="#2-自动修复机制"></a> 2. 自动修复机制</h4><p><strong>不一致数据自动检测和修复</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoRepairService</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, db_client</span>):</span><br><span class="line">        self.redis = redis_client</span><br><span class="line">        self.db = db_client</span><br><span class="line">        self.repair_queue = queue.Queue()</span><br><span class="line">        self.start_workers()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_workers</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;启动修复工作线程&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):  <span class="comment"># 3个修复 worker</span></span><br><span class="line">            thread = threading.Thread(target=self._repair_worker)</span><br><span class="line">            thread.daemon = <span class="literal">True</span></span><br><span class="line">            thread.start()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_repair_worker</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;修复工作线程&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                key = self.repair_queue.get()</span><br><span class="line">                self._repair_key(key)</span><br><span class="line">                self.repair_queue.task_done()</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                logging.error(<span class="string">f&quot;Repair worker error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_repair_key</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;修复单个key&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 从数据库获取正确数据</span></span><br><span class="line">        <span class="keyword">if</span> key.startswith(<span class="string">&#x27;user:&#x27;</span>):</span><br><span class="line">            user_id = key.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">            db_data = self.db.query(<span class="string">&quot;SELECT * FROM users WHERE id = %s&quot;</span>, user_id)</span><br><span class="line">            <span class="keyword">if</span> db_data:</span><br><span class="line">                <span class="comment"># 更新缓存</span></span><br><span class="line">                self.redis.setex(key, <span class="number">3600</span>, db_data)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">schedule_repair</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;调度修复任务&quot;&quot;&quot;</span></span><br><span class="line">        self.repair_queue.put(key)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bulk_repair_check</span>(<span class="params">self, pattern=<span class="string">&quot;user:*&quot;</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;批量检查修复&quot;&quot;&quot;</span></span><br><span class="line">        cursor = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            cursor, keys = self.redis.scan(cursor, <span class="keyword">match</span>=pattern, count=<span class="number">100</span>)</span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">                self._verify_and_repair(key)</span><br><span class="line">            <span class="keyword">if</span> cursor == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_verify_and_repair</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;验证并修复数据&quot;&quot;&quot;</span></span><br><span class="line">        cache_data = self.redis.get(key)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cache_data:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取数据库数据对比</span></span><br><span class="line">        <span class="keyword">if</span> key.startswith(<span class="string">&#x27;user:&#x27;</span>):</span><br><span class="line">            user_id = key.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">            db_data = self.db.query(<span class="string">&quot;SELECT * FROM users WHERE id = %s&quot;</span>, user_id)</span><br><span class="line">            <span class="keyword">if</span> db_data != cache_data:</span><br><span class="line">                self.schedule_repair(key)</span><br></pre></td></tr></table></figure><h3 id="七-场景化解决方案"><a class="markdownIt-Anchor" href="#七-场景化解决方案"></a> 七、场景化解决方案</h3><h4 id="1-电商商品库存一致性"><a class="markdownIt-Anchor" href="#1-电商商品库存一致性"></a> 1. 电商商品库存一致性</h4><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InventoryService</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.redis = redis.Redis()</span><br><span class="line">        self.db = database.Connection()</span><br><span class="line">        self.lock = redis.Redis()  <span class="comment"># 用于分布式锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrease_stock</span>(<span class="params">self, product_id, quantity</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;减少库存（保证一致性）&quot;&quot;&quot;</span></span><br><span class="line">        lock_key = <span class="string">f&quot;lock:stock:<span class="subst">&#123;product_id&#125;</span>&quot;</span></span><br><span class="line">        cache_key = <span class="string">f&quot;stock:<span class="subst">&#123;product_id&#125;</span>&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取分布式锁</span></span><br><span class="line">        <span class="keyword">with</span> self._acquire_lock(lock_key):</span><br><span class="line">            <span class="comment"># 检查缓存库存</span></span><br><span class="line">            cache_stock = self.redis.get(cache_key)</span><br><span class="line">            <span class="keyword">if</span> cache_stock <span class="keyword">and</span> <span class="built_in">int</span>(cache_stock) &amp;lt; quantity:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&quot;库存不足&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新数据库</span></span><br><span class="line">            self.db.update(</span><br><span class="line">                <span class="string">&quot;UPDATE products SET stock = stock - %s WHERE id = %s AND stock &amp;gt;= %s&quot;</span>,</span><br><span class="line">                quantity, product_id, quantity</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新缓存</span></span><br><span class="line">            <span class="keyword">if</span> cache_stock:</span><br><span class="line">                new_stock = <span class="built_in">int</span>(cache_stock) - quantity</span><br><span class="line">                self.redis.setex(cache_key, <span class="number">3600</span>, <span class="built_in">str</span>(new_stock))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 缓存不存在，删除以确保下次从数据库加载</span></span><br><span class="line">                self.redis.delete(cache_key)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_stock</span>(<span class="params">self, product_id</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取库存信息&quot;&quot;&quot;</span></span><br><span class="line">        cache_key = <span class="string">f&quot;stock:<span class="subst">&#123;product_id&#125;</span>&quot;</span></span><br><span class="line">        stock = self.redis.get(cache_key)</span><br><span class="line">        <span class="keyword">if</span> stock:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(stock)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从数据库获取</span></span><br><span class="line">        stock = self.db.query(<span class="string">&quot;SELECT stock FROM products WHERE id = %s&quot;</span>, product_id)</span><br><span class="line">        <span class="keyword">if</span> stock <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.redis.setex(cache_key, <span class="number">3600</span>, <span class="built_in">str</span>(stock))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stock</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_acquire_lock</span>(<span class="params">self, lock_key, timeout=<span class="number">10</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取分布式锁&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 实现分布式锁逻辑</span></span><br><span class="line">        identifier = <span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">        end = time.time() + timeout</span><br><span class="line">        <span class="keyword">while</span> time.time() &amp;lt; end:</span><br><span class="line">            <span class="keyword">if</span> self.lock.<span class="built_in">set</span>(lock_key, identifier, nx=<span class="literal">True</span>, ex=<span class="number">5</span>):</span><br><span class="line">                <span class="keyword">return</span> identifier</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;获取锁超时&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-金融账户余额一致性"><a class="markdownIt-Anchor" href="#2-金融账户余额一致性"></a> 2. 金融账户余额一致性</h4><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountService</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.redis = redis.Redis()</span><br><span class="line">        self.db = database.Connection()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transfer</span>(<span class="params">self, from_account, to_account, amount</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;转账操作（强一致性要求）&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用数据库事务保证一致性</span></span><br><span class="line">        <span class="keyword">with</span> self.db.transaction():</span><br><span class="line">            <span class="comment"># 更新数据库</span></span><br><span class="line">            self.db.update(</span><br><span class="line">                <span class="string">&quot;UPDATE accounts SET balance = balance - %s WHERE id = %s AND balance &amp;gt;= %s&quot;</span>,</span><br><span class="line">                amount, from_account, amount</span><br><span class="line">            )</span><br><span class="line">            self.db.update(</span><br><span class="line">                <span class="string">&quot;UPDATE accounts SET balance = balance + %s WHERE id = %s&quot;</span>,</span><br><span class="line">                amount, to_account</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 删除相关缓存</span></span><br><span class="line">            self.redis.delete(<span class="string">f&quot;account:<span class="subst">&#123;from_account&#125;</span>&quot;</span>)</span><br><span class="line">            self.redis.delete(<span class="string">f&quot;account:<span class="subst">&#123;to_account&#125;</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 记录交易日志</span></span><br><span class="line">            self._log_transaction(from_account, to_account, amount)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_balance</span>(<span class="params">self, account_id</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取余额（最终一致性）&quot;&quot;&quot;</span></span><br><span class="line">        cache_key = <span class="string">f&quot;account:<span class="subst">&#123;account_id&#125;</span>&quot;</span></span><br><span class="line">        balance = self.redis.get(cache_key)</span><br><span class="line">        <span class="keyword">if</span> balance:</span><br><span class="line">            <span class="keyword">return</span> decimal.Decimal(balance)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从数据库获取</span></span><br><span class="line">        balance = self.db.query(<span class="string">&quot;SELECT balance FROM accounts WHERE id = %s&quot;</span>, account_id)</span><br><span class="line">        <span class="keyword">if</span> balance <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 异步更新缓存</span></span><br><span class="line">            threading.Thread(</span><br><span class="line">                target=self.redis.setex,</span><br><span class="line">                args=(cache_key, <span class="number">300</span>, <span class="built_in">str</span>(balance))</span><br><span class="line">            ).start()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> balance</span><br></pre></td></tr></table></figure><h3 id="八-总结与最佳实践"><a class="markdownIt-Anchor" href="#八-总结与最佳实践"></a> 八、总结与最佳实践</h3><h4 id="一致性方案选择指南"><a class="markdownIt-Anchor" href="#一致性方案选择指南"></a> 一致性方案选择指南</h4><p><img src="db541323ce40494a994076ba3cd5de0c.png" alt="" /></p><h4 id="最佳实践-checklist"><a class="markdownIt-Anchor" href="#最佳实践-checklist"></a> 最佳实践 checklist ✅</h4><p><strong>设计阶段</strong>：</p><ul><li><p>明确业务的一致性要求</p></li><li><p>选择合适的一致性级别</p></li><li><p>设计缓存更新策略</p></li><li><p>规划监控和修复机制</p></li></ul><p><strong>开发阶段</strong>：</p><ul><li><p>实现适当的重试机制</p></li><li><p>添加分布式锁避免并发冲突</p></li><li><p>设置合理的超时时间</p></li><li><p>实现数据验证和修复</p></li></ul><p><strong>运维阶段</strong>：</p><ul><li><p>监控缓存命中率和一致性</p></li><li><p>设置告警机制</p></li><li><p>定期进行一致性检查</p></li><li><p>准备应急预案</p></li></ul><h4 id="关键建议"><a class="markdownIt-Anchor" href="#关键建议"></a> 关键建议 🚀</h4><ol><li><p><strong>不要过度设计</strong>：根据业务需求选择适当的一致性级别</p></li><li><p><strong>监控重于预防</strong>：建立完善的监控体系比追求完美方案更重要</p></li><li><p><strong>设计容错机制</strong>：假设不一致会发生，准备好修复方案</p></li><li><p><strong>持续优化改进</strong>：根据监控数据不断调整和优化策略</p></li></ol><p>通过本文的详细分析和实践方案，你应该能够根据业务需求选择合适的缓存一致性方案，并构建出可靠的数据同步体系。记住：一致性是一个持续的过程，而不是一次性的解决方案！</p>]]></content>
    
    
    <summary type="html">【Redis缓存一致性：如何保证数据库与缓存同步】</summary>
    
    
    
    <category term="数据库" scheme="http://www.formeasy.cc/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="http://www.formeasy.cc/tags/Redis/"/>
    
  </entry>
  
</feed>
