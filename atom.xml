<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>易锦风的博客</title>
  
  <subtitle>专注互联网和软件技术</subtitle>
  <link href="http://www.formeasy.cc/atom.xml" rel="self"/>
  
  <link href="http://www.formeasy.cc/"/>
  <updated>2025-10-30T02:08:51.630Z</updated>
  <id>http://www.formeasy.cc/</id>
  
  <author>
    <name>formeasy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【UE5 C++】C++代码调用蓝图方法或事件</title>
    <link href="http://www.formeasy.cc/2025/10/30/UE/%E3%80%90UE5%20C++%E3%80%91C++%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E8%93%9D%E5%9B%BE%E6%96%B9%E6%B3%95%E6%88%96%E4%BA%8B%E4%BB%B6/"/>
    <id>http://www.formeasy.cc/2025/10/30/UE/%E3%80%90UE5%20C++%E3%80%91C++%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E8%93%9D%E5%9B%BE%E6%96%B9%E6%B3%95%E6%88%96%E4%BA%8B%E4%BB%B6/</id>
    <published>2025-10-30T02:04:30.000Z</published>
    <updated>2025-10-30T02:08:51.630Z</updated>
    
    <content type="html"><![CDATA[<p>此方法为：先创建C++类MyTest，再以MyTest类为父类创建蓝图；在其他类中，可以通过MyTest调用蓝图对应方法。</p><h3 id="1创建c代码"><a class="markdownIt-Anchor" href="#1创建c代码"></a> 1.创建c++代码</h3><p>通过UE创建继承自Actor的C++代码<br /><img src="842ec38aa1ab8e1241a3f3efa326a638.png" alt="" /><br /><img src="e1e55aac2ae7facd8cf7e6be598afe08.png" alt="" /></p><h3 id="2添加可以在ue中重写方法的说明"><a class="markdownIt-Anchor" href="#2添加可以在ue中重写方法的说明"></a> 2.添加可以在UE中重写方法的说明</h3><p>需使用声明：UFUNCTION(BlueprintNativeEvent, BlueprintCallable)</p><p>BlueprintNativeEvent表示在 c++ 中定义事件，可以在UE中实现，c++ 中必须实现。<br />如果UE中实现了，则覆盖c++中逻辑。</p><p>BlueprintCallable 表示可以在蓝图中调用。</p><p>完整代码 .h文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//添加可以在UE中重写方法</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintNativeEvent, BlueprintCallable)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Play</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Play_Implementation</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure><p>.cpp文件增加方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyTest::Play_Implementation</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中.h文件的 virtual void Play_Implementation();可以不写，写是为了方便实用快捷键创建.cpp中的实现。</p><p>.cpp文件中必须实现Play_Implementation。<br />后缀为官方定义的不可更改。不然.h中的Play()会报错。</p><p><strong>注：可以填参数int32，<sub>但我测试FString类型无法添加</sub> 。 传递FString类型 要使用：const FString&amp; str</strong></p><p><strong>注：增加了此代码后，需要重写通过编辑器编译进入UE，不然可能不会出现步骤2中的可选事件</strong></p><h3 id="2创建蓝图类"><a class="markdownIt-Anchor" href="#2创建蓝图类"></a> 2.创建蓝图类</h3><p>以MyTest为末班，创建蓝图类。<br /><img src="23756da69ec24a09064e03a32e4c397e.png" alt="" /><br />打开蓝图类，鼠标移动到左侧FUNCTIONS菜单上，可以出现下拉菜单，可以发现刚才出现了刚才定义的Play。<br /><img src="61a50015e339b8dfff83af7e3f09f0d7.png" alt="" /><br />点击Play，可以发现生成了一个事件。<br />可以对其进行连线，以便进一步在C++中调用。<br /><img src="c8a1f2f6699008c28efd718fa868f67c.png" alt="" /></p><h3 id="3调用测试"><a class="markdownIt-Anchor" href="#3调用测试"></a> 3.调用测试</h3><p>到此，只要获取到该蓝图的Actor，Cast获取MyTest，即可调用声明的Play方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AMyTest* myTestActor = <span class="built_in">Cast</span>&lt;AMyTest&gt;(Actor);</span><br><span class="line"><span class="keyword">if</span>(myTestActor)</span><br><span class="line">&#123;</span><br><span class="line">myTestActor-&gt;<span class="built_in">Play</span>(<span class="number">99</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：Actor为创建出来的蓝图对象，自行获取</strong></p>]]></content>
    
    
    <summary type="html">【UE5 C++】C++代码调用蓝图方法或事件</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>UE5 蓝图调用C++函数方式</title>
    <link href="http://www.formeasy.cc/2025/10/30/UE/UE5%20%E8%93%9D%E5%9B%BE%E8%B0%83%E7%94%A8C++%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.formeasy.cc/2025/10/30/UE/UE5%20%E8%93%9D%E5%9B%BE%E8%B0%83%E7%94%A8C++%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F/</id>
    <published>2025-10-30T01:04:11.000Z</published>
    <updated>2025-10-30T02:09:25.248Z</updated>
    
    <content type="html"><![CDATA[<p>本文要记录两种方式蓝图调用C++函数：</p><h2 id="一-蓝图调用actor类的函数"><a class="markdownIt-Anchor" href="#一-蓝图调用actor类的函数"></a> 一、蓝图调用Actor类的函数</h2><h3 id="11-创建一个基于actor类"><a class="markdownIt-Anchor" href="#11-创建一个基于actor类"></a> 1.1 创建一个基于Actor类：</h3><p><img src="wechat_2025-10-30_085751_471.png" alt="" /></p><p><img src="wechat_2025-10-30_085844_432.png" alt="" /></p><h3 id="12-创建后内容浏览器中添加c类并自动打开vs"><a class="markdownIt-Anchor" href="#12-创建后内容浏览器中添加c类并自动打开vs"></a> 1.2 创建后，内容浏览器中添加C++类，并自动打开VS</h3><p>在新建的类下添加如下代码：</p><p>代码的方法为获取本机IP</p><p>.h</p><p><img src="wechat_2025-10-30_090020_363.png" alt="" /></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyActor.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C_MP_LOBBY_API</span> AMyActor : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Sets default values for this actor&#x27;s properties</span></span><br><span class="line"><span class="built_in">AMyActor</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function">FString <span class="title">ShowIP</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>.cpp</p><p><img src="wechat_2025-10-30_090342_384.png" alt="" /></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyActor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/AllowWindowsPlatformTypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/PreWindowsApi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/GameEngine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/PostWindowsApi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/HideWindowsPlatformTypes.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AMyActor::<span class="built_in">AMyActor</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyActor::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyActor::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FString <span class="title">AMyActor::ShowIP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WSADATA Wsadata;</span><br><span class="line"><span class="type">char</span> name[<span class="number">255</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">0</span>), &amp;Wsadata))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gethostname</span>(name, <span class="built_in">sizeof</span>(name)))</span><br><span class="line">&#123;</span><br><span class="line">hostent* host = <span class="built_in">gethostbyname</span>(name);</span><br><span class="line"><span class="keyword">if</span> (host != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">FString a = <span class="built_in">inet_ntoa</span>(*(<span class="keyword">struct</span> in_addr*)*host-&gt;h_addr_list);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">TEXT</span>(<span class="string">&quot;%s&quot;</span>), a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">TEXT</span>(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-编写代码后进行编译"><a class="markdownIt-Anchor" href="#14-编写代码后进行编译"></a> 1.4 编写代码后，进行编译</h3><h3 id="15-调用actor类的两种方法"><a class="markdownIt-Anchor" href="#15-调用actor类的两种方法"></a> 1.5 调用Actor类的两种方法</h3><h4 id="1-关卡蓝图中调用"><a class="markdownIt-Anchor" href="#1-关卡蓝图中调用"></a> 1) 关卡蓝图中调用</h4><p>将创建的c++类拖拽到场景中，世界大纲便会出现此Actor</p><p><img src="wechat_2025-10-30_092639_415.png" alt="" /></p><p>打开关卡蓝图，获到Actor类，并调用Show IP函数，如下：</p><p><img src="wechat_2025-10-30_093009_086.png" alt="" /></p><h4 id="2-创建蓝图类并调用"><a class="markdownIt-Anchor" href="#2-创建蓝图类并调用"></a> 2) 创建蓝图类并调用</h4><p>创建一个蓝图类（在内容浏览器右键），选取父类为当前的c++Actor类</p><p><img src="wechat_2025-10-30_093351_427.png" alt="" /></p><p>起名比如BP_Actor,双击打开，编写如下：</p><p><img src="wechat_2025-10-30_093730_788.png" alt="" /></p><p>效果同上</p><h2 id="二-蓝图调用蓝图函数库"><a class="markdownIt-Anchor" href="#二-蓝图调用蓝图函数库"></a> 二、蓝图调用蓝图函数库</h2><p><strong>注意：此方法创建出的子类中的方法必须为静态！</strong></p><h3 id="21-创建一个基于蓝图函数库"><a class="markdownIt-Anchor" href="#21-创建一个基于蓝图函数库"></a> 2.1 创建一个基于蓝图函数库：</h3><p><img src="wechat_2025-10-30_094508_149.png" alt="" /></p><p><img src="wechat_2025-10-30_094701_710.png" alt="" /></p><h3 id="22-创建后内容浏览器中创建了蓝图函数库c类并自动打开vs"><a class="markdownIt-Anchor" href="#22-创建后内容浏览器中创建了蓝图函数库c类并自动打开vs"></a> 2.2 创建后，内容浏览器中创建了蓝图函数库C++类，并自动打开VS</h3><p>编写代码</p><p><strong>注意：函数声明前需加static</strong></p><p>.h代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kismet/BlueprintFunctionLibrary.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyBlueprintFunctionLibrary.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C_MP_LOBBY_API</span> UMyBlueprintFunctionLibrary : <span class="keyword">public</span> UBlueprintFunctionLibrary</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line"><span class="function"><span class="type">static</span> FString <span class="title">ShowIP</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>.cpp代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyBlueprintFunctionLibrary.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/AllowWindowsPlatformTypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/PreWindowsApi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/GameEngine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/PostWindowsApi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows/HideWindowsPlatformTypes.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FString <span class="title">UMyBlueprintFunctionLibrary::ShowIP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WSADATA Wsadata;</span><br><span class="line"><span class="type">char</span> name[<span class="number">255</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">0</span>), &amp;Wsadata))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gethostname</span>(name, <span class="built_in">sizeof</span>(name)))</span><br><span class="line">&#123;</span><br><span class="line">hostent* host = <span class="built_in">gethostbyname</span>(name);</span><br><span class="line"><span class="keyword">if</span> (host != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">FString a = <span class="built_in">inet_ntoa</span>(*(<span class="keyword">struct</span> in_addr*)*host-&gt;h_addr_list);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">TEXT</span>(<span class="string">&quot;%s&quot;</span>), a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">TEXT</span>(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写后进行编译</p><h3 id="23-使用蓝图函数库c类"><a class="markdownIt-Anchor" href="#23-使用蓝图函数库c类"></a> 2.3 使用蓝图函数库C++类</h3><p>这种方法使用函数比较简单，因为蓝图函数库是全局的，只要在蓝图中直接引用函数即可</p><p><img src="wechat_2025-10-30_100209_911.png" alt="" /></p>]]></content>
    
    
    <summary type="html">UE5 蓝图调用C++函数方式</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>UE给场景添加VR组件进行虚拟漫游</title>
    <link href="http://www.formeasy.cc/2025/10/27/UE/UE%E7%BB%99%E5%9C%BA%E6%99%AF%E6%B7%BB%E5%8A%A0VR%E7%BB%84%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%99%9A%E6%8B%9F%E6%BC%AB%E6%B8%B8/"/>
    <id>http://www.formeasy.cc/2025/10/27/UE/UE%E7%BB%99%E5%9C%BA%E6%99%AF%E6%B7%BB%E5%8A%A0VR%E7%BB%84%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%99%9A%E6%8B%9F%E6%BC%AB%E6%B8%B8/</id>
    <published>2025-10-27T07:34:47.000Z</published>
    <updated>2025-10-29T07:02:05.188Z</updated>
    
    <content type="html"><![CDATA[<p>将ue5工程，添加VR组件进行虚拟漫游，步骤如下；</p><h3 id="1添加vr虚拟现实库"><a class="markdownIt-Anchor" href="#1添加vr虚拟现实库"></a> 1.添加VR虚拟现实库</h3><p><img src="wechat_2025-10-27_152843_721.png" alt="" /></p><p><img src="wechat_2025-10-27_152940_712.png" alt="" /></p><p>添加后，内容浏览器中会多出VRSpectator和VRTemplate两个目录</p><p>另外，确认插件是否启用了openxr插件。</p><h3 id="2添加vr摄像头vrpawn"><a class="markdownIt-Anchor" href="#2添加vr摄像头vrpawn"></a> 2.添加VR摄像头（VRPawn）</h3><p><img src="wechat_2025-10-27_153112_253.png" alt="" /></p><p>将VRTemplate目录的Blueprints目录下中VRPawn拖到场景中，并调整位置。</p><h3 id="3项目设置中以vr启动"><a class="markdownIt-Anchor" href="#3项目设置中以vr启动"></a> 3.项目设置中以VR启动</h3><p><img src="wechat_2025-10-27_153207_454.png" alt="" /></p><h3 id="4安装并打开steamvr软件进行设置"><a class="markdownIt-Anchor" href="#4安装并打开steamvr软件进行设置"></a> 4.安装并打开SteamVR软件进行设置</h3><ul><li>启动SteamVR桌面客户端</li><li>打开 设置 -&gt; 开发者</li><li>查看“当前 OpenXR Runtime“状态</li><li>若不是 SteamVR，点击【设置为OpenXR Runtime】</li></ul><p>最后，UE5启动时，以VR预览的方式启动即可。</p><p>参考资料：<a href="https://www.bilibili.com/video/BV1yM4y177dv/?vd_source=16559409b3ad61518421a045daa8639d">https://www.bilibili.com/video/BV1yM4y177dv/?vd_source=16559409b3ad61518421a045daa8639d</a></p>]]></content>
    
    
    <summary type="html">UE给场景添加VR组件进行虚拟漫游</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>UE场景光照变桔黄Nanite缺失项目设置问题</title>
    <link href="http://www.formeasy.cc/2025/10/27/UE/UE%E5%9C%BA%E6%99%AF%E5%85%89%E7%85%A7%E5%8F%98%E6%A1%94%E9%BB%84Nanite%E7%BC%BA%E5%A4%B1%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://www.formeasy.cc/2025/10/27/UE/UE%E5%9C%BA%E6%99%AF%E5%85%89%E7%85%A7%E5%8F%98%E6%A1%94%E9%BB%84Nanite%E7%BC%BA%E5%A4%B1%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/</id>
    <published>2025-10-27T06:22:08.000Z</published>
    <updated>2025-10-27T06:28:16.188Z</updated>
    
    <content type="html"><![CDATA[<p>今天新建虚幻引擎项目时 , 编辑器右下角收到这个提示 ,<br /><img src="95a2b49c35b24dcfafde349d94c2b860.png" alt="" /></p><blockquote><p>缺失项目设置！ 使用Nanite资产需要Shader Model 6（SM6）。请在此启用： 项目设置-&gt; 平台-&gt;<br />Windows-&gt;D3D12目标着色器格式如未启用，Nanite资产将无法正常显示。</p></blockquote><p>并且打开场景时，场景光照变桔黄：<br /><img src="wechat_2025-10-27_142115_580.png" alt="" /></p><p>如何解决呢? 很简单</p><p>编辑 - 项目设置 - 平台 - Windows<br />D3D12 Targeted Shader Formats <code>开启 SM6</code><br />目标RHI 设置成 <code>DirectX 12</code><br /><img src="e6ffae4d7323433f8ad7a61ace8c635d.png" alt="" /></p><p>那么用UE5做游戏到底要不要开Nanite?<br />还是那句话 , 能开尽量开 , 官方也推荐开</p><p>应该将Nanite用于哪些类型的网格体？<br /><code>一般来说，能启用时应该尽量启用Nanite</code>。启用了Nanite的静态网格体通常可以更快地渲染，占用的内存和磁盘空间会更少。</p><p>具体来说，如果网格体满足以下条件，则尤其适合使用Nanite：</p><p>包含很多三角形，或屏幕上三角形非常小<br />场景中有很多实例<br />是其他Nanite几何体的主要遮挡物<br />使用虚拟阴影贴图投射阴影<br />不过有一个例外，那就是天空球之类的对象：它的三角形在屏幕上显得很大，不会遮挡任何东西，并且场景中只有一个。通常，这种例外很少见，并且让它们启用Nanite导致的性能损失很小，所以只要Nanite支持，就不必过度担心是否应该不开启Nanite。</p><p>官方文档原话:<br /><img src="122b3461b2e246c6a48f5c7c5d613961.png" alt="" /></p><p>Nanite支持的平台<br />Nanite目前支持PlayStation 5、Xbox Series S|X、以及符合以下显卡要求的PC（需要使用最新显卡驱动并<code>支持DirectX 12</code>）：<br />● NVIDIA：Maxwell显卡或更新版本的显卡<br />● AMD：GCN显卡或更新版本的显卡<br />● 凡是支持DirectX 12 Agility SDK的较新版Windows 10（高于版本1909.1350）和Windows 11都受支持。<br />○ Windows 10版本<code>1909</code> — 修订版号应该超过或等于.1350。<br />○ Windows 10版本2004和20H2 — 修订版号应该超过或等于.789。<br />○ DirectX 12（带着色器模型6.6原子），或Vulkan（VK_KHR_shader_atomic_int64）<br />● <code>最新显卡驱动程序</code></p><p>数据大小<br />Nanite能够实现<code>大量微观细节</code>，这可能会让人认为几何体数据会大量增加，导致玩家的游戏包大小和下载数据增加。然而，现实并没有那么可怕。事实上，Nanite的网格体格式要比标准的静态网格体格式小得多，因为Nanite有专门的网格体编码格式。</p><p>例如，对虚幻引擎5示例《古代山谷》来说，平均而言，Nanite网格体的每个输入三角形会消耗14.4字节。这意味着平均一个拥有100万三角形的Nanite网格体，在磁盘上需要约13.8兆字节（MB）。</p>]]></content>
    
    
    <summary type="html">UE场景光照变桔黄Nanite缺失项目设置问题</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>UE5 局域网联机，寻找会话失败</title>
    <link href="http://www.formeasy.cc/2025/10/27/UE/UE5%20%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%EF%BC%8C%E5%AF%BB%E6%89%BE%E4%BC%9A%E8%AF%9D%E5%A4%B1%E8%B4%A5/"/>
    <id>http://www.formeasy.cc/2025/10/27/UE/UE5%20%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%EF%BC%8C%E5%AF%BB%E6%89%BE%E4%BC%9A%E8%AF%9D%E5%A4%B1%E8%B4%A5/</id>
    <published>2025-10-27T05:34:25.000Z</published>
    <updated>2025-10-27T05:50:50.777Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1关闭防火墙"><a class="markdownIt-Anchor" href="#1关闭防火墙"></a> 1.关闭防火墙</h3><h3 id="2在项目名buildcs脚本中添加该行添加后关闭编辑器重新生成解决方案"><a class="markdownIt-Anchor" href="#2在项目名buildcs脚本中添加该行添加后关闭编辑器重新生成解决方案"></a> 2.在【项目名.Build.cs】脚本中添加该行，添加后关闭编辑器，重新生成解决方案。</h3><p><img src="9cf42465ce02c20396dcaa295ba0e67f.png" alt="" /></p><h3 id="3检查是否在同一个c类子网"><a class="markdownIt-Anchor" href="#3检查是否在同一个c类子网"></a> 3.检查是否在同一个C类子网</h3><p>一般是存在多块网卡（安装虚拟机）或是启用了Hyper-V，先禁用网卡或关闭Hyper-V。</p><ul><li>安装VMware会自动添加VMware Network Adapter VMnet1和VMware Network Adapter VMnet8网卡。</li><li>安装VirtualBox会自动添加VirtualBox Host-Only Ethernet Adapter网卡。</li><li>安装Hyper-V会自动添加Hyper-V Virtual Ethernet Adapter网卡。</li></ul><p>详细参考 <a href="https://forums.unrealengine.com/t/cant-find-session-in-lan/375836/12">https://forums.unrealengine.com/t/cant-find-session-in-lan/375836/12</a></p><hr /><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料：</h3><p>1.<a href="https://forums.unrealengine.com/t/cant-find-session-in-lan/375836/12" title="Can't find session in LAN - Programming &amp; Scripting / Multiplayer &amp; Networking - Epic Developer Community Forums (unrealengine.com)">Can’t find session in LAN - Programming &amp; Scripting / Multiplayer &amp; Networking - Epic Developer Community Forums (unrealengine.com)</a><br /><img src="ea00e43c0f9ba10a684359889e548414.png" alt="" /></p><p>2.<a href="https://unreal.gg-labs.com/wiki-archives/networking/how-to-use-sessions-in-c++" title="How To Use Sessions In C++ | 4.24 | UE4: Guidebook (gg-labs.com)">How To Use Sessions In C++ | 4.24 | UE4: Guidebook (gg-labs.com)</a><br /><img src="64f1144736af2c94b25ea0e28cba648d.png" alt="" /></p><p>3.<a href="https://www.reddit.com/r/unrealengine/comments/11a2s4s/lyra_session_browser_cannot_find_sessions_lan_wifi/" title="Lyra - 会话浏览器找不到会话 （LAN WIFI） ： r/unrealengine (reddit.com)">Lyra - 会话浏览器找不到会话 （LAN WIFI） ： r/unrealengine (reddit.com)</a><br /><img src="e8fcd78fd791909404d93d88d1cc1f6d.png" alt="" /></p><h3 id="尝试解决办法"><a class="markdownIt-Anchor" href="#尝试解决办法"></a> 尝试解决办法</h3><p>全部都做一遍，其中可能有若干个步骤多余。</p>]]></content>
    
    
    <summary type="html">UE5 局域网联机，寻找会话失败</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>UE Gameplay 框架总结</title>
    <link href="http://www.formeasy.cc/2025/10/27/UE/UE%20Gameplay%20%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://www.formeasy.cc/2025/10/27/UE/UE%20Gameplay%20%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</id>
    <published>2025-10-27T00:37:47.000Z</published>
    <updated>2025-10-27T00:48:19.039Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了游戏开发中几个重要的概念：GameInstance用于保存临时全局数据，GameMode管理游戏规则和类信息，DefaultPawn提供基础操作，PlayerController连接客户端与服务器，以及GameState和PlayerState负责全局数据管理和玩家状态同步。</p><h2 id="各个模块"><a class="markdownIt-Anchor" href="#各个模块"></a> 各个模块</h2><h3 id="gameinstance游戏实例"><a class="markdownIt-Anchor" href="#gameinstance游戏实例"></a> <strong>GameInstance（<strong>游戏实例</strong>）</strong></h3><blockquote><ul><li>实例里的数据不会随着关卡的切换而消失。</li><li>作用是为游戏保存临时的全局数据（并不是所有的全局变量都存在<strong>GameInstance</strong>中，如玩家的信息应该存在<strong>PlayerState</strong>，游戏的一些信息存在<strong>GameState</strong>），或者自定义需要在全局使用的逻辑（慎重，<strong>GameInstance</strong> 的臃肿会导致卡顿）。</li><li>通常情况下一个Game中应该只有一个<strong>GameInstance</strong>(UE也是提供了多个GameInstance协同的扩展的，但是一次Game只能有一个GameInstance生效)</li><li>GameInstance的生命周期就是从游戏进程启动到游戏进程结束</li></ul></blockquote><h4 id="gameinstance主要处理"><a class="markdownIt-Anchor" href="#gameinstance主要处理"></a> <strong>GameInstance主要处理：</strong></h4><blockquote><ul><li>UWorld、ULevel之间的切换</li><li>全局配置</li><li>GameMode的切换</li></ul></blockquote><h3 id="gamemode-游戏规则"><a class="markdownIt-Anchor" href="#gamemode-游戏规则"></a> <strong>GameMode</strong> （游戏规则）</h3><blockquote><ul><li>仅在当前Level生效，一个Level一次只能对应一个GameMode，但是一个GameMode可以用在多个Level中</li><li>仅存在服务器中，客户端没有</li></ul></blockquote><h4 id="gamemode主要处理"><a class="markdownIt-Anchor" href="#gamemode主要处理"></a> <strong>GameMode</strong>主要处理：</h4><blockquote><ul><li>Class登记：记录GameMode中各种类的信息</li><li>Spawn：创建Pawn和PlayerController等</li><li>游戏进度：游戏暂停重启的逻辑</li><li>过场动画逻辑</li><li>多人游戏的步调同步</li></ul></blockquote><h2 id="defaultpawn-默认pawn"><a class="markdownIt-Anchor" href="#defaultpawn-默认pawn"></a> <strong>DefaultPawn</strong> （默认Pawn）</h2><blockquote><ul><li>自带DefualtPawnMovement、CollisionComponent、StaticMeshCompnent三件套（Pawn没有这些，Pawn提供了接口没有具体实现）</li><li>服务端和客户端都存在一份，同时保持同步。</li><li>在 GameMode 中修改。</li></ul></blockquote><h4 id="defaultpawn主要处理"><a class="markdownIt-Anchor" href="#defaultpawn主要处理"></a> <strong>DefaultPawn主要处理：</strong></h4><blockquote><ul><li>提供基础的操作，保证Game运行</li></ul></blockquote><h3 id="hud"><a class="markdownIt-Anchor" href="#hud"></a> <strong>HUD</strong></h3><blockquote><ul><li>实现一些简单的界面元素（文本，点），复杂的要使用UMG，但是HUD开销更小</li><li>只存在于客户端</li></ul></blockquote><h3 id="playercontroller"><a class="markdownIt-Anchor" href="#playercontroller"></a> <strong>PlayerController</strong></h3><blockquote><ul><li>拥有 Pawn 并设置其行为规则</li><li>服务器上拥有所有玩家的PlayerController，而本地客户端则只有当前玩家的 PlayerController 。</li><li>关联了客户端和服务端，通过该类，客户端可以向服务端发送请求</li></ul></blockquote><h4 id="playercontroller-主要处理"><a class="markdownIt-Anchor" href="#playercontroller-主要处理"></a> <strong>PlayerController</strong> 主要处理：</h4><blockquote><ul><li>Camera管理</li><li>Input输入响应</li><li>UPlayer关联</li><li>HUD显示</li><li>Level切换</li><li>Voice音源监听</li></ul></blockquote><h3 id="gamestate"><a class="markdownIt-Anchor" href="#gamestate"></a> <strong>GameState</strong></h3><blockquote><ul><li>数据的全局管理（用于存储游戏相关数据）</li><li>服务端和客户端都存在一份，它包含要复制到游戏中的每个客户端的信息</li><li>通常用来保持数据的同步，也可将其中的部分数据设置为不同步。</li></ul></blockquote><h4 id="gamestate主要处理"><a class="markdownIt-Anchor" href="#gamestate主要处理"></a> <strong>GameState主要处理：</strong></h4><blockquote><ul><li>保存游戏数据，如任务进度，游戏活动等。</li></ul></blockquote><h3 id="playerstate"><a class="markdownIt-Anchor" href="#playerstate"></a> <strong>PlayerState</strong></h3><blockquote><ul><li>数据的全局管理（用于存储角色相关数据）</li><li>该类需要通过 PlayerController 来访问</li><li>所有玩家的 PlayerState存在于所有机器上（与 PlayerController 不同），并且可以将数据从服务器复制到客户端以保持同步</li><li>PlayerState的生命周期为一整个Level的生命周期</li></ul></blockquote><h4 id="playerstate-主要处理"><a class="markdownIt-Anchor" href="#playerstate-主要处理"></a> <strong>PlayerState</strong> 主要处理：</h4><blockquote><ul><li>保存玩家数据，客户端可以存在多个PlayerState对象，不同的PlayerState保存不同玩家的状态</li></ul></blockquote>]]></content>
    
    
    <summary type="html">UE Gameplay 框架总结</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="UE" scheme="http://www.formeasy.cc/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL5.6-5.7-8.0版本授权用户远程连接</title>
    <link href="http://www.formeasy.cc/2025/10/24/MySQL/MySQL5.6-5.7-8.0%E7%89%88%E6%9C%AC%E6%8E%88%E6%9D%83%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    <id>http://www.formeasy.cc/2025/10/24/MySQL/MySQL5.6-5.7-8.0%E7%89%88%E6%9C%AC%E6%8E%88%E6%9D%83%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</id>
    <published>2025-10-24T13:42:07.000Z</published>
    <updated>2025-10-24T13:51:35.032Z</updated>
    
    <content type="html"><![CDATA[<p><strong>修改配置文件</strong><br />找到 MySQL 的配置文件 my.cnf(或 my.ini),通常位于 /etc/mysql/ 或者 /etc/my.cnf，使用文本编辑器打开文件，找到 [mysqld] 部分，添加如下内容：</p><p>bind-address = 0.0.0.0<br />这将允许所有 IP 地址的连接，如果你想限制只允许特定 IP 地址连接，可以将 0.0.0.0 替换为特定的 IP 地址。</p><p><strong>MySQL5.6版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span> WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p><strong>MySQL5.7版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p><strong>MySQL8.0版本</strong></p><p>因默认认证插件和权限限制，需多一步 “调整认证方式” 或 “分步骤授权”。<br />MySQL 8 不允许 “创建用户” 和 “授权” 在一条 SQL 中完成，需分开执行：</p><p>1）创建用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;CREATE USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure><p>2）授权示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p>3）修改远程连接用户的加密规则<br />由于 MySQL 8 默认的 caching_sha2_password 插件，部分旧客户端（如 Navicat 11 及以下）不支持，需改为传统插件兼容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure><p>4）刷新权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;flush privileges;</span><br></pre></td></tr></table></figure><p><strong>开放服务器端口</strong><br />所有版本需开放 3306 端口。</p>]]></content>
    
    
    <summary type="html">MySQL5.6-5.7-8.0版本授权用户远程连接</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="MySQL" scheme="http://www.formeasy.cc/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Window环境下安装Redis</title>
    <link href="http://www.formeasy.cc/2025/10/10/Redis/Window%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Redis/"/>
    <id>http://www.formeasy.cc/2025/10/10/Redis/Window%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Redis/</id>
    <published>2025-10-10T06:27:15.000Z</published>
    <updated>2025-10-10T06:33:39.166Z</updated>
    
    <content type="html"><![CDATA[<p>由于 Redis 官方没有提供 Windows 原生版本，这里将介绍几种主流的安装方法。</p><hr /><h3 id="方法一使用微软移植的-redis最推荐-最稳定"><a class="markdownIt-Anchor" href="#方法一使用微软移植的-redis最推荐-最稳定"></a> 方法一：使用微软移植的 Redis（最推荐、最稳定）</h3><p>这是最适合 Windows 的安装方式，由微软团队维护，提供了稳定的安装包。</p><h4 id="下载-redis"><a class="markdownIt-Anchor" href="#下载-redis"></a> 下载 Redis</h4><ol><li><p>访问 Redis 在 GitHub 的发布页面：<br /><strong><a href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></strong></p></li><li><p>找到最新的稳定版。通常文件名格式为 <code>Redis-x64-3.0.504.msi</code>（版本号可能不同）。<strong>下载 <code>.msi</code> 安装文件。</strong></p></li></ol><h4 id="安装-redis"><a class="markdownIt-Anchor" href="#安装-redis"></a> 安装 Redis</h4><ol><li><strong>运行安装程序</strong>：双击下载的 <code>.msi</code> 文件。</li><li><strong>同意许可协议</strong>：勾选 “I accept the terms in the License Agreement”，然后点击 “Next”。</li><li><strong>选择安装路径</strong>：建议保持默认路径（<code>C:\Program Files\Redis\</code>），点击 “Next”。</li><li><strong>配置端口</strong>：默认端口是 <code>6379</code>，保持默认即可，点击 “Next”。</li><li><strong>设置内存限制</strong>：这个设置可以保持默认，点击 “Next”。</li><li><strong>重要配置</strong>：<strong>务必勾选 “Add the Redis installation folder to the PATH environment variable”</strong>（将 Redis 添加到系统环境变量）。这样你就可以在任意命令行窗口中使用 <code>redis-cli</code> 命令了。</li><li><strong>完成安装</strong>：点击 “Install” 开始安装。安装完成后，点击 “Finish”。</li></ol><h4 id="验证安装和服务状态"><a class="markdownIt-Anchor" href="#验证安装和服务状态"></a> 验证安装和服务状态</h4><ol><li><p><strong>打开命令提示符（CMD）或 PowerShell</strong>：按 <code>Win + R</code>，输入 <code>cmd</code> 或 <code>powershell</code>，然后回车。</p></li><li><p><strong>检查 Redis 服务</strong>：Redis 安装后会默认作为 Windows 服务运行。</p><ul><li><p><strong>方法A（图形界面）</strong>：</p><ul><li>按 <code>Win + R</code>，输入 <code>services.msc</code>，回车。</li><li>在服务列表中找到 <code>Redis</code>，其状态应为 “正在运行”。</li></ul></li><li><p><strong>方法B（命令行）</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sc</span> query Redis</span><br></pre></td></tr></table></figure><p>如果看到 <code>STATE</code> 显示为 <code>RUNNING</code>，则表示服务运行正常。</p></li></ul></li><li><p><strong>测试连接</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis<span class="literal">-cli</span></span><br></pre></td></tr></table></figure><p>你会看到命令提示符变成 <code>127.0.0.1:6379&gt;</code>。<br />输入 <code>ping</code>，如果服务器回复 <code>PONG</code>，说明安装成功！</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ping</span><br><span class="line">PONG</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> mykey <span class="string">&quot;Hello Redis&quot;</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get mykey</span><br><span class="line"><span class="string">&quot;Hello Redis&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="keyword">exit</span></span><br></pre></td></tr></table></figure></li></ol><hr /><h3 id="方法二使用-wsl2体验与-linux-一致的环境"><a class="markdownIt-Anchor" href="#方法二使用-wsl2体验与-linux-一致的环境"></a> 方法二：使用 WSL2（体验与 Linux 一致的环境）</h3><p>Windows Subsystem for Linux 2 是在 Windows 上运行原生 Linux 二进制文件的最佳方式。如果你需要进行开发，这是<strong>最推荐</strong>的方法，因为它的行为和 Linux 生产环境完全一致。</p><ol><li><p><strong>安装 WSL2</strong>：</p><ul><li><p>以管理员身份打开 PowerShell 或 Windows 命令提示符，然后运行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span></span><br></pre></td></tr></table></figure></li><li><p>此命令将启用所需的可选功能，默认安装 Ubuntu 发行版，并设置为使用 WSL2。安装后需要重启电脑。</p></li></ul></li><li><p><strong>启动 WSL</strong>：在开始菜单中搜索 “Ubuntu” 并启动。</p></li><li><p><strong>在 WSL 中安装 Redis</strong>：</p><ul><li><p>在 WSL 终端中，执行以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade <span class="literal">-y</span></span><br><span class="line">sudo apt install redis<span class="literal">-server</span> <span class="literal">-y</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>在 WSL 中启动 Redis</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service redis<span class="literal">-server</span> <span class="built_in">start</span></span><br></pre></td></tr></table></figure></li><li><p><strong>连接测试</strong>：</p><ul><li>在 WSL 终端中直接使用 <code>redis-cli</code>。</li><li>如果要从 Windows 主机连接 WSL2 中的 Redis，配置会稍复杂，需要修改 WSL 中 Redis 的绑定地址。对于初学者，建议先在 WSL 内部进行测试。</li></ul></li></ol><hr /><h3 id="方法三使用-chocolatey-包管理器适合喜欢命令行的用户"><a class="markdownIt-Anchor" href="#方法三使用-chocolatey-包管理器适合喜欢命令行的用户"></a> 方法三：使用 Chocolatey 包管理器（适合喜欢命令行的用户）</h3><p>如果你已经安装了 Chocolatey，安装 Redis 会非常简单。</p><ol><li><p><strong>安装 Chocolatey</strong>：如果未安装，请以<strong>管理员身份</strong>打开 PowerShell，执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Bypass <span class="literal">-Scope</span> <span class="keyword">Process</span> <span class="literal">-Force</span>; [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol = [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol <span class="operator">-bor</span> <span class="number">3072</span>; <span class="built_in">iex</span> ((<span class="built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="string">&#x27;https://community.chocolatey.org/install.ps1&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Chocolatey 安装 Redis</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install redis<span class="literal">-64</span></span><br></pre></td></tr></table></figure></li><li><p>安装完成后，Redis 也会作为服务运行。你可以用与方法一相同的方式进行验证。</p></li></ol><hr /><h3 id="windows-下-redis-的基本使用和管理"><a class="markdownIt-Anchor" href="#windows-下-redis-的基本使用和管理"></a> Windows 下 Redis 的基本使用和管理</h3><h4 id="启动停止-redis-服务"><a class="markdownIt-Anchor" href="#启动停止-redis-服务"></a> 启动/停止 Redis 服务</h4><ul><li><p><strong>图形界面（服务管理器）</strong>：<code>services.msc</code>，找到 <code>Redis</code> 服务，进行启动、停止、重启操作。</p></li><li><p><strong>命令行（管理员权限）</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">net stop Redis</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">net <span class="built_in">start</span> Redis</span><br><span class="line"><span class="comment"># 或者使用 sc 命令</span></span><br><span class="line"><span class="built_in">sc</span> stop Redis</span><br><span class="line"><span class="built_in">sc</span> <span class="built_in">start</span> Redis</span><br></pre></td></tr></table></figure></li></ul><h4 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h4><ul><li><p><strong>配置文件位置</strong>：默认安装在 <code>C:\Program Files\Redis\</code> 目录下，文件名是 <code>redis.windows-service.conf</code>（对于服务）或 <code>redis.windows.conf</code>（对于临时启动）。</p></li><li><p><strong>常见配置修改</strong>：</p><ul><li><p><strong>绑定 IP</strong>：默认只允许本地（<code>127.0.0.1</code>）连接。要允许远程连接，需要编辑配置文件，找到 <code>bind</code> 行，修改为 <code>bind 0.0.0.0</code>。<strong>（注意：这有安全风险，务必设置密码防火墙！）</strong></p></li><li><p><strong>设置密码</strong>：找到 <code># requirepass foobared</code> 行，取消注释并将 <code>foobared</code> 改为你的强密码。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass your_strong_password_here</span><br></pre></td></tr></table></figure></li><li><p><strong>数据文件目录</strong>：<code>dir ./</code> 指定了 RDB 和 AOF 文件的存储位置，通常是安装目录下。</p></li></ul></li><li><p><strong>修改配置后，必须重启 Redis 服务才能生效。</strong></p></li></ul><h4 id="连接有密码的-redis"><a class="markdownIt-Anchor" href="#连接有密码的-redis"></a> 连接有密码的 Redis</h4><p>如果设置了密码，连接方式如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式1：先连接，再认证</span></span><br><span class="line">redis<span class="literal">-cli</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; AUTH your_password</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2：连接时直接指定密码</span></span><br><span class="line">redis<span class="literal">-cli</span> <span class="literal">-a</span> your_password</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式3（更安全，避免密码出现在历史命令中）</span></span><br><span class="line">redis<span class="literal">-cli</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; AUTH your_password</span><br></pre></td></tr></table></figure><h4 id="数据持久化文件"><a class="markdownIt-Anchor" href="#数据持久化文件"></a> 数据持久化文件</h4><p>Redis 的数据会保存在安装目录下（例如 <code>C:\Program Files\Redis\</code>），文件名为：</p><ul><li><strong>RDB 快照</strong>：<code>dump.rdb</code></li><li><strong>AOF 日志</strong>：<code>appendonly.aof</code>（如果开启）</li></ul><hr /><h3 id="使用-gui-工具管理-redis推荐"><a class="markdownIt-Anchor" href="#使用-gui-工具管理-redis推荐"></a> 使用 GUI 工具管理 Redis（推荐）</h3><p>对于不习惯命令行的用户，可以使用图形化界面工具，非常方便。</p><ol><li><p><strong>RedisInsight</strong>（官方推荐，免费）：</p><ul><li><strong>下载地址</strong>：<a href="https://redis.io/redisinsight/">https://redis.io/redisinsight/</a></li><li>功能强大，支持可视化查看数据、执行命令、性能分析等。</li></ul></li><li><p><strong>Another Redis Desktop Manager</strong>（开源，流行）：</p><ul><li><strong>下载地址</strong>：<a href="https://github.com/qishibo/AnotherRedisDesktopManager/releases">https://github.com/qishibo/AnotherRedisDesktopManager/releases</a></li><li>界面美观，响应迅速，非常受开发者欢迎。</li></ul></li><li><p><strong>FastoRedis</strong>（功能全面）：</p><ul><li><strong>下载地址</strong>：<a href="https://fastoredis.com/">https://fastoredis.com/</a></li><li>支持多种数据库模式。</li></ul></li></ol><h3 id="总结与建议"><a class="markdownIt-Anchor" href="#总结与建议"></a> 总结与建议</h3><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>MSI 安装包</strong></td><td><strong>最简单、稳定，一键安装成服务</strong></td><td>版本可能稍旧</td><td><strong>Windows 桌面用户、快速入门</strong></td></tr><tr><td><strong>WSL2</strong></td><td><strong>与 Linux 环境 100% 一致，版本新</strong></td><td>需要开启 WSL，配置稍复杂</td><td><strong>开发者、需要与生产环境保持一致</strong></td></tr><tr><td><strong>Chocolatey</strong></td><td>命令行安装，方便自动化</td><td>需要先安装 Chocolatey</td><td>喜欢包管理器、自动化脚本的用户</td></tr></tbody></table><p><strong>对于绝大多数 Windows 用户，我强烈推荐使用【方法一：微软移植的 MSI 安装包】</strong>，它省去了所有复杂的配置，开箱即用，是体验 Redis 最快的方式。</p>]]></content>
    
    
    <summary type="html">Window环境下安装Redis</summary>
    
    
    
    <category term="数据库" scheme="http://www.formeasy.cc/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="http://www.formeasy.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java快速开发框架大比拼：Jeesite 、jeecgBoot、smartAdmin、若依全方位解析</title>
    <link href="http://www.formeasy.cc/2025/10/07/Other/Java%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E5%A4%A7%E6%AF%94%E6%8B%BC%EF%BC%9AJeesite%20%E3%80%81jeecgBoot%E3%80%81smartAdmin%E3%80%81%E8%8B%A5%E4%BE%9D%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.formeasy.cc/2025/10/07/Other/Java%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E5%A4%A7%E6%AF%94%E6%8B%BC%EF%BC%9AJeesite%20%E3%80%81jeecgBoot%E3%80%81smartAdmin%E3%80%81%E8%8B%A5%E4%BE%9D%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E6%9E%90/</id>
    <published>2025-10-07T14:16:42.000Z</published>
    <updated>2025-10-07T14:25:30.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-引言"><a class="markdownIt-Anchor" href="#一-引言"></a> <strong>一、引言</strong></h3><p>在 Java 开发领域，快速开发框架的出现极大地提高了开发效率，降低了开发成本。Jeesite、jeecgBoot、smartAdmin 和若依作为当下流行的快速开发框架，各自有着独特的特性。本文将对这四个框架进行详细的对比分析，涵盖它们的特点、优势与劣势、适用场景、使用技巧以及实际案例，帮助开发者根据项目需求做出最佳选择。</p><p><img src="911b7b057788d21493e66a10c6d05835.png" alt="" /></p><h3 id="二-jeesite-框架剖析"><a class="markdownIt-Anchor" href="#二-jeesite-框架剖析"></a> <strong><strong>二、Jeesite</strong> <strong>框架剖析</strong></strong></h3><h4 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> <strong>特点</strong></h4><p>Jeesite 是一个基于 Spring Boot、Spring MVC、MyBatis 等主流框架开发的开源 Java 快速开发平台。它提供了丰富的功能模块，如用户管理、角色管理、菜单管理等基础模块，同时支持多数据源、代码生成等实用功能。该框架采用了经典的 MVC 架构，使得代码结构清晰，易于维护。</p><h4 id="优势"><a class="markdownIt-Anchor" href="#优势"></a> <strong>优势</strong></h4><p><strong>1.成熟稳定</strong>：经过多年的发展和社区维护，Jeesite 在稳定性方面表现出色，能够满足企业级项目对系统稳定性的高要求。</p><p><strong>2.文档完善</strong>：拥有详细的官方文档，从入门教程到高级特性的使用说明一应俱全，对于新手开发者非常友好，能够快速上手开发。</p><p><strong>3.扩展性强</strong>：通过模块化的设计，开发者可以方便地根据项目需求添加或删除功能模块，对不同规模和复杂度的项目都有很好的适应性。</p><h4 id="劣势"><a class="markdownIt-Anchor" href="#劣势"></a> <strong>劣势</strong></h4><p><strong>1.学习曲线较陡</strong>：对于没有太多 Java 开发经验的初学者来说，框架的复杂性可能导致学习成本较高，需要花费一定时间来理解框架的整体架构和运行机制。</p><p><strong>2.界面设计相对传统</strong>：在前端界面设计方面，Jeesite 可能缺乏一些现代感和时尚感，对于对界面美观度要求较高的项目，可能需要进行较多的二次开发。</p><h4 id=""><a class="markdownIt-Anchor" href="#"></a> </h4><p><img src="37e28767b270116a7bfd1231745bafaa.jpeg" alt="" /></p><h4 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> <strong>适用场景</strong></h4><p><strong>1.企业级信息管理系统</strong>：如企业内部的办公自动化系统、资源管理系统等，这些系统对稳定性和扩展性要求较高，Jeesite 能够很好地满足需求。</p><p><strong>2.中大型项目开发</strong>：由于其强大的功能和良好的扩展性，适合用于开发规模较大、业务逻辑复杂的项目，帮助团队高效完成开发任务。</p><h4 id="使用技巧"><a class="markdownIt-Anchor" href="#使用技巧"></a> <strong>使用技巧</strong></h4><p><strong>1.利用代码生成器</strong>：Jeesite 的代码生成器可以根据数据库表结构自动生成 Java 代码和前端页面代码，大大提高开发效率。开发者可以根据项目需求对生成的代码进行定制化修改。</p><p><strong>2.合理配置多数据源</strong>：如果项目涉及多个数据库的操作，合理配置多数据源能够确保数据的高效读写。可以在配置文件中清晰地定义不同数据源的连接信息，并在代码中通过注解等方式指定使用的数据源。</p><h4 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> <strong>案例</strong></h4><p>某大型制造企业的生产管理系统采用 Jeesite 框架进行开发。该系统涵盖了生产计划管理、物料采购管理、库存管理等多个模块。通过 Jeesite 的多数据源功能，系统能够与企业现有的财务系统、销售系统等进行数据交互，实现了企业生产运营的全面信息化管理。在开发过程中，利用代码生成器快速生成了大量基础代码，缩短了开发周期，并且系统上线后运行稳定，满足了企业的业务需求。</p><p><img src="16e4215a401f0cb2973a9fe3d0e84e77.jpeg" alt="" /></p><h3 id="三-jeecgboot-框架解读"><a class="markdownIt-Anchor" href="#三-jeecgboot-框架解读"></a> <strong><strong>三、JeecgBoot</strong> <strong>框架解读</strong></strong></h3><h4 id="特点-2"><a class="markdownIt-Anchor" href="#特点-2"></a> <strong>特点</strong></h4><p>JeecgBoot 是一款基于代码生成器的快速开发平台，基于 Spring Boot、MyBatis-Plus 等技术构建。它的代码生成功能非常强大，支持单表、一对多、树表等多种模式的代码生成。同时，JeecgBoot 还集成了丰富的前端组件库，如 Element UI，使得前端开发更加便捷高效。</p><h4 id="优势-2"><a class="markdownIt-Anchor" href="#优势-2"></a> <strong>优势</strong></h4><p><strong>1.快速开发</strong>：强大的代码生成功能可以快速生成项目所需的后端代码和前端页面，极大地提高了开发速度，尤其适合对项目交付时间要求较高的场景。</p><p><strong>2.丰富的插件和扩展</strong>：框架提供了众多插件，如工作流插件、报表插件等，可以方便地集成到项目中，满足不同业务场景的需求，减少了开发人员的重复劳动。</p><p><strong>3.良好的前端体验</strong>：基于 Element UI 的前端设计，界面美观大方，交互性强，能够为用户提供良好的使用体验，对于注重用户体验的项目来说是一个不错的选择。</p><h4 id="劣势-2"><a class="markdownIt-Anchor" href="#劣势-2"></a> <strong>劣势</strong></h4><p><strong>1.定制化难度</strong>：虽然代码生成功能方便，但对于一些复杂的业务逻辑和特殊需求，可能需要对生成的代码进行大量修改，定制化过程相对复杂，需要开发者对框架有较深入的理解。</p><p><strong>2.依赖较多</strong>：框架集成了多个第三方库和插件，可能会导致项目的依赖关系较为复杂，在版本升级或维护过程中可能会出现一些兼容性问题。</p><h4 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> </h4><p><img src="b2df04c3962e581310136ef219a54e95.png" alt="" /></p><h4 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> </h4><h4 id="适用场景-2"><a class="markdownIt-Anchor" href="#适用场景-2"></a> <strong>适用场景</strong></h4><p><strong>1.快速原型开发</strong>：对于需要快速搭建项目原型，验证业务想法的场景，JeecgBoot 的快速开发特性能够快速生成可用的系统框架，为后续的开发工作奠定基础。</p><p><strong>2.中小项目开发</strong>：在业务逻辑不是特别复杂的中小项目中，JeecgBoot 可以充分发挥其快速开发的优势，帮助团队快速完成项目开发，降低开发成本。</p><h4 id="使用技巧-2"><a class="markdownIt-Anchor" href="#使用技巧-2"></a> <strong>使用技巧</strong></h4><p><strong>1.熟练掌握代码生成配置</strong>：仔细配置代码生成的参数，如表名、字段类型、关联关系等，以生成符合项目需求的高质量代码。可以通过自定义模板来进一步定制生成代码的风格和结构。</p><p><strong>2.合理使用插件</strong>：根据项目业务需求，有选择性地使用框架提供的插件。在使用插件前，充分了解插件的功能和使用方法，确保其与项目的兼容性和稳定性。</p><h4 id="案例-2"><a class="markdownIt-Anchor" href="#案例-2"></a> <strong>案例</strong></h4><p>一家互联网创业公司在开发一款在线教育平台时采用了 JeecgBoot 框架。由于项目时间紧迫，需要快速搭建平台的基本架构。通过 JeecgBoot 的代码生成功能，开发团队迅速生成了用户管理、课程管理、订单管理等模块的后端代码和前端页面。同时，利用工作流插件实现了课程审核流程的自动化。该平台在短时间内上线，并获得了用户的良好反馈，帮助创业公司快速占领了市场份额。</p><p><img src="0dd4394d238e0c8d84600739fc4be1aa.png" alt="" /></p><h3 id="四-smartadmin-框架分析"><a class="markdownIt-Anchor" href="#四-smartadmin-框架分析"></a> <strong><strong>四、SmartAdmin</strong> <strong>框架分析</strong></strong></h3><h4 id="特点-3"><a class="markdownIt-Anchor" href="#特点-3"></a> <strong>特点</strong></h4><p>SmartAdmin 是一个轻量级的 Java 快速开发框架，基于 Spring Boot 和 Vue.js 技术栈。它强调简洁高效的开发理念，提供了简洁的代码结构和丰富的工具类。在权限管理方面，SmartAdmin 有着独特的设计，能够灵活地实现不同用户角色的权限控制。</p><h4 id="优势-3"><a class="markdownIt-Anchor" href="#优势-3"></a> <strong>优势</strong></h4><p><strong>1.轻量级设计</strong>：框架体积小，启动速度快，资源消耗低，适合对性能要求较高的项目，尤其是在一些资源受限的环境中也能稳定运行。</p><p><strong>2.前后端分离架构</strong>：采用流行的前后端分离架构，前端基于 Vue.js 开发，使得前后端开发人员可以并行工作，提高开发效率。同时，前后端分离也有利于系统的维护和扩展。</p><p><strong>3.灵活的权限管理</strong>：提供了强大而灵活的权限管理功能，可以根据用户角色、部门等多种维度进行权限分配，满足不同项目复杂的权限需求。</p><h4 id="劣势-3"><a class="markdownIt-Anchor" href="#劣势-3"></a> <strong>劣势</strong></h4><p><strong>1.功能相对较少</strong>：与一些功能全面的大型框架相比，SmartAdmin 的功能模块相对较少，对于一些业务复杂、需要大量功能集成的项目，可能需要进行较多的二次开发来补充功能。</p><p><strong>2.社区活跃度有限</strong>：目前其社区活跃度相对不高，在遇到问题时，可能较难从社区获取及时有效的解决方案，一定程度上增加了开发和维护的难度。</p><h4 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> </h4><h4 id="适用场景-3"><a class="markdownIt-Anchor" href="#适用场景-3"></a> <strong>适用场景</strong></h4><p><strong>1.小型 Web 应用开发</strong>：如小型企业官网、个人博客、小型电商平台等，这些项目对功能复杂度要求不高，SmartAdmin 的轻量级和高效开发特性能够快速实现项目需求。</p><p><strong>2.对性能要求高的系统</strong>：在一些对系统性能和响应速度要求苛刻的场景下，如实时数据处理系统、高并发访问的应用等，SmartAdmin 的轻量级设计能够保证系统的高效运行。</p><h4 id="使用技巧-3"><a class="markdownIt-Anchor" href="#使用技巧-3"></a> <strong>使用技巧</strong></h4><p><strong>1.优化前端代码</strong>：由于采用 Vue.js 进行前端开发，开发者可以通过优化前端代码结构、使用 Vue 的性能优化技巧等方式，进一步提高前端页面的加载速度和用户体验。</p><p><strong>2.合理配置权限</strong>：根据项目的实际业务需求，细致地进行权限配置。可以利用 SmartAdmin 提供的权限管理工具，对不同用户角色的操作权限进行精准控制，确保系统的安全性。</p><h4 id="案例-3"><a class="markdownIt-Anchor" href="#案例-3"></a> <strong>案例</strong></h4><p>某小型电商创业公司开发一款移动端电商应用的后台管理系统时选择了 SmartAdmin 框架。由于公司资源有限，且对系统性能和开发速度有较高要求，SmartAdmin 的轻量级和前后端分离特性满足了这些需求。开发团队快速搭建了系统的后端服务，并利用 Vue.js 开发了简洁易用的前端管理界面。通过灵活的权限管理功能，实现了不同岗位员工（如管理员、客服、运营人员等）的权限控制。该系统上线后运行稳定，为电商业务的顺利开展提供了有力支持。</p><h3 id="五-若依框架探讨"><a class="markdownIt-Anchor" href="#五-若依框架探讨"></a> <strong><strong>五、若依框架探讨</strong></strong></h3><h4 id="特点-4"><a class="markdownIt-Anchor" href="#特点-4"></a> <strong>特点</strong></h4><p>若依是一个基于 Spring Boot 和 Vue.js 的开源快速开发平台，致力于为企业级开发提供一站式解决方案。它提供了丰富的功能模块，包括用户管理、部门管理、菜单管理、数据权限等。若依注重代码的简洁性和可维护性，采用了流行的技术架构，易于上手和扩展。</p><p><img src="37e4d408b30a578dbca203154887721f.png" alt="" /></p><h4 id="优势-4"><a class="markdownIt-Anchor" href="#优势-4"></a> <strong>优势</strong></h4><p><strong>1.功能全面</strong>：涵盖了企业级开发中常见的各种功能模块，开发者可以直接使用这些模块进行项目开发，减少了从头开发基础功能的时间和工作量。</p><p><strong>2.代码简洁易读</strong>：框架的代码风格简洁明了，遵循良好的编程规范，使得代码的可读性和可维护性都很高。对于团队开发来说，有利于新成员快速理解和融入项目。</p><p><strong>3.持续更新和社区支持</strong>：若依的开发者团队持续对框架进行更新和优化，修复漏洞和添加新功能。同时，活跃的社区为开发者提供了交流和学习的平台，遇到问题时能够及时获得帮助。</p><h4 id="劣势-4"><a class="markdownIt-Anchor" href="#劣势-4"></a> <strong>劣势</strong></h4><p><strong>1.系统复杂度</strong>：由于功能全面，框架本身的复杂度相对较高，对于一些简单项目来说，可能会引入过多不必要的依赖和复杂性，增加了项目的维护成本。</p><p><strong>2.部分功能定制困难</strong>：在某些情况下，对于一些特殊业务需求，对框架中已有的功能模块进行定制可能会比较困难，需要对框架的底层代码有深入了解才能进行修改。</p><h4 id="适用场景-4"><a class="markdownIt-Anchor" href="#适用场景-4"></a> <strong>适用场景</strong></h4><p><strong>1.大型企业级项目</strong>：适合开发大型企业的综合管理系统，如企业资源计划（ERP）系统、客户关系管理（CRM）系统等，能够充分发挥其功能全面和稳定性高的优势。</p><p><strong>2.通用型后台管理系统</strong>：若依的功能模块和架构设计非常适合开发通用型的后台管理系统，开发者可以根据具体项目需求对现有模块进行定制和扩展，快速搭建出满足业务需求的管理平台。</p><h4 id="使用技巧-4"><a class="markdownIt-Anchor" href="#使用技巧-4"></a> <strong>使用技巧</strong></h4><p><strong>1.合理利用已有模块</strong>：在项目开发过程中，充分分析若依提供的功能模块，尽可能复用已有的功能，减少重复开发。对于需要定制的部分，可以在已有模块的基础上进行适当修改。</p><p><strong>2.关注社区动态</strong>：积极参与若依的社区讨论，关注框架的更新动态和其他开发者分享的经验技巧。通过社区可以获取到更多关于框架优化和使用的信息，提高开发效率和项目质量。</p><h4 id="案例-4"><a class="markdownIt-Anchor" href="#案例-4"></a> <strong>案例</strong></h4><p>某大型金融企业在进行内部管理系统升级时采用了若依框架。该系统需要整合多个业务部门的功能，包括财务管理、风险管理、人力资源管理等。若依丰富的功能模块和强大的扩展性满足了企业的需求。开发团队在若依的基础上，通过定制化开发，快速搭建了一套符合企业业务流程的综合管理系统。系统上线后，稳定运行，提高了企业内部的管理效率和协同工作能力，得到了企业用户的高度认可。</p><p><img src="d3668f1da1d0a05f9721d96d6516fe13.png" alt="" /></p><h3 id="六-对比总结"><a class="markdownIt-Anchor" href="#六-对比总结"></a> <strong><strong>六、对比总结</strong></strong></h3><table><tbody><tr><td><p><strong>框架名称</strong></p></td><td><p><strong>特点</strong></p></td><td><p><strong>优势</strong></p></td><td><p><strong>劣势</strong></p></td><td><p><strong>适用场景</strong></p></td></tr><tr><td><p>Jeesite</p></td><td><p>基于主流<span data-tit="框架" data-pretit="框架">框架</span>，MVC&nbsp;架构，功能模块丰富</p></td><td><p>成熟稳定、文档完善、扩展性强</p></td><td><p>学习曲线较陡、界面设计传统</p></td><td><p>企业级信息<span data-tit="管理系统" data-pretit="管理系统">管理系统</span>、中大型项目</p></td></tr><tr><td><p>JeecgBoot</p></td><td><p>基于代码<span data-tit="生成器" data-pretit="生成器">生成器</span>，集成前端组件库</p></td><td><p>快速开发、插件丰富、前端体验好</p></td><td><p>定制化难度大、依赖较多</p></td><td><p>快速原型开发、中小项目</p></td></tr><tr><td><p>SmartAdmin</p></td><td><p>轻量级，前后端分离，权限管理灵活</p></td><td><p>轻量级设计、前后端分离、权限管理灵活</p></td><td><p>功能相对较少、社区活跃度有限</p></td><td><p>小型&nbsp;Web&nbsp;应用、对性能要求高的系统</p></td></tr><tr><td><p>若依</p></td><td><p>功能全面，代码简洁，社区活跃</p></td><td><p>功能全面、代码简洁易读、持续更新和社区支持</p></td><td><p>系统复杂度高、部分功能定制困难</p></td><td><p>大型企业级项目、通用型<span data-tit="后台管理系统" data-pretit="后台管理系统">后台管理系统</span></p></td></tr></tbody></table><h3 id="七-结论"><a class="markdownIt-Anchor" href="#七-结论"></a> <strong><strong>七、结论</strong></strong></h3><p>Jeesite、jeecgBoot、smartAdmin 和若依这四个 Java 快速开发框架都有各自的特点和优势，也存在一定的劣势。在选择框架时，开发者需要综合考虑项目的规模、业务复杂度、性能要求、开发时间等因素。对于大型企业级项目，若依和 Jeesite 可能是较好的选择；对于快速原型开发和中小项目，JeecgBoot 更具优势；而对于小型 Web 应用和对性能要求高的系统，SmartAdmin 则是不错的选项。希望通过本文的对比分析，能够帮助开发者在实际项目中做出更合适的框架选择，提高开发效率，打造出高质量的 Java 应用系统。</p><p><strong>若依地址：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/y_project/RuoYi</span><br></pre></td></tr></table></figure><p><strong>Jeesite地址：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/thinkgem/jeesite</span><br></pre></td></tr></table></figure><p><strong>JeecgBoot地址：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/jeecg/JeecgBoot</span><br></pre></td></tr></table></figure><p><strong>SmartAdmin地址：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/lab1024/smart-admin</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java快速开发框架大比拼：Jeesite 、jeecgBoot、smartAdmin、若依全方位解析</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Other" scheme="http://www.formeasy.cc/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>Redis 同步机制解析</title>
    <link href="http://www.formeasy.cc/2025/10/05/Redis/Redis%20%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.formeasy.cc/2025/10/05/Redis/Redis%20%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</id>
    <published>2025-10-05T14:21:03.000Z</published>
    <updated>2025-10-05T14:42:18.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-redis-同步机制的核心与价值"><a class="markdownIt-Anchor" href="#一-redis-同步机制的核心与价值"></a> 一、Redis 同步机制的核心与价值</h2><h3 id="11-核心需求数据备份与读写分离"><a class="markdownIt-Anchor" href="#11-核心需求数据备份与读写分离"></a> 1.1 核心需求：数据备份与读写分离</h3><h4 id="数据备份"><a class="markdownIt-Anchor" href="#数据备份"></a> 数据备份</h4><p>在实际生产环境中，单机Redis实例存在多种风险：</p><ul><li>服务器硬件故障导致数据永久丢失</li><li>操作系统崩溃导致内存数据未持久化</li><li>误操作删除关键数据</li></ul><p>通过同步机制建立主从架构，可以实现：</p><ol><li><strong>多副本存储</strong>：数据至少存在于2个节点（1主1从），典型配置为1主2从</li><li><strong>容灾恢复</strong>：当主节点故障时，可快速提升从节点为新主节点</li><li><strong>数据持久化保障</strong>：结合RDB和AOF持久化策略，即使主节点完全损坏，从节点也能提供完整的数据恢复点</li></ol><p><strong>示例场景</strong>：电商平台商品库存数据，通过同步机制确保即使主节点宕机，从节点也能继续提供服务，避免超卖。</p><h4 id="读写分离"><a class="markdownIt-Anchor" href="#读写分离"></a> 读写分离</h4><p>Redis的主从架构天然支持读写分离：</p><ul><li><strong>主节点(Master)</strong>：处理所有写入操作（SET, INCR等）和部分关键读请求</li><li><strong>从节点(Slave)</strong>：处理90%以上的读请求（GET, HGET等），支持配置多个从节点实现水平扩展</li></ul><p><strong>优势体现</strong>：</p><ul><li>提升系统整体吞吐量：读性能随从节点数量线性增长</li><li>降低主节点负载：将CPU密集型操作（如复杂Lua脚本）分流到从节点</li><li>实现地域就近访问：在不同机房部署从节点，减少网络延迟</li></ul><p><strong>典型应用</strong>：</p><ul><li>社交平台：主节点处理发帖/点赞等写操作，从节点处理信息流展示</li><li>内容管理系统：主节点处理内容更新，从节点处理内容查询</li></ul><h3 id="12-关键目标高效-可靠-低延迟"><a class="markdownIt-Anchor" href="#12-关键目标高效-可靠-低延迟"></a> 1.2 关键目标：高效、可靠、低延迟</h3><h4 id="高效性实现"><a class="markdownIt-Anchor" href="#高效性实现"></a> 高效性实现</h4><p>Redis采用智能复制策略平衡效率：</p><ol><li><p><strong>全量复制</strong>：</p><ul><li>初次连接时执行</li><li>通过RDB快照完成</li><li>优化措施：支持无盘复制（diskless replication）</li></ul></li><li><p><strong>增量复制</strong>：</p><ul><li>基于复制积压缓冲区（repl-backlog-buffer）</li><li>默认大小1MB，可根据网络质量调整</li><li>仅传输变更命令，大幅减少带宽占用</li></ul></li></ol><p><strong>配置建议</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-size 16mb  # 提升缓冲区大小应对网络不稳定</span><br><span class="line">repl-diskless-sync yes  # 启用无盘复制加速全量同步</span><br></pre></td></tr></table></figure><h4 id="可靠性保障"><a class="markdownIt-Anchor" href="#可靠性保障"></a> 可靠性保障</h4><p>Redis通过多种机制确保同步可靠性：</p><ul><li><strong>断点续传</strong>：基于复制偏移量（replication offset）记录同步进度</li><li><strong>心跳检测</strong>：主从定期（默认10秒）PING-PONG通信</li><li><strong>自动重连</strong>：网络恢复后自动重新建立同步连接</li><li><strong>数据校验</strong>：使用CRC64校验和验证数据一致性</li></ul><h4 id="低延迟优化"><a class="markdownIt-Anchor" href="#低延迟优化"></a> 低延迟优化</h4><p>为实现毫秒级同步延迟，Redis采用：</p><ol><li><strong>TCP长连接</strong>：避免频繁建立连接的开销</li><li><strong>异步复制</strong>：主节点不等待从节点ACK继续处理请求</li><li><strong>延迟监控</strong>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO replication  # 查看master_repl_offset和slave_repl_offset差值</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>硬件优化</strong>：<ul><li>主从节点部署在同一可用区减少网络延迟</li><li>使用高性能网卡（如10Gbps）</li></ul></li></ol><p><strong>性能指标</strong>：</p><ul><li>同机房延迟：通常&lt;1ms</li><li>跨机房延迟：取决于网络质量，通常&lt;10ms</li><li>极端情况下可配置WAIT命令实现同步写（牺牲性能换取更强一致性）</li></ul><h2 id="二-基础同步主从复制master-slave-replication"><a class="markdownIt-Anchor" href="#二-基础同步主从复制master-slave-replication"></a> 二、基础同步：主从复制（Master-Slave Replication）</h2><p>主从复制是 Redis 同步机制的基石，所有高级同步（哨兵、集群）均基于此扩展。其核心逻辑是通过主节点(Master)和从节点(Slave)的协作，实现数据的分布式存储和读写分离。从节点主动连接主节点，复制主节点的数据集，并实时同步主节点的写操作。这种架构设计不仅提高了系统的可用性，还能有效分担主节点的读请求压力。</p><h3 id="21-主从复制的三个核心阶段"><a class="markdownIt-Anchor" href="#21-主从复制的三个核心阶段"></a> 2.1 主从复制的三个核心阶段</h3><p>主从复制全流程分为&quot;建立连接&quot;、“数据同步”、&quot;命令传播&quot;三个阶段，缺一不可。这三个阶段构成了一个完整的数据同步生命周期，确保主从节点之间的数据最终一致性。</p><h4 id="阶段-1建立连接握手阶段"><a class="markdownIt-Anchor" href="#阶段-1建立连接握手阶段"></a> 阶段 1：建立连接（握手阶段）</h4><p>从节点通过配置<code>slaveof &lt;master-ip&gt; &lt;master-port&gt;</code>（Redis 5.0 后推荐使用更符合现代语义的<code>replicaof</code>）触发连接流程，具体步骤如下：</p><ol><li><p><strong>初始化连接</strong>：</p><ul><li>从节点启动后，向主节点发送<code>SYNC</code>命令（Redis 2.8 前）或更先进的<code>PSYNC</code>命令（Redis 2.8 后，支持增量复制）</li><li>主节点收到命令后，首先验证从节点的<code>requirepass</code>（若配置）与自身<code>masterauth</code>是否一致</li><li>验证通过后，主节点返回<code>+OK</code>响应</li></ul></li><li><p><strong>建立通信通道</strong>：</p><ul><li>主节点创建一个专门的&quot;复制客户端&quot;（用于向从节点发送数据）</li><li>从节点创建&quot;复制监听器&quot;（用于接收主节点发送的数据）</li><li>双方完成TCP连接初始化，为后续数据传输做好准备</li></ul></li><li><p><strong>连接确认</strong>：</p><ul><li>从节点会定期发送<code>PING</code>命令检测连接状态</li><li>主节点响应<code>PONG</code>确认连接正常</li></ul></li></ol><h4 id="阶段-2数据同步全量-增量复制"><a class="markdownIt-Anchor" href="#阶段-2数据同步全量-增量复制"></a> 阶段 2：数据同步（全量 / 增量复制）</h4><p>这是同步的核心阶段，分为两种模式：全量复制（首次同步或从节点断线过久）和增量复制（从节点短期断线后恢复）。选择哪种模式取决于从节点的同步状态和断开时间。</p><h5 id="221-全量复制从-0-到-1-复制完整数据集"><a class="markdownIt-Anchor" href="#221-全量复制从-0-到-1-复制完整数据集"></a> 2.2.1 全量复制：从 0 到 1 复制完整数据集</h5><p>当遇到以下情况时会触发全量复制：</p><ul><li>从节点是全新节点，从未同步过数据</li><li>从节点的<code>replid</code>（主节点标识）与主节点不一致</li><li>从节点的复制偏移量<code>offset</code>不在主节点的复制积压缓冲区范围内</li></ul><p><strong>全量复制详细流程</strong>：</p><ol><li><p><strong>发起请求</strong>：</p><ul><li>从节点发送<code>PSYNC ? -1</code>命令（表示请求全量复制）</li></ul></li><li><p><strong>主节点准备RDB</strong>：</p><ul><li>主节点接收到请求后，执行<code>bgsave</code>命令在后台生成RDB快照文件</li><li>在生成RDB期间，主节点会缓存所有写操作（如<code>SET</code>、<code>HSET</code>）到&quot;复制积压缓冲区&quot;</li></ul></li><li><p><strong>传输RDB文件</strong>：</p><ul><li>RDB生成完成后，主节点通过专用连接将RDB文件分块传输给从节点</li><li>传输过程中使用TCP滑动窗口机制优化网络传输效率</li></ul></li><li><p><strong>从节点加载数据</strong>：</p><ul><li>从节点收到RDB文件后，首先安全地清空自身数据集</li><li>然后将RDB文件加载到内存中，重建数据库</li></ul></li><li><p><strong>同步缓冲命令</strong>：</p><ul><li>主节点发送完RDB后，将&quot;复制积压缓冲区&quot;中的写操作按顺序发送给从节点</li><li>从节点执行这些命令，确保与主节点数据完全一致</li></ul></li></ol><p><strong>性能考量</strong>：</p><ul><li>RDB生成过程会fork子进程，可能导致短暂延迟</li><li>网络传输大数据量可能成为瓶颈</li><li>从节点加载RDB时会出现服务暂停</li><li>建议在业务低峰期执行全量复制，并确保网络带宽充足</li></ul><h5 id="222-增量复制仅同步断线期间的增量数据"><a class="markdownIt-Anchor" href="#222-增量复制仅同步断线期间的增量数据"></a> 2.2.2 增量复制：仅同步断线期间的增量数据</h5><p>当从节点短期断线（如网络闪断）后重新连接，且主节点的&quot;复制积压缓冲区&quot;仍保留断线期间的写操作时，触发增量复制。这种模式显著提高了同步效率。</p><p><strong>增量复制详细流程</strong>：</p><ol><li><p><strong>重新连接</strong>：</p><ul><li>从节点重新连接主节点时，发送<code>PSYNC &lt;replid&gt; &lt;offset&gt;</code>命令</li><li><code>replid</code>是主节点标识，<code>offset</code>是从节点最后一次同步的位置</li></ul></li><li><p><strong>主节点验证</strong>：</p><ul><li>主节点验证<code>replid</code>是否与自身一致</li><li>检查<code>offset</code>是否在&quot;复制积压缓冲区&quot;的有效范围内（缓冲区保留[master_offset - backlog_size, master_offset]的操作）</li></ul></li><li><p><strong>执行增量同步</strong>：</p><ul><li>验证通过后，主节点仅将<code>offset</code>之后的写操作从缓冲区发送给从节点</li><li>从节点执行这些增量命令，快速追上主节点数据状态</li></ul></li></ol><p><strong>增量复制的关键条件</strong>：</p><ol><li>从节点需正确记录上一次同步的<code>replid</code>和<code>offset</code>（存储在<code>replica.conf</code>中）</li><li>主节点的&quot;复制积压缓冲区&quot;需足够大，能够容纳断线期间的写操作</li><li>断线时间未超过<code>repl-backlog-ttl</code>（默认3600秒），避免缓冲区被清空</li></ol><p><strong>优化建议</strong>：</p><ul><li>对于写操作频繁的场景，适当增大<code>repl-backlog-size</code></li><li>监控从节点的复制延迟，及时发现潜在问题</li><li>定期检查复制积压缓冲区的使用情况</li></ul><h4 id="阶段-3命令传播实时同步写操作"><a class="markdownIt-Anchor" href="#阶段-3命令传播实时同步写操作"></a> 阶段 3：命令传播（实时同步写操作）</h4><p>数据同步完成后，主从进入&quot;命令传播&quot;阶段，这是维持数据一致性的关键环节。主节点每执行一次写命令，都会将该命令发送给所有从节点，从节点执行相同命令，确保数据实时同步。</p><p><strong>命令传播的详细机制</strong>：</p><ol><li><p><strong>写命令传播流程</strong>：</p><ul><li>客户端向主节点发送写命令（如<code>SET key value</code>）</li><li>主节点执行命令并修改本地数据</li><li>主节点将命令封装为Redis协议格式，发送给所有从节点</li><li>从节点接收并执行相同命令</li></ul></li><li><p><strong>性能优化策略</strong>：</p><ul><li>主节点采用&quot;异步发送&quot;模式：写命令执行后立即返回客户端，随后异步将命令发送给从节点</li><li>从节点通过<code>repl-disable-tcp-nodelay</code>配置控制TCP特性：<ul><li>默认<code>no</code>（关闭TCP_NODELAY）：TCP会缓冲小数据包，减少网络请求数，但可能增加毫秒级延迟</li><li>设为<code>yes</code>（开启TCP_NODELAY）：写命令立即发送，延迟降低，但网络请求数增加</li></ul></li></ul></li><li><p><strong>复制偏移量监控</strong>：</p><ul><li>主从节点都会维护复制偏移量<code>offset</code></li><li>通过<code>INFO replication</code>可以查看主从节点的<code>master_repl_offset</code>和<code>slave_repl_offset</code></li><li>两者的差值反映了复制延迟</li></ul></li></ol><h3 id="22-主从复制的核心配置"><a class="markdownIt-Anchor" href="#22-主从复制的核心配置"></a> 2.2 主从复制的核心配置</h3><h4 id="主节点配置"><a class="markdownIt-Anchor" href="#主节点配置"></a> 主节点配置</h4><table><thead><tr><th>配置项</th><th>示例值</th><th>说明</th><th>推荐设置</th></tr></thead><tbody><tr><td><code>bind</code></td><td><code>0.0.0.0</code></td><td>允许从节点远程连接</td><td>生产环境建议绑定具体IP</td></tr><tr><td><code>protected-mode</code></td><td><code>no</code></td><td>关闭保护模式</td><td>必须关闭才能远程连接</td></tr><tr><td><code>port</code></td><td><code>6379</code></td><td>主节点服务端口</td><td>默认6379，可修改</td></tr><tr><td><code>requirepass</code></td><td><code>Str0ngP@ss</code></td><td>主节点访问密码</td><td>生产环境必须设置</td></tr><tr><td><code>masterauth</code></td><td><code>Str0ngP@ss</code></td><td>主从同步验证密码</td><td>需与从节点密码一致</td></tr><tr><td><code>repl-backlog-size</code></td><td><code>32mb</code></td><td>复制积压缓冲区大小</td><td>写频繁场景建议增大</td></tr><tr><td><code>repl-backlog-ttl</code></td><td><code>3600</code></td><td>缓冲区保留时间</td><td>默认3600秒(1小时)</td></tr></tbody></table><h4 id="从节点配置"><a class="markdownIt-Anchor" href="#从节点配置"></a> 从节点配置</h4><table><thead><tr><th>配置项</th><th>示例值</th><th>说明</th><th>推荐设置</th></tr></thead><tbody><tr><td><code>replicaof</code></td><td><code>192.168.1.1 6379</code></td><td>指定主节点地址</td><td>Redis 5.0+使用</td></tr><tr><td><code>slaveof</code></td><td><code>192.168.1.1 6379</code></td><td>Redis 5.0前使用</td><td>已弃用</td></tr><tr><td><code>requirepass</code></td><td><code>Str0ngP@ss</code></td><td>从节点密码</td><td>需与主节点masterauth一致</td></tr><tr><td><code>replica-read-only</code></td><td><code>yes</code></td><td>从节点只读模式</td><td>默认开启，防止误写</td></tr><tr><td><code>repl-disable-tcp-nodelay</code></td><td><code>yes</code></td><td>TCP优化选项</td><td>延迟敏感场景开启</td></tr></tbody></table><h4 id="配置验证方法"><a class="markdownIt-Anchor" href="#配置验证方法"></a> 配置验证方法</h4><ol><li><strong>主节点检查</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a yourpassword info replication</span><br></pre></td></tr></table></figure><p>查看<code>connected_slaves</code>是否为预期的从节点数量，以及每个从节点的状态信息。</p><ol start="2"><li><strong>从节点检查</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a yourpassword info replication</span><br></pre></td></tr></table></figure><p>确认<code>master_host</code>和<code>master_port</code>是否正确，<code>master_link_status</code>是否为<code>up</code>（表示连接正常）。</p><ol start="3"><li><strong>复制延迟监控</strong>： 比较主节点的<code>master_repl_offset</code>和从节点的<code>slave_repl_offset</code>，两者的差值即为复制延迟。</li></ol><h4 id="常见问题处理"><a class="markdownIt-Anchor" href="#常见问题处理"></a> 常见问题处理</h4><ol><li><p><strong>连接失败</strong>：</p><ul><li>检查防火墙设置</li><li>验证密码配置是否正确</li><li>确认主节点<code>bind</code>配置允许远程连接</li></ul></li><li><p><strong>同步中断</strong>：</p><ul><li>检查网络连接状态</li><li>查看日志文件定位问题</li><li>适当增大<code>repl-timeout</code>（默认60秒）</li></ul></li><li><p><strong>性能优化</strong>：</p><ul><li>对于大型数据集，考虑在低峰期执行全量同步</li><li>适当调整<code>repl-backlog-size</code>避免频繁全量同步</li><li>监控复制延迟，及时发现性能瓶颈</li></ul></li></ol><h2 id="三-高可用同步哨兵模式sentinel"><a class="markdownIt-Anchor" href="#三-高可用同步哨兵模式sentinel"></a> 三、高可用同步：哨兵模式（Sentinel）</h2><h3 id="31-哨兵模式的核心角色与架构"><a class="markdownIt-Anchor" href="#31-哨兵模式的核心角色与架构"></a> 3.1 哨兵模式的核心角色与架构</h3><p>哨兵模式是一个分布式系统，由以下三部分组成：</p><ol><li><p><strong>哨兵节点（Sentinel）</strong>：</p><ul><li>独立的Redis进程，不存储业务数据</li><li>主要职责：<ul><li>持续监控主从节点健康状态</li><li>检测到主节点故障时自动触发故障转移</li><li>通知客户端主从拓扑变更</li><li>充当服务发现的配置中心</li></ul></li></ul></li><li><p><strong>主节点（Master）</strong>：</p><ul><li>与普通Redis主节点功能相同</li><li>需要响应哨兵的监控请求</li><li>向哨兵报告其从节点列表</li></ul></li><li><p><strong>从节点（Slave）</strong>：</p><ul><li>与普通Redis从节点功能相同</li><li>自动被哨兵发现并监控</li><li>在故障转移时可能被提升为新主节点</li></ul></li></ol><p><strong>架构设计要点</strong>：</p><ul><li><p>哨兵节点数量必须≥3且为奇数（推荐3或5个）</p><ul><li>原因：避免脑裂，确保故障转移需要&quot;多数哨兵同意&quot;的机制能正常工作</li><li>示例：3个哨兵时，至少需要2个哨兵达成共识才能执行故障转移</li></ul></li><li><p>主从节点数量可根据业务需求灵活配置</p><ul><li>典型配置：1主2从+3哨兵（适合中小规模应用）</li><li>大型系统可能采用：1主5从+5哨兵</li></ul></li></ul><h3 id="32-哨兵模式的同步逻辑故障转移流程"><a class="markdownIt-Anchor" href="#32-哨兵模式的同步逻辑故障转移流程"></a> 3.2 哨兵模式的同步逻辑（故障转移流程）</h3><h4 id="步骤1监控sentinel-monitoring"><a class="markdownIt-Anchor" href="#步骤1监控sentinel-monitoring"></a> 步骤1：监控（Sentinel Monitoring）</h4><p>哨兵节点通过以下机制实现全面监控：</p><ol><li><strong>初始配置</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 192.168.1.1 6379 2</span><br></pre></td></tr></table></figure><ul><li><code>mymaster</code>：主节点别名</li><li><code>192.168.1.1:6379</code>：主节点地址</li><li><code>2</code>：判定客观下线需要的哨兵票数</li></ul><ol start="2"><li><p><strong>健康检查机制</strong>：</p><ul><li>每1秒发送<code>PING</code>命令到所有被监控节点<ul><li>正常响应：返回<code>PONG</code></li></ul></li><li>每10秒发送<code>INFO replication</code>到主节点<ul><li>获取从节点列表及其复制状态</li><li>自动发现新增的从节点</li></ul></li></ul></li><li><p><strong>哨兵集群通信</strong>：</p><ul><li>使用Redis的Pub/Sub功能</li><li>每2秒通过<code>__sentinel__:hello</code>频道广播节点状态</li><li>维护哨兵之间的共识状态</li></ul></li></ol><h4 id="步骤2主观下线与客观下线"><a class="markdownIt-Anchor" href="#步骤2主观下线与客观下线"></a> 步骤2：主观下线与客观下线</h4><ol><li><p><strong>主观下线（SDOWN）</strong>：</p><ul><li>触发条件：单个哨兵在<code>down-after-milliseconds</code>（默认30秒）内未收到主节点的有效响应</li><li>处理动作：该哨兵将主节点标记为&quot;主观下线&quot;</li></ul></li><li><p><strong>客观下线（ODOWN）</strong>：</p><ul><li>触发流程：<ul><li>发起投票：哨兵发送<code>SENTINEL is-master-down-by-addr</code>命令询问其他哨兵</li><li>收集响应：等待其他哨兵回复（包含它们对主节点状态的判断）</li><li>达成共识：当≥<code>quorum</code>个哨兵同意主节点不可用时，标记为&quot;客观下线&quot;</li></ul></li><li>示例：配置<code>quorum=2</code>时，需要至少2个哨兵确认主节点故障</li></ul></li></ol><h4 id="步骤3选举新主节点"><a class="markdownIt-Anchor" href="#步骤3选举新主节点"></a> 步骤3：选举新主节点</h4><p>选举过程采用多级排序策略：</p><ol><li><p><strong>第一优先级：replica-priority</strong></p><ul><li>配置项：<code>replica-priority</code>（默认100）</li><li>规则：数值越小优先级越高</li><li>应用场景：可以手动指定某些从节点优先被选为主节点</li></ul></li><li><p><strong>第二优先级：复制偏移量（offset）</strong></p><ul><li>比较各从节点与主节点的数据同步进度</li><li>选择复制进度最接近原主节点的从节点</li><li>确保数据丢失最少</li></ul></li><li><p><strong>第三优先级：runid</strong></p><ul><li>Redis实例启动时生成的唯一标识</li><li>按字典序选择runid较小的节点</li><li>作为最终裁决条件</li></ul></li></ol><h4 id="步骤4故障转移执行"><a class="markdownIt-Anchor" href="#步骤4故障转移执行"></a> 步骤4：故障转移执行</h4><p>完整的故障转移流程：</p><ol><li><strong>提升新主</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF NO ONE</span><br></pre></td></tr></table></figure><ul><li>取消新主节点的从属关系</li><li>使其开始接受写请求</li></ul><ol start="2"><li><strong>重配置从节点</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLICAOF &lt;new-master-ip&gt; &lt;new-master-port&gt;</span><br></pre></td></tr></table></figure><ul><li>所有从节点开始同步新主节点的数据</li><li>采用增量复制或全量复制（取决于复制偏移量）</li></ul><ol start="3"><li><p><strong>旧主节点处理</strong>：</p><ul><li>当旧主节点恢复后，自动被配置为新主节点的从节点</li><li>通过<code>INFO replication</code>命令可以验证复制关系</li></ul></li><li><p><strong>客户端通知</strong>：</p><ul><li>哨兵通过<code>+switch-master</code>事件通知客户端</li><li>客户端应实现自动重连机制</li></ul></li></ol><h3 id="33-哨兵模式的核心配置实战"><a class="markdownIt-Anchor" href="#33-哨兵模式的核心配置实战"></a> 3.3 哨兵模式的核心配置（实战）</h3><h4 id="关键配置详解"><a class="markdownIt-Anchor" href="#关键配置详解"></a> 关键配置详解</h4><table><thead><tr><th>配置项</th><th>说明</th><th>推荐值</th></tr></thead><tbody><tr><td><code>port 26379</code></td><td>哨兵服务端口</td><td>通常保持默认</td></tr><tr><td><code>sentinel monitor &lt;name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</code></td><td>定义监控的主节点</td><td>根据网络环境调整</td></tr><tr><td><code>sentinel down-after-milliseconds &lt;name&gt; 30000</code></td><td>主观下线判定时间</td><td>生产环境建议30-60秒</td></tr><tr><td><code>sentinel failover-timeout &lt;name&gt; 180000</code></td><td>故障转移超时时间</td><td>根据网络延迟调整</td></tr><tr><td><code>sentinel parallel-syncs &lt;name&gt; 1</code></td><td>并行同步数量</td><td>较大集群可适当增加</td></tr></tbody></table><h4 id="配置示例"><a class="markdownIt-Anchor" href="#配置示例"></a> 配置示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel.conf</span></span><br><span class="line">port 26379</span><br><span class="line">sentinel monitor mycluster 10.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mycluster 50000</span><br><span class="line">sentinel failover-timeout mycluster 120000</span><br><span class="line">sentinel auth-pass mycluster MySecurePassword</span><br><span class="line">sentinel parallel-syncs mycluster 2</span><br></pre></td></tr></table></figure><h4 id="运维检查清单"><a class="markdownIt-Anchor" href="#运维检查清单"></a> 运维检查清单</h4><ol><li><strong>启动哨兵</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /etc/redis/sentinel.conf</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>监控命令</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 26379 sentinel masters  <span class="comment"># 查看所有监控的主节点</span></span><br><span class="line">redis-cli -p 26379 sentinel slaves mymaster  <span class="comment"># 查看指定主节点的从节点 </span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>故障模拟测试</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模拟主节点宕机</span></span><br><span class="line">redis-cli -p 6379 DEBUG <span class="built_in">sleep</span> 60</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 观察哨兵日志</span></span><br><span class="line"><span class="built_in">tail</span> -f /var/log/redis/sentinel.log</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>客户端配置</strong>：</p><ul><li>应配置连接所有哨兵节点地址</li><li>实现自动故障转移处理逻辑</li><li>示例Java客户端配置：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JedisSentinelPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisSentinelPool</span>(<span class="string">&quot;mymaster&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;(Arrays.asList(</span><br><span class="line">        <span class="string">&quot;sentinel1:26379&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sentinel2:26379&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sentinel3:26379&quot;</span>)));</span><br></pre></td></tr></table></figure><h2 id="四-分布式同步redis-cluster集群模式"><a class="markdownIt-Anchor" href="#四-分布式同步redis-cluster集群模式"></a> 四、分布式同步：Redis Cluster（集群模式）</h2><h3 id="41-集群模式的核心概念"><a class="markdownIt-Anchor" href="#41-集群模式的核心概念"></a> 4.1 集群模式的核心概念</h3><h4 id="分片机制详解"><a class="markdownIt-Anchor" href="#分片机制详解"></a> 分片机制详解</h4><p>Redis Cluster 使用 CRC16 算法计算 key 的哈希值，然后对 16384 取模得到对应的哈希槽。例如：</p><ul><li>key “user:1001” 的 CRC16 值为 12345，则哈希槽为 12345 % 16384 = 12345</li><li>key “product:2002” 的 CRC16 值为 54321，则哈希槽为 54321 % 16384 = 54321</li></ul><p>哈希槽分配示例：</p><ul><li>3 节点集群：节点1(0-5460)、节点2(5461-10922)、节点3(10923-16383)</li><li>5 节点集群：每个节点约 3276 个槽</li></ul><h4 id="主从复制架构"><a class="markdownIt-Anchor" href="#主从复制架构"></a> 主从复制架构</h4><p>每个主节点可以配置多个从节点，形成多副本保护。从节点会：</p><ul><li>实时同步主节点数据</li><li>在主节点故障时参与选举</li><li>可配置为可读副本分担读压力</li></ul><h4 id="客户端重定向机制"><a class="markdownIt-Anchor" href="#客户端重定向机制"></a> 客户端重定向机制</h4><p>当客户端访问错误节点时，会收到两种重定向响应：</p><ol><li><strong>MOVED</strong>：永久重定向，表示槽已迁移到指定节点</li><li><strong>ASK</strong>：临时重定向，发生在集群扩容/缩容期间</li></ol><h3 id="42-集群模式的同步逻辑"><a class="markdownIt-Anchor" href="#42-集群模式的同步逻辑"></a> 4.2 集群模式的同步逻辑</h3><h4 id="421-分片内同步优化"><a class="markdownIt-Anchor" href="#421-分片内同步优化"></a> 4.2.1 分片内同步优化</h4><ol><li><p><strong>集群感知复制</strong>：</p><ul><li>从节点加入时通过 <code>CLUSTER MEET</code> 发现拓扑</li><li>只同步所属分片的槽数据</li><li>定期交换集群状态信息</li></ul></li><li><p><strong>读写分离配置</strong>：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 允许从节点处理读请求</span><br><span class="line">cluster-replica-ok yes</span><br></pre></td></tr></table></figure><p>启用后，从节点可以：</p><ul><li>响应本地持有的槽的读请求</li><li>其他槽请求仍返回 MOVED</li></ul><h4 id="422-故障转移流程详解"><a class="markdownIt-Anchor" href="#422-故障转移流程详解"></a> 4.2.2 故障转移流程详解</h4><ol><li><p><strong>故障检测阶段</strong>：</p><ul><li>从节点每秒发送 PING</li><li>超时后标记主节点为 <code>PFail</code> (Possible Failure)</li><li>收集其他节点的确认信息</li></ul></li><li><p><strong>选举投票规则</strong>：</p><ul><li>每个主节点有且只有一票</li><li>从节点按以下条件竞选：<ul><li>复制偏移量最新</li><li>节点运行时间最长</li><li>节点ID字典序最小</li></ul></li></ul></li><li><p><strong>数据同步阶段</strong>：</p><ul><li>新主节点生成新的复制ID</li><li>其他从节点执行部分重同步(PSYNC)</li><li>故障期间写入使用故障转移标记</li></ul></li></ol><h3 id="43-集群模式的核心配置与实战"><a class="markdownIt-Anchor" href="#43-集群模式的核心配置与实战"></a> 4.3 集群模式的核心配置与实战</h3><h4 id="配置参数详解"><a class="markdownIt-Anchor" href="#配置参数详解"></a> 配置参数详解</h4><table><thead><tr><th>配置项</th><th>推荐值</th><th>说明</th></tr></thead><tbody><tr><td>cluster-require-full-coverage</td><td>no</td><td>允许部分槽不可用时集群仍可服务</td></tr><tr><td>cluster-migration-barrier</td><td>1</td><td>主节点最少从节点数才开始迁移</td></tr><tr><td>cluster-replica-no-failover</td><td>no</td><td>从节点是否参与故障转移</td></tr></tbody></table><h4 id="集群搭建完整流程"><a class="markdownIt-Anchor" href="#集群搭建完整流程"></a> 集群搭建完整流程</h4><ol><li><strong>准备阶段</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建6个实例配置</span></span><br><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> &#123;6379..6384&#125;; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p /redis/<span class="variable">$&#123;port&#125;</span></span><br><span class="line">  <span class="built_in">cp</span> redis.conf /redis/<span class="variable">$&#123;port&#125;</span>/</span><br><span class="line">  sed -i <span class="string">&quot;s/port 6379/port <span class="variable">$&#123;port&#125;</span>/&quot;</span> /redis/<span class="variable">$&#123;port&#125;</span>/redis.conf</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>启动节点</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动所有节点</span></span><br><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> &#123;6379..6384&#125;; <span class="keyword">do</span></span><br><span class="line">  redis-server /redis/<span class="variable">$&#123;port&#125;</span>/redis.conf</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>创建集群</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create \</span><br><span class="line">  127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 \</span><br><span class="line">  127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 \</span><br><span class="line">  --cluster-replicas 1 \</span><br><span class="line">  --cluster-yes</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>验证集群</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查集群状态</span></span><br><span class="line">redis-cli -p 6379 cluster nodes | grep master</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 测试数据分布</span></span><br><span class="line">redis-cli -c -p 6379 <span class="built_in">set</span> foo bar</span><br></pre></td></tr></table></figure><h4 id="生产环境建议"><a class="markdownIt-Anchor" href="#生产环境建议"></a> 生产环境建议</h4><ol><li><p><strong>节点规划</strong>：</p><ul><li>至少3个物理机部署</li><li>每个物理机部署主从节点对</li><li>预留30%内存用于故障转移</li></ul></li><li><p><strong>监控指标</strong>：</p><ul><li>槽分布均衡性</li><li>节点间延迟</li><li>故障转移次数</li><li>集群状态变化</li></ul></li><li><p><strong>运维操作</strong>：</p><ul><li>使用 <code>redis-cli --cluster reshard</code> 进行槽迁移</li><li>定期执行 <code>CLUSTER REPLICATE</code> 调整拓扑</li><li>备份时使用 <code>CLUSTER SAVECONFIG</code></li></ul></li></ol><h2 id="五-redis-同步机制的常见问题与优化方案"><a class="markdownIt-Anchor" href="#五-redis-同步机制的常见问题与优化方案"></a> 五、Redis 同步机制的常见问题与优化方案</h2><h3 id="51-问题1全量复制频繁触发"><a class="markdownIt-Anchor" href="#51-问题1全量复制频繁触发"></a> 5.1 问题1：全量复制频繁触发</h3><h4 id="现象表现"><a class="markdownIt-Anchor" href="#现象表现"></a> 现象表现</h4><p>从节点频繁断开与重连，每次重连都触发全量复制(RDB文件传输)，导致主节点CPU和网络带宽占用过高，影响正常业务请求处理。监控中可观察到主节点CPU使用率周期性飙升，网络出口流量激增。</p><h4 id="原因分析"><a class="markdownIt-Anchor" href="#原因分析"></a> 原因分析</h4><ol><li><strong>复制缓冲区过期</strong>：从节点断线时间超过repl-backlog-ttl(默认3600秒)后，复制积压缓冲区被清空，无法支持增量复制</li><li><strong>缓冲区容量不足</strong>：复制积压缓冲区(repl-backlog-size)设置过小(默认16MB)，断线期间的写操作超出缓冲区容量</li><li><strong>主节点标识变更</strong>：主节点runid因重启等原因变更，导致从节点保存的replid与主节点不一致</li><li><strong>网络环境不稳定</strong>：网络抖动或带宽不足导致连接频繁中断</li></ol><h4 id="优化方案"><a class="markdownIt-Anchor" href="#优化方案"></a> 优化方案</h4><ol><li><p><strong>调整缓冲区参数</strong>：</p><ul><li>将repl-backlog-size从16MB调整为64-128MB(根据业务写入量计算：缓冲区大小=平均写入速率×最大预期断线时间)</li><li>将repl-backlog-ttl从3600秒延长至86400秒(1天)</li></ul></li><li><p><strong>保障主节点稳定性</strong>：</p><ul><li>主节点配置appendonly yes，开启AOF持久化</li><li>使用config set命令动态调整参数，避免重启</li><li>部署主节点高可用方案(如哨兵)</li></ul></li><li><p><strong>网络优化</strong>：</p><ul><li>主从节点部署在同一机房或可用区</li><li>使用专线连接跨机房节点</li><li>避免在网络拥堵时段进行部署或维护</li></ul></li><li><p><strong>监控与告警</strong>：</p><ul><li>监控info replication中的connected_slaves和master_repl_offset</li><li>设置全量复制次数阈值告警</li></ul></li></ol><h3 id="52-问题2从节点同步延迟高"><a class="markdownIt-Anchor" href="#52-问题2从节点同步延迟高"></a> 5.2 问题2：从节点同步延迟高</h3><h4 id="现象表现-2"><a class="markdownIt-Anchor" href="#现象表现-2"></a> 现象表现</h4><p>从节点数据与主节点差距较大，通过info replication查看master_repl_offset与slave_repl_offset差值持续增大，从节点读取到旧数据。在电商秒杀等高并发场景下，可能导致库存超卖等问题。</p><h4 id="原因分析-2"><a class="markdownIt-Anchor" href="#原因分析-2"></a> 原因分析</h4><ol><li><strong>主节点写入压力大</strong>：QPS过高导致命令传播不及时</li><li><strong>TCP缓冲延迟</strong>：repl-disable-tcp-nodelay设为no(默认)时，TCP会缓冲数据导致延迟</li><li><strong>从节点性能瓶颈</strong>：<ul><li>CPU资源不足，无法及时处理命令</li><li>内存不足，频繁触发swap</li><li>磁盘IO性能差(RDB加载慢)</li></ul></li><li><strong>从节点数量过多</strong>：单个主节点挂载过多从节点(&gt;5个)</li></ol><h4 id="优化方案-2"><a class="markdownIt-Anchor" href="#优化方案-2"></a> 优化方案</h4><ol><li><p><strong>网络传输优化</strong>：</p><ul><li>从节点配置repl-disable-tcp-nodelay yes</li><li>调整TCP内核参数(net.ipv4.tcp_slow_start_after_idle=0)</li></ul></li><li><p><strong>架构优化</strong>：</p><ul><li>使用Redis Cluster分散写入压力</li><li>实现读写分离，将读请求分散到多个从节点</li><li>限制单个主节点的从节点数量(建议≤5)</li></ul></li><li><p><strong>硬件升级</strong>：</p><ul><li>为从节点配置多核CPU(≥8核)</li><li>使用SSD替代HDD</li><li>增加内存容量，避免swap</li></ul></li><li><p><strong>监控措施</strong>：</p><ul><li>实时监控slave_repl_offset差值</li><li>设置延迟阈值告警(如&gt;100MB)</li></ul></li></ol><h3 id="53-问题3主从数据不一致"><a class="markdownIt-Anchor" href="#53-问题3主从数据不一致"></a> 5.3 问题3：主从数据不一致</h3><h4 id="现象表现-3"><a class="markdownIt-Anchor" href="#现象表现-3"></a> 现象表现</h4><p>主节点执行写命令后，部分从节点未同步该命令，导致主从数据差异。通过redis-cli的diff命令可以检测到不一致的键值，在金融交易等场景可能导致严重问题。</p><h4 id="原因分析-3"><a class="markdownIt-Anchor" href="#原因分析-3"></a> 原因分析</h4><ol><li><strong>异步复制特性</strong>：Redis默认采用异步复制，主节点宕机可能导致数据丢失</li><li><strong>从节点误写入</strong>：replica-read-only配置为no(默认yes)时，从节点可能被误写入</li><li><strong>网络分区</strong>：部分从节点长时间无法连接主节点</li><li><strong>命令传播失败</strong>：主节点在命令传播过程中崩溃</li></ol><h4 id="优化方案-3"><a class="markdownIt-Anchor" href="#优化方案-3"></a> 优化方案</h4><ol><li><strong>一致性配置</strong>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-replicas-to-write 2</span><br><span class="line">min-replicas-max-lag 10</span><br></pre></td></tr></table></figure><p>表示至少2个从节点延迟不超过10秒才允许写入</p><ol start="2"><li><p><strong>从节点保护</strong>：</p><ul><li>强制所有从节点配置replica-read-only yes</li><li>定期检查从节点配置</li></ul></li><li><p><strong>高可用部署</strong>：</p><ul><li>部署Redis Sentinel自动故障转移</li><li>使用Redis Cluster分区容错</li><li>跨机房部署时考虑网络分区场景</li></ul></li><li><p><strong>数据校验机制</strong>：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群模式检查</span></span><br><span class="line">redis-cli --cluster check &lt;host&gt;:&lt;port&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 主从数据对比</span></span><br><span class="line">redis-cli -h master --scan | <span class="keyword">while</span> <span class="built_in">read</span> key; <span class="keyword">do</span></span><br><span class="line">  diff=$(redis-cli -h master GET <span class="string">&quot;<span class="variable">$key</span>&quot;</span> | diff - &lt;(redis-cli -h slave GET <span class="string">&quot;<span class="variable">$key</span>&quot;</span>))</span><br><span class="line">  [ -n <span class="string">&quot;<span class="variable">$diff</span>&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$key</span>: <span class="variable">$diff</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ol start="5"><li><p><strong>定期修复</strong>：</p><ul><li>设置定时任务校验数据一致性</li><li>发现不一致时触发从节点resync</li></ul></li></ol><h3 id="54-问题4集群模式哈希槽迁移导致同步中断"><a class="markdownIt-Anchor" href="#54-问题4集群模式哈希槽迁移导致同步中断"></a> 5.4 问题4：集群模式哈希槽迁移导致同步中断</h3><h4 id="现象表现-4"><a class="markdownIt-Anchor" href="#现象表现-4"></a> 现象表现</h4><p>在Redis Cluster扩容/缩容时，执行CLUSTER SETSLOT MIGRATING/IMPORTING命令迁移哈希槽过程中，部分从节点同步中断，客户端请求返回MOVED/ASK重定向错误。</p><h4 id="原因分析-4"><a class="markdownIt-Anchor" href="#原因分析-4"></a> 原因分析</h4><ol><li><strong>数据变更频繁</strong>：迁移过程中大量键被修改，增量复制压力大</li><li><strong>网络波动</strong>：迁移期间网络不稳定导致连接中断</li><li><strong>资源竞争</strong>：迁移过程占用大量CPU和网络资源</li><li><strong>配置不一致</strong>：迁移后集群拓扑信息未及时同步</li></ol><h4 id="优化方案-4"><a class="markdownIt-Anchor" href="#优化方案-4"></a> 优化方案</h4><ol><li><p><strong>迁移时机选择</strong>：</p><ul><li>选择业务低峰期(如凌晨2-4点)执行迁移</li><li>监控QPS和系统负载，在负载较低时操作</li></ul></li><li><p><strong>参数调优</strong>：</p><ul><li>迁移前调大repl-backlog-size(如调整为256MB)</li><li>设置cluster-node-timeout(默认15秒)为更合理的值</li></ul></li><li><p><strong>迁移过程控制</strong>：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分批迁移键空间</span></span><br><span class="line">redis-cli --cluster rebalance \</span><br><span class="line">  --cluster-weight node1=1 node2=0 \</span><br><span class="line">  --cluster-use-empty-masters</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>监控与恢复</strong>：</p><ul><li>使用cluster slots实时监控迁移进度</li><li>迁移完成后检查所有节点cluster_state状态</li><li>对同步中断的从节点执行cluster failover强制重新同步</li></ul></li><li><p><strong>客户端处理</strong>：</p><ul><li>客户端实现ASK/MOVED重试逻辑</li><li>使用Redis集群代理屏蔽复杂度</li></ul></li></ol><h2 id="六-redis-同步机制的选型建议"><a class="markdownIt-Anchor" href="#六-redis-同步机制的选型建议"></a> 六、Redis 同步机制的选型建议</h2><h4 id="1-主从复制replication"><a class="markdownIt-Anchor" href="#1-主从复制replication"></a> 1. 主从复制（Replication）</h4><p><strong>适用场景</strong>：</p><ul><li>单机扩展、读写分离</li><li>数据备份容灾</li><li>测试/开发环境</li></ul><p><strong>推荐方案</strong>： 主从复制 + 读写分离（1主多从）</p><p><strong>优势</strong>：</p><ul><li>配置简单（通过replicaof命令即可完成）</li><li>性能开销低（异步复制）</li><li>从节点可分担读请求（如QPS 10万+的场景）</li></ul><p><strong>劣势</strong>：</p><ul><li>主节点宕机需人工切换（需要运维介入）</li><li>可用性较低（无自动故障转移）</li><li>数据延迟（异步复制导致）</li></ul><p><strong>典型应用</strong>： 电商商品详情页缓存、新闻资讯类应用</p><h4 id="2-哨兵模式sentinel"><a class="markdownIt-Anchor" href="#2-哨兵模式sentinel"></a> 2. 哨兵模式（Sentinel）</h4><p><strong>适用场景</strong>：</p><ul><li>高可用需求</li><li>自动故障转移</li><li>7x24小时服务</li></ul><p><strong>推荐方案</strong>： 至少3个哨兵节点+1主2从</p><p><strong>优势</strong>：</p><ul><li>自动监控和故障转移（30秒内完成切换）</li><li>支持通知机制（可通过API对接监控系统）</li><li>配置中心（自动更新客户端连接信息）</li></ul><p><strong>劣势</strong>：</p><ul><li>仅支持单主架构（写入瓶颈）</li><li>无法解决数据分片问题</li><li>脑裂问题需要特殊处理</li></ul><p><strong>配置示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br></pre></td></tr></table></figure><h4 id="3-集群模式cluster"><a class="markdownIt-Anchor" href="#3-集群模式cluster"></a> 3. 集群模式（Cluster）</h4><p><strong>适用场景</strong>：</p><ul><li>大数据量（TB级）</li><li>高并发写入</li><li>需要水平扩展</li></ul><p><strong>推荐方案</strong>： 至少3主3从（官方推荐）</p><p><strong>优势</strong>：</p><ul><li>自动数据分片（16384个slot）</li><li>支持水平扩展（可动态增删节点）</li><li>高可用（主从自动切换）</li></ul><p><strong>劣势</strong>：</p><ul><li>配置复杂（需要规划槽位分配）</li><li>客户端需要支持集群协议</li><li>跨slot操作受限（如事务、Lua脚本）</li></ul><p><strong>性能指标</strong>：</p><ul><li>单节点：8-10万QPS</li><li>集群：线性扩展（如10节点可达80-100万QPS）</li></ul><h4 id="最终建议"><a class="markdownIt-Anchor" href="#最终建议"></a> 最终建议：</h4><h5 id="中小规模业务数据量-10gb读多写少"><a class="markdownIt-Anchor" href="#中小规模业务数据量-10gb读多写少"></a> 中小规模业务（数据量 &lt;10GB，读多写少）</h5><p><strong>方案</strong>：主从复制 + 哨兵模式 <strong>实施要点</strong>：</p><ol><li>部署1主2从架构</li><li>配置3个哨兵节点</li><li>设置合理的down-after-milliseconds（建议5000ms）</li><li>客户端实现自动重连机制</li></ol><h5 id="大规模业务数据量-10gb高并发"><a class="markdownIt-Anchor" href="#大规模业务数据量-10gb高并发"></a> 大规模业务（数据量 &gt; 10GB，高并发）</h5><p><strong>方案</strong>：集群模式 <strong>实施步骤</strong>：</p><ol><li>使用redis-cli --cluster create初始化集群</li><li>确保每个主节点有1-2个从节点</li><li>配置cluster-require-full-coverage为no</li><li>监控集群状态（cluster nodes/cluster info）</li></ol><h5 id="对数据一致性要求极高的业务如金融支付"><a class="markdownIt-Anchor" href="#对数据一致性要求极高的业务如金融支付"></a> 对数据一致性要求极高的业务（如金融支付）</h5><p><strong>增强方案</strong>：</p><ol><li>在集群模式基础上：<ul><li>设置min-replicas-to-write 2</li><li>配置min-replicas-max-lag 10</li></ul></li><li>定期校验：<ul><li>使用redis-check-aof工具</li><li>实现CRC校验机制</li></ul></li><li>建议搭配：<ul><li>持久化采用AOF+fsync everysec</li><li>部署跨机房容灾方案</li></ul></li></ol>]]></content>
    
    
    <summary type="html">Redis 同步机制解析</summary>
    
    
    
    <category term="数据库" scheme="http://www.formeasy.cc/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="http://www.formeasy.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 解锁：C++ 实战深度探索 Set 数据类型</title>
    <link href="http://www.formeasy.cc/2025/10/05/Redis/Redis%20%E8%A7%A3%E9%94%81%EF%BC%9AC++%20%E5%AE%9E%E6%88%98%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%20Set%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.formeasy.cc/2025/10/05/Redis/Redis%20%E8%A7%A3%E9%94%81%EF%BC%9AC++%20%E5%AE%9E%E6%88%98%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%20Set%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-10-05T14:07:35.000Z</published>
    <updated>2025-10-05T14:20:08.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>欢迎来到 Redis Set 的终极指南。如果您曾需要管理一组独一无二的元素集合——无论是用户 ID、文章标签还是邮件地址——并希望以闪电般的速度对其执行强大的集合运算，那么您来对地方了。Redis Set 绝不是一个简单的列表，它是一种精妙的数据结构，将数学中强大的集合理论直接带入您的高性能数据库中。</p><p>在本文中，我们将从最基础的概念讲起，逐步深入到高级的实际应用。我们将使用优秀的 C++ 库 <code>redis-plus-plus</code> 来演示所有示例，并逐行剖析代码。无论您是 C++ 开发者、后端工程师，还是仅仅对 Redis 感到好奇，读完本文，您都将深刻理解是什么让 Set 成为 Redis 中功能最丰富的工具之一。</p><h3 id="redis-set-究竟是什么"><a class="markdownIt-Anchor" href="#redis-set-究竟是什么"></a> Redis Set 究竟是什么？</h3><p>在我们深入代码之前，先来建立一个清晰的思维模型。想象你有一个<strong>魔力袋</strong>，你可以往里面扔东西，但这个袋子有两条非常特殊的规则：</p><ol><li><strong>强制保持唯一</strong>：这个袋子会自动拒绝重复的物品。如果你想把一个标有“A”的弹珠放进一个已经有“A”弹珠的袋子里，它会阻止你，确保袋子里每样东西都只有一个。</li><li><strong>顺序毫不在意</strong>：当你从袋子里往外取东西时，它们的顺序是完全随机的。袋子不记得到底是按什么顺序把东西放进去的。</li></ol><p>这个“魔力袋”正是 Redis Set 的精准比喻：一个<strong>无序的、元素唯一的字符串集合</strong>。这个简单的定义是其强大功能的基石，使其能够以惊人的速度进行成员资格检查、数量统计以及诸如交集、并集等复杂的服务器端运算。</p><hr /><h3 id="第一章基础入门-创建和查看你的第一个-set"><a class="markdownIt-Anchor" href="#第一章基础入门-创建和查看你的第一个-set"></a> 第一章：基础入门 - 创建和查看你的第一个 Set</h3><p>让我们从最基本的操作开始：如何向一个 Set 添加元素，以及如何查看它的全部内容。为此，我们将使用 <code>SADD</code> 和 <code>SMEMBERS</code> 这两个命令。</p><h4 id="sadd向集合中添加成员"><a class="markdownIt-Anchor" href="#sadd向集合中添加成员"></a> <code>SADD</code>：向集合中添加成员</h4><p><code>SADD</code> 是您向 Set 中添加一个或多个元素的主要工具。如果某个元素已经存在，Redis 会优雅地忽略它。该命令的返回值是_新_成功添加的元素的数量。</p><h4 id="smembers获取所有成员"><a class="markdownIt-Anchor" href="#smembers获取所有成员"></a> <code>SMEMBERS</code>：获取所有成员</h4><p><code>SMEMBERS</code> 的功能正如其名：返回指定 Set 中的所有成员。这对于获取整个集合非常有用，但请注意：<strong>在拥有数百万元素的超大 Set 上使用此命令可能会暂时阻塞您的 Redis 服务器</strong>，因为它需要时间来准备所有数据。我们将在后续章节中讨论更安全的替代方案 <code>SSCAN</code>。</p><h4 id="c-实战sadd-与-smembers"><a class="markdownIt-Anchor" href="#c-实战sadd-与-smembers"></a> C++ 实战：<code>sadd</code> 与 <code>smembers</code></h4><p>现在，让我们来分析一段代码，它演示了这些基础操作。</p><p><img src="ecfbf686c86c863f90654a62651e1aeb.png" alt="image.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入必要的头文件...</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个辅助函数，用于打印容器内容</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintContainer</span><span class="params">(<span class="type">const</span> T&amp; container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : container) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(sw::redis::Redis&amp; redis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sadd 和 smembers&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 清空数据库，确保一个干净的测试环境</span></span><br><span class="line">    redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 一次添加一个元素</span></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用初始化列表，一次添加多个元素</span></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key&quot;</span>, &#123;<span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用迭代器，从另一个容器中添加多个元素</span></span><br><span class="line">    std::set&lt;std::string&gt; elems = &#123;<span class="string">&quot;555&quot;</span>, <span class="string">&quot;666&quot;</span>, <span class="string">&quot;777&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 返回值是成功插入了多少个元素</span></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key&quot;</span>, elems.<span class="built_in">begin</span>(), elems.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 现在，让我们获取所有元素 ---</span></span><br><span class="line">    std::set&lt;std::string&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为我们的 C++ set 构建一个插入迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">inserter</span>(result, result.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 Redis set 中获取所有成员，并插入到我们的 C++ set 中</span></span><br><span class="line">    redis.<span class="built_in">smembers</span>(<span class="string">&quot;key&quot;</span>, it);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintContainer</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码剖析"><a class="markdownIt-Anchor" href="#代码剖析"></a> 代码剖析：</h5><ol><li><strong><code>redis.flushall()</code></strong>：我们首先清空整个 Redis 数据库，以确保测试环境的纯净。</li><li><strong>单个元素 <code>sadd</code></strong>：<code>redis.sadd(&quot;key&quot;, &quot;111&quot;);</code> 将字符串 “111” 添加到名为 <code>key</code> 的 Set 中。由于 Set 原本是空的，此命令返回 <code>1</code>。</li><li><strong>初始化列表 <code>sadd</code></strong>：<code>redis.sadd(&quot;key&quot;, &#123;&quot;222&quot;, &quot;333&quot;, &quot;444&quot;&#125;);</code> 展示了 <code>redis-plus-plus</code> 库的一个便捷特性，允许您一次性添加多个元素。这比发送三个独立的命令效率更高。此调用将返回 <code>3</code>。</li><li><strong>基于迭代器的 <code>sadd</code></strong>：在这里，我们先填充了一个 C++ 的 <code>std::set</code>，然后使用它的迭代器（<code>elems.begin()</code>, <code>elems.end()</code>）将其所有元素添加到 Redis 的 Set 中。这对于将现有 C++ 容器中的数据同步到 Redis 非常有用。</li><li><strong>使用 <code>smembers</code> 获取数据</strong>：<ul><li>我们创建了一个 <code>std::set&lt;string&gt; result;</code> 来存放从 Redis 返回的数据。在客户端使用 <code>std::set</code> 是一个绝佳选择，因为它不仅 mirroring（镜像）了 Redis Set 的唯一性，还能自动对元素进行排序，便于我们进行可预测的展示。</li><li><code>auto it = std::inserter(result, result.end());</code> 是至关重要的一行。我们需要一种方式告诉 <code>redis-plus-plus</code> 应该把接收到的元素_放在哪里_。<code>inserter</code> 是一种特殊的迭代器，当你给它赋值时，它会调用其关联容器的 <code>insert()</code> 方法。</li><li><code>redis.smembers(&quot;key&quot;, it);</code> 执行命令。<code>redis-plus-plus</code> 获取 <code>key</code> 中的所有成员，并使用我们的迭代器 <code>it</code> 将它们逐一插入到 <code>result</code> 集合中。</li></ul></li></ol><h5 id="c-关键概念inserter-vs-back_inserter"><a class="markdownIt-Anchor" href="#c-关键概念inserter-vs-back_inserter"></a> C++ 关键概念：<code>inserter</code> vs <code>back_inserter</code></h5><p>在原始笔记中，有一个关键的区别被强调了出来：</p><ul><li><code>std::back_inserter</code> 创建一个调用 <code>push_back()</code> 的迭代器。它适用于 <code>std::vector</code>, <code>std::list</code>, <code>std::deque</code> 等容器。</li><li><code>std::set</code> <strong>没有</strong> <code>push_back()</code> 方法，因为它需要维护内部的排序。因此，对于 <code>std::set</code>，我们<strong>必须</strong>使用 <code>std::inserter</code>，它会调用 <code>insert()</code> 方法。</li></ul><h5 id="预测输出"><a class="markdownIt-Anchor" href="#预测输出"></a> 预测输出：</h5><p><code>PrintContainer</code> 函数将打印 <code>result</code> 集合的内容。由于 <code>std::set</code> 会对其元素进行排序，输出将是按字母/数字顺序排列的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sadd 和 smembers</span><br><span class="line">111 222 333 444 555 666 777</span><br></pre></td></tr></table></figure><hr /><h3 id="第二章深入探索-检查与修改你的-set"><a class="markdownIt-Anchor" href="#第二章深入探索-检查与修改你的-set"></a> 第二章：深入探索 - 检查与修改你的 Set</h3><p>既然我们知道了如何构建一个 Set，接下来让我们学习如何查询它的属性并执行基本的修改。这些命令是 Set 日常操作的核心，并且它们都快得令人难以置信。</p><h4 id="sismember这个元素存在吗-时间复杂度-o1"><a class="markdownIt-Anchor" href="#sismember这个元素存在吗-时间复杂度-o1"></a> <code>SISMEMBER</code>：这个元素存在吗？ (时间复杂度 O(1))</h4><p>这是 Set 命令库中最强大的命令之一。<code>SISMEMBER</code> 检查一个特定元素是否是 Set 的成员。如果存在，返回 <code>1</code> (true)；如果不存在，返回 <code>0</code> (false)。它的性能是 <strong>O(1)</strong>，这意味着其速度是恒定的，不依赖于 Set 的大小。无论是在一个有10个元素的 Set 还是在一个有1000万个元素的 Set 中检查成员资格，花费的时间都是相同的。</p><h5 id="c-实战sismember"><a class="markdownIt-Anchor" href="#c-实战sismember"></a> C++ 实战：<code>sismember</code></h5><p><img src="9713b0a2a8a3beabcac12fcee436e93a.png" alt="image.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">(sw::redis::Redis&amp; redis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sismember&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key&quot;</span>, &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 &quot;111&quot; 是否是集合的成员</span></span><br><span class="line">    <span class="type">bool</span> result = redis.<span class="built_in">sismember</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result:&quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>剖析</strong>：我们创建一个 Set，然后使用 <code>sismember</code> 检查 “111” 是否存在。<code>redis-plus-plus</code> 库非常方便地将 Redis 返回的 <code>1</code> 或 <code>0</code> 直接映射为了 C++ 的 <code>bool</code> 类型。因为 “111” 确实在 Set 中，<code>result</code> 将为 <code>true</code>。</li><li><strong>应用场景</strong>：<ul><li><strong>标签系统</strong>：检查一篇博客文章是否已经被标记为 “DevOps”。</li><li><strong>权限控制</strong>：检查一个 <code>userID</code> 是否在 <code>admin_users</code> 这个 Set 中。</li><li><strong>唯一性事件</strong>：检查用户是否已经执行了某个一次性操作（例如，“voted_on_poll_123”）。</li></ul></li><li><strong>预测输出</strong>：当 <code>bool true</code> 被输出到 <code>cout</code> 时，通常会显示为 <code>1</code>。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sismember</span><br><span class="line">result:1</span><br></pre></td></tr></table></figure><h4 id="scard集合里有多少元素-时间复杂度-o1"><a class="markdownIt-Anchor" href="#scard集合里有多少元素-时间复杂度-o1"></a> <code>SCARD</code>：集合里有多少元素？ (时间复杂度 O(1))</h4><p><code>SCARD</code> 代表 “Set Cardinality”（集合基数），它简单地返回一个 Set 中元素的数量。与 <code>SISMEMBER</code> 一样，这也是一个 <strong>O(1)</strong> 操作。Redis 内部维护了一个计数器，所以它不需要遍历所有元素就能告诉你总数。</p><h5 id="c-实战scard"><a class="markdownIt-Anchor" href="#c-实战scard"></a> C++ 实战：<code>scard</code></h5><p><img src="dc1d1e20840d157e1a1af23995505fcf.png" alt="image.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">(sw::redis::Redis&amp; redis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;scard&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向集合中添加4个唯一元素</span></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key&quot;</span>, &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取集合中的元素个数</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = redis.<span class="built_in">scard</span>(<span class="string">&quot;key&quot;</span>); <span class="comment">// 返回 4</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result:&quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>剖析</strong>：我们添加了四个元素，然后调用 <code>scard</code>。命令返回了计数 <code>4</code>。</li><li><strong>应用场景</strong>：<ul><li><strong>在线用户</strong>：跟踪已登录的独立用户数量。</li><li><strong>点赞计数</strong>：快速显示一张照片获得的独立点赞数。</li><li><strong>数据分析</strong>：统计今天访问网站的独立 IP 地址数量。</li></ul></li><li><strong>预测输出</strong>：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scard</span><br><span class="line">result:4</span><br></pre></td></tr></table></figure><h4 id="spop随机移除并返回一个元素"><a class="markdownIt-Anchor" href="#spop随机移除并返回一个元素"></a> <code>SPOP</code>：随机移除并返回一个元素</h4><p><code>SPOP</code> 是一个既有趣又实用的命令。它会从 Set 中<strong>随机</strong>选择一个元素，将其<strong>移除</strong>，然后<strong>返回</strong>给你。这是一种“破坏性读取”，因为元素在被读取后就从集合中消失了。</p><h5 id="c-实战spop"><a class="markdownIt-Anchor" href="#c-实战spop"></a> C++ 实战：<code>spop</code></h5><p><img src="d468a41d718f4bc1c582e2922f375a16.png" alt="image.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">(sw::redis::Redis&amp; redis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;spop&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key&quot;</span>, &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机弹出一个元素，spop 的返回值是 Optional&lt;string&gt;</span></span><br><span class="line">    <span class="keyword">auto</span> result = redis.<span class="built_in">spop</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 因为返回值是 Optional，我们通过 .value() 来获取原始的 string 内容</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;result:&quot;</span> &lt;&lt; result.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;result is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>剖析</strong>：<ul><li><code>auto result = redis.spop(&quot;key&quot;);</code> 执行命令。</li><li><code>redis-plus-plus</code> 将返回值包装在 <code>sw::redis::Optional&lt;std::string&gt;</code> 中。这是因为如果你对一个空 Set 执行 <code>spop</code>，Redis 会返回 <code>nil</code>（空）。<code>Optional</code> 类型可以优雅地处理这种情况，避免空指针等问题。</li><li><code>if (result)</code> 检查 <code>Optional</code> 对象是否真的包含一个值。在我们的例子中，由于 Set 非空，它肯定会弹出一个元素，所以条件为真。</li><li><code>result.value()</code> 从 <code>Optional</code> 中提取出实际的 <code>std::string</code> 值。</li></ul></li><li><strong>核心特性：随机性</strong>：<code>SPOP</code> 最大的特点就是随机。这意味着每次运行这段代码，得到的结果都可能不同。它非常适合需要随机处理任务的场景。</li><li><strong>应用场景</strong>：<ul><li><strong>抽奖系统</strong>：从参与用户 Set 中随机抽取一名中奖者。</li><li><strong>任务队列</strong>：从待处理任务池中随机分配一个任务给工作进程。</li><li><strong>在线匹配</strong>：从等待匹配的玩家池中随机抽取一个进行游戏。</li></ul></li><li><strong>预测输出</strong>：输出是<strong>不确定</strong>的，可能是以下四种情况之一：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 可能的输出 1</span><br><span class="line">spop</span><br><span class="line">result:111</span><br><span class="line"></span><br><span class="line">// 可能的输出 2</span><br><span class="line">spop</span><br><span class="line">result:333</span><br></pre></td></tr></table></figure><hr /><h3 id="第三章集合的威力-集合运算"><a class="markdownIt-Anchor" href="#第三章集合的威力-集合运算"></a> 第三章：集合的威力 - 集合运算</h3><p>这才是 Redis Set 真正大放异彩的地方。Redis 能够在服务器端以极高的效率执行集合的<strong>交集 (intersection)</strong>、<strong>并集 (union)</strong> 和<strong>差集 (difference)</strong> 运算，避免了将大量数据传输到客户端再进行计算的开销。</p><h4 id="交集运算sinter-sinterstore"><a class="markdownIt-Anchor" href="#交集运算sinter-sinterstore"></a> 交集运算：<code>SINTER</code> &amp; <code>SINTERSTORE</code></h4><p>交集运算会找出所有给定的 Set 中<strong>共同存在</strong>的元素。</p><ul><li><code>SINTER</code>: 计算交集并<strong>直接返回</strong>给客户端。</li><li><code>SINTERSTORE</code>: 计算交集，但<strong>不返回</strong>，而是将结果<strong>存储在一个新的目标 Set 中</strong>。</li></ul><h5 id="c-实战sinter-求交集并返回"><a class="markdownIt-Anchor" href="#c-实战sinter-求交集并返回"></a> C++ 实战：<code>sinter</code> (求交集并返回)</h5><p><img src="6b72b60fe1898e72ae64816ea8a5b213.png" alt="image.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test5</span><span class="params">(sw::redis::Redis&amp; redis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里的 cout 应该是 &quot;sinter&quot;，一个小笔误</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sinter&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key1&quot;</span>, &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>&#125;);</span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key2&quot;</span>, &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;444&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    std::set&lt;std::string&gt; result;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">inserter</span>(result, result.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求交集涉及多个 key，我们使用初始化列表来描述</span></span><br><span class="line">    <span class="comment">// 将 &quot;key1&quot; 和 &quot;key2&quot; 的交集插入到 result 中</span></span><br><span class="line">    redis.<span class="built_in">sinter</span>(&#123;<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;key2&quot;</span>&#125;, it);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintContainer</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>剖析</strong>：<ul><li><code>key1</code> 包含 <code>&#123;&quot;111&quot;, &quot;222&quot;, &quot;333&quot;, &quot;444&quot;&#125;</code>。</li><li><code>key2</code> 包含 <code>&#123;&quot;111&quot;, &quot;222&quot;, &quot;444&quot;&#125;</code>。</li><li><code>redis.sinter(&#123;&quot;key1&quot;, &quot;key2&quot;&#125;, it);</code> 命令计算出两个集合的共同成员是 <code>&#123;&quot;111&quot;, &quot;222&quot;, &quot;444&quot;&#125;</code>，并通过迭代器将它们存入 C++ 的 <code>result</code> 集合中。</li></ul></li><li><strong>应用场景</strong>：<ul><li><strong>共同好友</strong>：计算用户A的好友列表和用户B的好友列表的交集。</li><li><strong>内容推荐</strong>：找出同时对 “科幻” 和 “悬疑” 标签感兴趣的用户。</li></ul></li><li><strong>预测输出</strong>：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sinter</span><br><span class="line">111 222 444</span><br></pre></td></tr></table></figure><h5 id="c-实战sinterstore-求交集并存储"><a class="markdownIt-Anchor" href="#c-实战sinterstore-求交集并存储"></a> C++ 实战：<code>sinterstore</code> (求交集并存储)</h5><p><img src="39517223411c5e3c73a08b152ce72cf3.png" alt="image.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test6</span><span class="params">(sw::redis::Redis&amp; redis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sinterstore&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    redis.<span class="built_in">flushall</span>();</span><br><span class="line"></span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key1&quot;</span>, &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>&#125;);</span><br><span class="line">    redis.<span class="built_in">sadd</span>(<span class="string">&quot;key2&quot;</span>, &#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;444&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定一个 destination (&quot;key3&quot;)，将交集结果存储到其中</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> len = redis.<span class="built_in">sinterstore</span>(<span class="string">&quot;key3&quot;</span>, &#123;<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;key2&quot;</span>&#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;len:&quot;</span> &lt;&lt; len &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 &quot;key3&quot; 中的元素以验证结果</span></span><br><span class="line">    std::set&lt;std::string&gt; result;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">inserter</span>(result, result.<span class="built_in">end</span>());</span><br><span class="line">    redis.<span class="built_in">smembers</span>(<span class="string">&quot;key3&quot;</span>, it);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintContainer</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>剖析</strong>：<ul><li><code>redis.sinterstore(&quot;key3&quot;, &#123;&quot;key1&quot;, &quot;key2&quot;&#125;);</code> 计算出交集 <code>&#123;&quot;111&quot;, &quot;222&quot;&#125;</code>，然后将这个结果存入一个全新的 Set <code>key3</code> 中。如果 <code>key3</code> 已存在，它将被覆盖。</li><li>该命令返回新生成的 <code>key3</code> 集合的元素数量，即 <code>2</code>。所以 <code>len</code> 的值为 <code>2</code>。</li><li>后续的 <code>smembers</code> 验证了 <code>key3</code> 的内容确实是正确的交集结果。</li></ul></li><li><strong>应用场景</strong>：当你需要<strong>缓存</strong>或<strong>复用</strong>交集计算结果时，<code>SINTERSTORE</code> 非常有用。例如，为一组用户预先计算出他们共同喜欢的商品列表。</li><li><strong>预测输出</strong>：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore</span><br><span class="line">len:2</span><br><span class="line">111 222</span><br></pre></td></tr></table></figure><hr /><h3 id="第四章超越基础-更多强大的-set-命令"><a class="markdownIt-Anchor" href="#第四章超越基础-更多强大的-set-命令"></a> 第四章：超越基础 - 更多强大的 Set 命令</h3><p>我们已经覆盖了所提供代码中的所有命令，但 Redis Set 的能力远不止于此。为了成为真正的 Set 大师，让我们来了解一下其他一些极其有用的命令。</p><h4 id="并集运算sunion-sunionstore"><a class="markdownIt-Anchor" href="#并集运算sunion-sunionstore"></a> 并集运算：<code>SUNION</code> &amp; <code>SUNIONSTORE</code></h4><p>并集运算返回所有给定集合的全部<strong>不重复</strong>的元素。</p><ul><li><strong>命令</strong>：<code>SUNION key [key ...]</code> 和 <code>SUNIONSTORE destination key [key ...]</code></li><li><strong>应用场景</strong>：<ul><li><strong>好友圈</strong>：获取用户A的好友、用户B的好友和用户C的好友的完整、不重复的列表。</li><li><strong>权限合并</strong>：一个用户属于 “editor” 角色组和 “publisher” 角色组，通过并集可以得到该用户拥有的所有权限的集合。</li></ul></li></ul><h4 id="差集运算sdiff-sdiffstore"><a class="markdownIt-Anchor" href="#差集运算sdiff-sdiffstore"></a> 差集运算：<code>SDIFF</code> &amp; <code>SDIFFSTORE</code></h4><p>差集运算返回那些只存在于<strong>第一个</strong>集合中，但不在任何后续集合中的元素。</p><ul><li><strong>命令</strong>：<code>SDIFF key [key ...]</code> 和 <code>SDIFFSTORE destination key [key ...]</code></li><li><strong>应用场景</strong>：<ul><li><strong>好友推荐</strong>：找出我的好友中，有哪些还不是我朋友A的好友，从而可以向我推荐。</li><li><strong>内容去重</strong>：向用户展示新闻时，从“今日热点”中排除掉他“已读新闻”Set 中的内容。</li></ul></li></ul><h4 id="安全迭代sscan"><a class="markdownIt-Anchor" href="#安全迭代sscan"></a> 安全迭代：<code>SSCAN</code></h4><p>正如前文提到的，<code>SMEMBERS</code> 对于大集合是危险的。<code>SSCAN</code> 提供了安全的替代方案。它使用一个游标 (cursor) 来分批次地返回集合中的元素，每次只返回一小部分，绝不会阻塞服务器。</p><ul><li><strong>命令</strong>：<code>SSCAN key cursor [MATCH pattern] [COUNT count]</code></li><li><strong>工作方式</strong>：你用一个初始为 <code>0</code> 的游标开始第一次调用。Redis 返回下一批元素和一个新的游标。你用这个新的游标进行下一次调用，如此往复，直到返回的游标为 <code>0</code>，表示迭代完成。</li><li><strong>适用场景</strong>：任何需要遍历生产环境中大集合的操作，例如数据迁移、离线分析等。</li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>Redis Set 是一种看似简单却异常强大的数据结构。让我们回顾一下它的核心优势：</p><ul><li><strong>唯一性</strong>：自动处理数据去重，简化了应用逻辑。</li><li><strong>极速性能</strong>：绝大多数核心操作（增、删、查、计数）的时间复杂度都是 O(1)，性能与集合大小无关。</li><li><strong>强大的集合运算</strong>：能够在服务器端原子性地、高效地执行交、并、差集运算，极大地减少了网络开销和客户端的计算压力。</li></ul><p>从简单的在线用户统计，到复杂的社交网络好友关系分析，再到智能推荐系统，Redis Set 都能以其优雅和高效提供坚实的解决方案。希望通过本文的深度解析和 C++ 代码示例，您已经准备好在自己的项目中发挥 Redis Set 的真正威力了。</p>]]></content>
    
    
    <summary type="html">Redis 解锁：C++ 实战深度探索 Set 数据类型</summary>
    
    
    
    <category term="数据库" scheme="http://www.formeasy.cc/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="http://www.formeasy.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SQL 优化实战案例：从慢查询到高性能的完整指南</title>
    <link href="http://www.formeasy.cc/2025/10/05/MySQL/SQL%20%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E4%BB%8E%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/"/>
    <id>http://www.formeasy.cc/2025/10/05/MySQL/SQL%20%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E4%BB%8E%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</id>
    <published>2025-10-05T13:21:30.000Z</published>
    <updated>2025-10-05T13:55:55.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-常见-sql-性能问题概览"><a class="markdownIt-Anchor" href="#一-常见-sql-性能问题概览"></a> 📊 一、常见 SQL 性能问题概览</h2><h3 id="生产环境性能问题分布"><a class="markdownIt-Anchor" href="#生产环境性能问题分布"></a> 🚨 生产环境性能问题分布</h3><p>根据对 1000+ 生产环境慢查询的分析，常见问题比例如下：</p><p>索引问题：45%<br />JOIN优化：25%<br />全表扫描：15%<br />锁竞争：10%<br />其它：5%</p><h3 id="性能问题症状识别"><a class="markdownIt-Anchor" href="#性能问题症状识别"></a> 📈 性能问题症状识别</h3><p><strong>快速诊断指标</strong>：</p><ul><li><p><strong>查询时间</strong> &gt; 1秒：需要优化</p></li><li><p><strong>扫描行数</strong> &gt; 10000行：索引可能失效</p></li><li><p><strong>临时表使用</strong>：需要优化查询或索引</p></li><li><p><strong>文件排序</strong>：添加合适的索引</p></li></ul><h2 id="二-案例一慢查询优化实战"><a class="markdownIt-Anchor" href="#二-案例一慢查询优化实战"></a> ⚡ 二、案例一：慢查询优化实战</h2><h3 id="问题场景电商订单查询缓慢"><a class="markdownIt-Anchor" href="#问题场景电商订单查询缓慢"></a> 🎯 问题场景：电商订单查询缓慢</h3><p><strong>原始慢查询</strong>（执行时间：3.2秒）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1001</span> </span><br><span class="line">  <span class="keyword">AND</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> status <span class="keyword">IN</span> (<span class="string">&#x27;completed&#x27;</span>, <span class="string">&#x27;shipped&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="问题分析过程"><a class="markdownIt-Anchor" href="#问题分析过程"></a> 🔍 问题分析过程</h3><p><strong>执行计划分析</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1001</span> </span><br><span class="line">  <span class="keyword">AND</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> status <span class="keyword">IN</span> (<span class="string">&#x27;completed&#x27;</span>, <span class="string">&#x27;shipped&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>执行计划输出</strong>：</p><pre><code>+----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra                       |+----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+|  1 | SIMPLE      | orders | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 500000 |     1.00 | Using where; Using filesort |+----+-------------+--------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+</code></pre><p><strong>问题诊断</strong>：</p><ul><li><p>type: ALL：全表扫描 50 万行数据</p></li><li><p>Using filesort：文件排序，性能杀手</p></li><li><p>缺少合适索引</p></li></ul><h3 id="️-优化方案"><a class="markdownIt-Anchor" href="#️-优化方案"></a> 🛠️ 优化方案</h3><p><strong>创建复合索引</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据查询条件创建最优索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_status_date </span><br><span class="line"><span class="keyword">ON</span> orders(user_id, status, order_date);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 包含所有过滤字段和排序字段</span></span><br></pre></td></tr></table></figure><p><strong>优化后查询</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用覆盖索引优化</span></span><br><span class="line"><span class="keyword">SELECT</span> order_id, user_id, order_date, status, amount</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">1001</span> </span><br><span class="line">  <span class="keyword">AND</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> status <span class="keyword">IN</span> (<span class="string">&#x27;completed&#x27;</span>, <span class="string">&#x27;shipped&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="性能对比"><a class="markdownIt-Anchor" href="#性能对比"></a> 📊 性能对比</h3><table><thead><tr><th>策略</th><th>实现方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>无索引查询</strong></td><td>全表扫描 + 文件排序</td><td>实现简单，无需索引维护</td><td>性能极差，数据量大时不可用</td><td>小表查询（数据量 &lt; 1000 行）</td></tr><tr><td><strong>复合索引优化</strong></td><td>创建 <code>(user_id, status, order_date)</code> 复合索引</td><td>查询性能提升 64 倍，减少磁盘 I/O</td><td>需要额外存储空间，写入稍慢</td><td>中大型表，频繁查询条件固定</td></tr></tbody></table><p><strong>优化效果</strong>：</p><ul><li><p><strong>执行时间</strong>：3.2秒 → 0.05秒（<strong>64倍提升</strong>）</p></li><li><p><strong>扫描行数</strong>：500,000行 → 150行（<strong>3333倍提升</strong>）</p></li><li><p><strong>CPU使用</strong>：95% → 5%（<strong>19倍降低</strong>）</p></li></ul><h2 id="三-案例二索引深度优化"><a class="markdownIt-Anchor" href="#三-案例二索引深度优化"></a> 🔍 三、案例二：索引深度优化</h2><h3 id="问题场景用户搜索功能性能瓶颈"><a class="markdownIt-Anchor" href="#问题场景用户搜索功能性能瓶颈"></a> 🎯 问题场景：用户搜索功能性能瓶颈</h3><p><strong>原始查询</strong>（执行时间：2.1秒）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">&#x27;%john%&#x27;</span></span><br><span class="line">   <span class="keyword">OR</span> email <span class="keyword">LIKE</span> <span class="string">&#x27;%john%&#x27;</span></span><br><span class="line">   <span class="keyword">OR</span> phone <span class="keyword">LIKE</span> <span class="string">&#x27;%john%&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">50</span>;</span><br></pre></td></tr></table></figure><h3 id="索引问题分析"><a class="markdownIt-Anchor" href="#索引问题分析"></a> 🔍 索引问题分析</h3><p><strong>现有索引情况</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查现有索引</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> users;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出：</span></span><br><span class="line"><span class="comment">-- INDEX (username)  -- 前缀索引</span></span><br><span class="line"><span class="comment">-- INDEX (email)     -- 前缀索引  </span></span><br><span class="line"><span class="comment">-- INDEX (phone)     -- 前缀索引</span></span><br></pre></td></tr></table></figure><p><strong>执行计划分析</strong>：</p><pre><code>+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra                       |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+|  1 | SIMPLE      | users | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 100000 |    100.00 | Using where; Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+</code></pre><p><strong>问题根源</strong>：</p><ul><li><p>LIKE '%john%'导致索引失效</p></li><li><p>OR 条件合并导致全表扫描</p></li><li><p>多个单列索引未有效利用</p></li></ul><h3 id="️-优化策略"><a class="markdownIt-Anchor" href="#️-优化策略"></a> 🛠️ 优化策略</h3><p><strong>方案一：全文索引优化</strong>（MySQL 5.6+）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建全文索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users </span><br><span class="line"><span class="keyword">ADD</span> FULLTEXT idx_search_fields(username, email, phone);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用全文搜索</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(username, email, phone) AGAINST(<span class="string">&#x27;john&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">50</span>;</span><br></pre></td></tr></table></figure><p><strong>方案二：分词索引优化</strong>（兼容性更好）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加搜索专用字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> search_tags <span class="type">VARCHAR</span>(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> search_tags <span class="operator">=</span> CONCAT(username, <span class="string">&#x27; &#x27;</span>, email, <span class="string">&#x27; &#x27;</span>, phone);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建分词索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_search_tags <span class="keyword">ON</span> users(search_tags(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> search_tags <span class="keyword">LIKE</span> <span class="string">&#x27;john%&#x27;</span> </span><br><span class="line">   <span class="keyword">OR</span> search_tags <span class="keyword">LIKE</span> <span class="string">&#x27;% john%&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">50</span>;</span><br></pre></td></tr></table></figure><h3 id="优化方案对比"><a class="markdownIt-Anchor" href="#优化方案对比"></a> 📊 优化方案对比</h3><table><thead><tr><th>策略</th><th>实现方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>单列索引</strong></td><td>为每个字段创建独立索引</td><td>简单直观，维护方便</td><td>OR 条件无法有效利用，<code>LIKE '%xxx'</code> 模糊查询失效</td><td>精确查询，字段独立使用</td></tr><tr><td><strong>全文索引</strong></td><td>使用 <code>MATCH ... AGAINST</code> 语法</td><td>专业文本搜索，支持相关性排序</td><td>MySQL 5.6+ 才支持，中文分词需额外插件（如 <code>ngram</code>、<code>mmseg</code>）</td><td>大量文本搜索，CMS、论坛、博客系统</td></tr><tr><td><strong>分词索引</strong></td><td>创建搜索专用字段 + 前缀索引</td><td>兼容性好，<code>LIKE 'xxx%'</code> 模糊查询可用</td><td>需要维护额外字段，存在一定数据冗余</td><td>中小规模搜索，对兼容性要求高的业务场景</td></tr></tbody></table><p><strong>优化效果</strong>：</p><ul><li><strong>全文索引方案</strong>：2.1秒 → 0.08秒（<strong>26倍提升</strong>）</li><li><strong>分词索引方案</strong>：2.1秒 → 0.15秒（<strong>14倍提升</strong>）</li></ul><h2 id="四-案例三大表-join-优化"><a class="markdownIt-Anchor" href="#四-案例三大表-join-优化"></a> 🔗 四、案例三：大表 JOIN 优化</h2><h3 id="问题场景电商报表查询超时"><a class="markdownIt-Anchor" href="#问题场景电商报表查询超时"></a> 🎯 问题场景：电商报表查询超时</h3><p><strong>原始查询</strong>（执行时间：12.5秒）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    u.username,</span><br><span class="line">    o.order_id,</span><br><span class="line">    o.amount,</span><br><span class="line">    p.product_name,</span><br><span class="line">    c.category_name</span><br><span class="line"><span class="keyword">FROM</span> users u</span><br><span class="line"><span class="keyword">JOIN</span> orders o <span class="keyword">ON</span> u.user_id <span class="operator">=</span> o.user_id</span><br><span class="line"><span class="keyword">JOIN</span> order_items oi <span class="keyword">ON</span> o.order_id <span class="operator">=</span> oi.order_id</span><br><span class="line"><span class="keyword">JOIN</span> products p <span class="keyword">ON</span> oi.product_id <span class="operator">=</span> p.product_id</span><br><span class="line"><span class="keyword">JOIN</span> categories c <span class="keyword">ON</span> p.category_id <span class="operator">=</span> c.category_id</span><br><span class="line"><span class="keyword">WHERE</span> u.register_date <span class="operator">&gt;=</span> <span class="string">&#x27;2023-01-01&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> o.order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> o.amount <span class="operator">&gt;</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> o.order_date <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="join-问题分析"><a class="markdownIt-Anchor" href="#join-问题分析"></a> 🔍 JOIN 问题分析</h3><p><strong>表数据量分析</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 各表数据量</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="string">&#x27;users&#x27;</span> <span class="keyword">as</span> table_name, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> count <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;orders&#x27;</span>, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span>  </span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;order_items&#x27;</span>, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> order_items</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;products&#x27;</span>, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;categories&#x27;</span>, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> categories;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><pre><code>+------------+---------+| table_name | count   |+------------+---------+| users      | 100,000 || orders     | 1,000,000|| order_items| 5,000,000|| products   | 50,000  || categories | 500     |+------------+---------+</code></pre><p><strong>执行计划分析</strong>：</p><pre><code>+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+---------+----------+----------------------------------------------------+| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                  | rows    | filtered | Extra                                              |+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+---------+----------+----------------------------------------------------+|  1 | SIMPLE      | u     | NULL       | range  | PRIMARY       | PRIMARY | 4       | NULL                 | 50000   |   100.00 | Using index condition; Using temporary; Using filesort ||  1 | SIMPLE      | o     | NULL       | ref    | idx_user_id   | idx_user_id | 5    | db.u.user_id         | 10      |    33.33 | Using where                                        ||  1 | SIMPLE      | oi    | NULL       | ref    | idx_order_id  | idx_order_id | 4    | db.o.order_id       | 5       |   100.00 | NULL                                               ||  1 | SIMPLE      | p     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | db.oi.product_id     | 1       |   100.00 | NULL                                               ||  1 | SIMPLE      | c     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | db.p.category_id    | 1       |   100.00 | NULL                                               |+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+---------+----------+----------------------------------------------------+</code></pre><p><strong>问题诊断</strong>：</p><ul><li><p><strong>驱动表选择不当</strong>：从 50,000 行 users 表开始</p></li><li><p><strong>中间结果集过大</strong>：多次 JOIN 产生大量中间数据</p></li><li><p><strong>排序性能差</strong>：对大量数据排序</p></li></ul><h3 id="️-优化方案-2"><a class="markdownIt-Anchor" href="#️-优化方案-2"></a> 🛠️ 优化方案</h3><p><strong>方案一：优化 JOIN 顺序和索引</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 添加缺失索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_orders_user_date_amount </span><br><span class="line"><span class="keyword">ON</span> orders(user_id, order_date, amount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_users_register_date </span><br><span class="line"><span class="keyword">ON</span> users(register_date, user_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 使用 STRAIGHT_JOIN 强制优化器使用最佳顺序</span></span><br><span class="line"><span class="keyword">SELECT</span> STRAIGHT_JOIN</span><br><span class="line">    u.username,</span><br><span class="line">    o.order_id,</span><br><span class="line">    o.amount,</span><br><span class="line">    p.product_name,</span><br><span class="line">    c.category_name</span><br><span class="line"><span class="keyword">FROM</span> orders o  <span class="comment">-- 从 orders 开始，过滤条件更强</span></span><br><span class="line"><span class="keyword">JOIN</span> users u <span class="keyword">ON</span> o.user_id <span class="operator">=</span> u.user_id</span><br><span class="line"><span class="keyword">JOIN</span> order_items oi <span class="keyword">ON</span> o.order_id <span class="operator">=</span> oi.order_id</span><br><span class="line"><span class="keyword">JOIN</span> products p <span class="keyword">ON</span> oi.product_id <span class="operator">=</span> p.product_id</span><br><span class="line"><span class="keyword">JOIN</span> categories c <span class="keyword">ON</span> p.category_id <span class="operator">=</span> c.category_id</span><br><span class="line"><span class="keyword">WHERE</span> u.register_date <span class="operator">&gt;=</span> <span class="string">&#x27;2023-01-01&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> o.order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> o.amount <span class="operator">&gt;</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> o.order_date <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>方案二：分阶段查询 + 临时表：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 第一阶段：过滤核心数据</span></span><br><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> temp_orders <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> o.order_id, o.user_id, o.amount, o.order_date</span><br><span class="line"><span class="keyword">FROM</span> orders o</span><br><span class="line"><span class="keyword">WHERE</span> o.order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> o.amount <span class="operator">&gt;</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> o.order_date <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1000</span>;  <span class="comment">-- 扩大限制，确保最终有100条</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二阶段：关联其他表</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    u.username,</span><br><span class="line">    t.order_id,</span><br><span class="line">    t.amount,</span><br><span class="line">    p.product_name,</span><br><span class="line">    c.category_name</span><br><span class="line"><span class="keyword">FROM</span> temp_orders t</span><br><span class="line"><span class="keyword">JOIN</span> users u <span class="keyword">ON</span> t.user_id <span class="operator">=</span> u.user_id</span><br><span class="line"><span class="keyword">JOIN</span> order_items oi <span class="keyword">ON</span> t.order_id <span class="operator">=</span> oi.order_id</span><br><span class="line"><span class="keyword">JOIN</span> products p <span class="keyword">ON</span> oi.product_id <span class="operator">=</span> p.product_id</span><br><span class="line"><span class="keyword">JOIN</span> categories c <span class="keyword">ON</span> p.category_id <span class="operator">=</span> c.category_id</span><br><span class="line"><span class="keyword">WHERE</span> u.register_date <span class="operator">&gt;=</span> <span class="string">&#x27;2023-01-01&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t.order_date <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="优化策略对比"><a class="markdownIt-Anchor" href="#优化策略对比"></a> 📊 优化策略对比</h3><table><thead><tr><th>策略</th><th>实现方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>原始 JOIN</strong></td><td>多表直接关联，依赖优化器</td><td>代码简洁，逻辑清晰</td><td>性能不可控，容易触发全表扫描</td><td>小数据量，开发测试环境</td></tr><tr><td><strong>优化 JOIN 顺序</strong></td><td>使用 <code>STRAIGHT_JOIN</code> 强制执行顺序</td><td>性能可控，避免优化器误判</td><td>需要手动分析，硬编码不够灵活</td><td>表关系复杂，优化器选择不佳时</td></tr><tr><td><strong>分阶段查询</strong></td><td>借助临时表 + 分步查询</td><td>内存消耗低，性能更稳定</td><td>代码复杂度高，需要多次查询</td><td>超大数据量，复杂聚合计算</td></tr></tbody></table><p><strong>优化效果：</strong></p><p><strong>优化JOIN顺序</strong>：12.5秒 → 1.2秒（10倍提升）</p><p><strong>分阶段查询</strong>：12.5秒 → 0.8秒（15倍提升）</p><h2 id="五-总结与优化方法论"><a class="markdownIt-Anchor" href="#五-总结与优化方法论"></a> 💡 五、总结与优化方法论</h2><h3 id="sql-优化核心原则"><a class="markdownIt-Anchor" href="#sql-优化核心原则"></a> 🎯 SQL 优化核心原则</h3><p><strong>优化优先级：</strong></p><p>索引优化：</p><ul><li>添加缺失索引</li><li>优化索引结构</li><li>覆盖索引</li></ul><p>查询重写</p><ul><li>减少JOIN</li><li>优化WHERE</li><li>分页优化</li></ul><p>架构调整</p><ul><li>读写分离</li><li>分库分表</li><li>缓存策略</li></ul><h3 id="优化检查清单"><a class="markdownIt-Anchor" href="#优化检查清单"></a> 📝 优化检查清单</h3><p><strong>索引优化检查项：</strong></p><ul><li><p>✅ WHERE 条件字段是否有索引？</p></li><li><p>✅ ORDER BY/GROUP BY 字段是否有索引？</p></li><li><p>✅ 复合索引字段顺序是否最优？</p></li><li><p>✅ 是否使用覆盖索引？</p></li><li><p>✅ 索引选择性是否足够高？</p></li></ul><p><strong>查询优化检查项：</strong></p><ul><li><p>✅ 是否避免 SELECT *？</p></li><li><p>✅ 是否使用 LIMIT 限制返回行数？</p></li><li><p>✅ JOIN 条件是否有索引？</p></li><li><p>✅ 是否避免在 WHERE 中使用函数？</p></li><li><p>✅ 是否合理使用 UNION 替代 OR？</p></li></ul><h3 id="️-整体优化方案对比"><a class="markdownIt-Anchor" href="#️-整体优化方案对比"></a> 🛠️ 整体优化方案对比</h3><table><thead><tr><th>优化维度</th><th>基础方案</th><th>进阶方案</th><th>高级方案</th><th>选择建议</th></tr></thead><tbody><tr><td><strong>索引策略</strong></td><td>单列索引</td><td>复合索引</td><td>覆盖索引</td><td>根据查询频率和字段选择</td></tr><tr><td><strong>查询优化</strong></td><td>减少 SELECT *</td><td>使用 LIMIT</td><td>分页优化</td><td>结合业务需求逐步优化</td></tr><tr><td><strong>JOIN 优化</strong></td><td>添加关联索引</td><td>调整 JOIN 顺序</td><td>分阶段查询</td><td>根据数据量和复杂度选择</td></tr><tr><td><strong>架构优化</strong></td><td>查询优化</td><td>读写分离</td><td>分库分表</td><td>按业务增长阶段实施</td></tr></tbody></table><h3 id="性能监控工具对比"><a class="markdownIt-Anchor" href="#性能监控工具对比"></a> 🔧 性能监控工具对比</h3><table><thead><tr><th>分析工具</th><th>使用方式</th><th>输出内容</th><th>适用阶段</th><th>学习成本</th></tr></thead><tbody><tr><td><strong>EXPLAIN</strong></td><td>EXPLAIN SELECT …</td><td>执行计划详情</td><td>日常开发</td><td>低</td></tr><tr><td><strong>EXPLAIN ANALYZE</strong></td><td>EXPLAIN ANALYZE SELECT …</td><td>实际执行统计</td><td>性能调优</td><td>中</td></tr><tr><td><strong>慢查询日志</strong></td><td>配置 slow_query_log</td><td>慢 SQL 记录</td><td>问题排查</td><td>中</td></tr><tr><td><strong>Performance Schema</strong></td><td>查询系统表</td><td>详细性能指标</td><td>深度优化</td><td>高</td></tr></tbody></table><h3 id="进阶优化策略"><a class="markdownIt-Anchor" href="#进阶优化策略"></a> 🚀 进阶优化策略</h3><p><strong>读写分离架构：</strong></p><p>应用层 -&gt; （写主库 - 读从库1 - 读从库2 - 读从库3） -&gt; 主库</p><p><strong>分库分表策略：</strong></p><p><strong>垂直分表</strong>：将大字段分离到扩展表</p><p><strong>水平分表</strong>：按时间或ID范围拆分</p><p><strong>分库</strong>：按业务模块分离</p><h3 id="持续学习路径"><a class="markdownIt-Anchor" href="#持续学习路径"></a> 📚 持续学习路径</h3><p><strong>推荐学习资源</strong>：</p><ul><li><p>MySQL 官方文档：EXPLAIN 输出详解</p></li><li><p>Percona Toolkit：性能分析工具</p></li><li><p>sys Schema：MySQL 性能监控视图</p></li><li><p>数据库设计范式：从源头避免性能问题</p></li></ul>]]></content>
    
    
    <summary type="html">SQL 优化实战案例：从慢查询到高性能的完整指南</summary>
    
    
    
    <category term="数据库" scheme="http://www.formeasy.cc/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="http://www.formeasy.cc/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>【Redis缓存一致性：如何保证数据库与缓存同步】</title>
    <link href="http://www.formeasy.cc/2025/10/04/Redis/%E3%80%90Redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5%E3%80%91/"/>
    <id>http://www.formeasy.cc/2025/10/04/Redis/%E3%80%90Redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5%E3%80%91/</id>
    <published>2025-10-04T08:11:24.000Z</published>
    <updated>2025-10-04T08:18:28.754Z</updated>
    
    <content type="html"><![CDATA[<p>💡 摘要：是否遇到过缓存数据与数据库不一致的尴尬局面？是否在数据更新后发现用户看到的还是旧数据？缓存一致性是分布式系统中最具挑战性的问题之一，它直接影响到数据的准确性和用户体验。本文将深入探讨Redis缓存一致性的各种解决方案，从简单的更新策略到复杂的最终一致性方案，帮你构建可靠的数据同步体系！</p><hr /><h3 id="一-缓存一致性挑战"><a class="markdownIt-Anchor" href="#一-缓存一致性挑战"></a> 一、缓存一致性挑战</h3><h4 id="1-为什么缓存一致性很难"><a class="markdownIt-Anchor" href="#1-为什么缓存一致性很难"></a> 1. 为什么缓存一致性很难？</h4><p><strong>典型的不一致场景</strong>：</p><ul><li><p>🕒 <strong>时序问题</strong>：缓存更新和数据库更新的顺序</p></li><li><p>⚡ <strong>并发冲突</strong>：多个请求同时更新同一数据</p></li><li><p>🔄 <strong>操作失败</strong>：一个操作成功另一个失败</p></li><li><p>🗑️ <strong>缓存失效</strong>：缓存过期或淘汰导致数据不一致</p></li></ul><p><img src="c1a02890a7ad4c8cb1d6d172adcdb820.png" alt="" /></p><h4 id="2-一致性级别对比"><a class="markdownIt-Anchor" href="#2-一致性级别对比"></a> 2. 一致性级别对比</h4><table><thead><tr><th>一致性级别</th><th>描述</th><th>性能影响</th><th>实现复杂度</th></tr></thead><tbody><tr><td><strong>强一致性</strong></td><td>任何时刻数据一致</td><td>高</td><td>极高</td></tr><tr><td><strong>最终一致性</strong></td><td>一段时间后数据一致</td><td>中</td><td>中</td></tr><tr><td><strong>弱一致性</strong></td><td>不保证数据一致</td><td>低</td><td>低</td></tr></tbody></table><h3 id="二-基础更新策略"><a class="markdownIt-Anchor" href="#二-基础更新策略"></a> 二、基础更新策略</h3><h4 id="1-cache-aside模式旁路缓存"><a class="markdownIt-Anchor" href="#1-cache-aside模式旁路缓存"></a> 1. Cache-Aside模式（旁路缓存）</h4><p><strong>最常用的缓存模式</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_user</span>(<span class="params">user_id</span>):</span><br><span class="line">    <span class="comment"># 1. 先查缓存</span></span><br><span class="line">    user_data = redis.get(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> user_data:</span><br><span class="line">        <span class="keyword">return</span> user_data</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 缓存不存在，查数据库</span></span><br><span class="line">    user_data = db.query(<span class="string">&quot;SELECT * FROM users WHERE id = %s&quot;</span>, user_id)</span><br><span class="line">    <span class="keyword">if</span> user_data:</span><br><span class="line">        <span class="comment"># 3. 写入缓存</span></span><br><span class="line">        redis.setex(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>, <span class="number">3600</span>, user_data)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> user_data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_user</span>(<span class="params">user_id, new_data</span>):</span><br><span class="line">    <span class="comment"># 1. 先更新数据库</span></span><br><span class="line">    db.update(<span class="string">&quot;UPDATE users SET ... WHERE id = %s&quot;</span>, user_id, new_data)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 再删除缓存</span></span><br><span class="line">    redis.delete(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>问题：并发更新可能导致不一致</strong></p><p><img src="1873d601c2a84ae5880db7b618e8a520.png" alt="" /></p><h4 id="2-write-through模式直写"><a class="markdownIt-Anchor" href="#2-write-through模式直写"></a> 2. Write-Through模式（直写）</h4><p><strong>同步更新缓存和数据库</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WriteThroughCache</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, db_client</span>):</span><br><span class="line">        self.redis = redis_client</span><br><span class="line">        self.db = db_client</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self, key, value, expire=<span class="number">3600</span></span>):</span><br><span class="line">        <span class="comment"># 1. 先更新数据库</span></span><br><span class="line">        self.db.update_data(key, value)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 再更新缓存</span></span><br><span class="line">        self.redis.setex(key, expire, value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="comment"># 直接读缓存</span></span><br><span class="line">        <span class="keyword">return</span> self.redis.get(key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">cache = WriteThroughCache(redis, db)</span><br><span class="line">cache.<span class="built_in">set</span>(<span class="string">&quot;user:1001&quot;</span>, user_data)</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：保证强一致性<br /><strong>缺点</strong>：写性能较低，不适合高频写场景</p><h3 id="三-最终一致性方案"><a class="markdownIt-Anchor" href="#三-最终一致性方案"></a> 三、最终一致性方案</h3><h4 id="1-延迟双删策略"><a class="markdownIt-Anchor" href="#1-延迟双删策略"></a> 1. 延迟双删策略</h4><p><strong>解决并发冲突的方案</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_user_with_double_delete</span>(<span class="params">user_id, new_data</span>):</span><br><span class="line">    <span class="comment"># 第一次删除缓存</span></span><br><span class="line">    redis.delete(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新数据库</span></span><br><span class="line">    db.update(<span class="string">&quot;UPDATE users SET ... WHERE id = %s&quot;</span>, user_id, new_data)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 延迟第二次删除</span></span><br><span class="line">    threading.Timer(<span class="number">1.0</span>, <span class="keyword">lambda</span>: redis.delete(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>)).start()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_with_retry</span>(<span class="params">user_id, max_retries=<span class="number">3</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;带重试的查询&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> attempt <span class="keyword">in</span> <span class="built_in">range</span>(max_retries):</span><br><span class="line">        user_data = redis.get(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> user_data:</span><br><span class="line">            <span class="keyword">return</span> user_data</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 缓存不存在，查数据库</span></span><br><span class="line">        user_data = db.query(<span class="string">&quot;SELECT * FROM users WHERE id = %s&quot;</span>, user_id)</span><br><span class="line">        <span class="keyword">if</span> user_data:</span><br><span class="line">            <span class="comment"># 设置缓存</span></span><br><span class="line">            redis.setex(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>, <span class="number">3600</span>, user_data)</span><br><span class="line">            <span class="keyword">return</span> user_data</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 短暂等待后重试</span></span><br><span class="line">        time.sleep(<span class="number">0.1</span> * (<span class="number">2</span> ** attempt))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="2-基于消息队列的异步更新"><a class="markdownIt-Anchor" href="#2-基于消息队列的异步更新"></a> 2. 基于消息队列的异步更新</h4><p><strong>使用消息队列保证最终一致性</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheAsyncUpdater</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.producer = KafkaProducer(</span><br><span class="line">            bootstrap_servers=[<span class="string">&#x27;kafka1:9092&#x27;</span>, <span class="string">&#x27;kafka2:9092&#x27;</span>],</span><br><span class="line">            value_serializer=<span class="keyword">lambda</span> v: json.dumps(v).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_user</span>(<span class="params">self, user_id, new_data</span>):</span><br><span class="line">        <span class="comment"># 1. 只更新数据库</span></span><br><span class="line">        db.update(<span class="string">&quot;UPDATE users SET ... WHERE id = %s&quot;</span>, user_id, new_data)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 发送缓存更新消息</span></span><br><span class="line">        message = &#123;</span><br><span class="line">            <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;cache_update&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;key&#x27;</span>: <span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;data&#x27;</span>: new_data,</span><br><span class="line">            <span class="string">&#x27;timestamp&#x27;</span>: time.time()</span><br><span class="line">        &#125;</span><br><span class="line">        self.producer.send(<span class="string">&#x27;cache-updates&#x27;</span>, message)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者端</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cache_update_consumer</span>():</span><br><span class="line">    consumer = KafkaConsumer(</span><br><span class="line">        <span class="string">&#x27;cache-updates&#x27;</span>,</span><br><span class="line">        bootstrap_servers=[<span class="string">&#x27;kafka1:9092&#x27;</span>, <span class="string">&#x27;kafka2:9092&#x27;</span>],</span><br><span class="line">        value_deserializer=<span class="keyword">lambda</span> m: json.loads(m.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> message <span class="keyword">in</span> consumer:</span><br><span class="line">        data = message.value</span><br><span class="line">        <span class="keyword">if</span> data[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;cache_update&#x27;</span>:</span><br><span class="line">            <span class="comment"># 更新缓存</span></span><br><span class="line">            redis.setex(data[<span class="string">&#x27;key&#x27;</span>], <span class="number">3600</span>, data[<span class="string">&#x27;data&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="四-强一致性方案"><a class="markdownIt-Anchor" href="#四-强一致性方案"></a> 四、强一致性方案</h3><h4 id="1-分布式事务方案"><a class="markdownIt-Anchor" href="#1-分布式事务方案"></a> 1. 分布式事务方案</h4><p><strong>使用2PC实现强一致性</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DistributedTransaction</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, db_client</span>):</span><br><span class="line">        self.redis = redis_client</span><br><span class="line">        self.db = db_client</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_with_2pc</span>(<span class="params">self, key, new_data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;两阶段提交更新&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 阶段一：准备</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 数据库准备</span></span><br><span class="line">            db_transaction = self.db.begin_transaction()</span><br><span class="line">            db_transaction.update(<span class="string">&quot;UPDATE users SET ... WHERE id = %s&quot;</span>, key.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>], new_data)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Redis准备（设置临时状态）</span></span><br><span class="line">            self.redis.setex(<span class="string">f&quot;lock:<span class="subst">&#123;key&#125;</span>&quot;</span>, <span class="number">30</span>, <span class="string">&quot;prepared&quot;</span>)</span><br><span class="line">            self.redis.setex(<span class="string">f&quot;temp:<span class="subst">&#123;key&#125;</span>&quot;</span>, <span class="number">30</span>, new_data)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 阶段二：提交</span></span><br><span class="line">            db_transaction.commit()</span><br><span class="line">            self.redis.setex(key, <span class="number">3600</span>, new_data)</span><br><span class="line">            self.redis.delete(<span class="string">f&quot;lock:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">            self.redis.delete(<span class="string">f&quot;temp:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 回滚</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;db_transaction&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>():</span><br><span class="line">                db_transaction.rollback()</span><br><span class="line">            self.redis.delete(<span class="string">f&quot;lock:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">            self.redis.delete(<span class="string">f&quot;temp:<span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">raise</span> e</span><br></pre></td></tr></table></figure><h4 id="2-基于binlog的同步方案"><a class="markdownIt-Anchor" href="#2-基于binlog的同步方案"></a> 2. 基于binlog的同步方案</h4><p><strong>使用MySQL binlog同步缓存</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysqlreplication</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinlogSyncService</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client</span>):</span><br><span class="line">        self.redis = redis_client</span><br><span class="line">        self.setup_binlog_stream()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setup_binlog_stream</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;设置binlog监听&quot;&quot;&quot;</span></span><br><span class="line">        stream = pymysqlreplication.BinLogStreamReader(</span><br><span class="line">            connection_settings=&#123;</span><br><span class="line">                <span class="string">&#x27;host&#x27;</span>: <span class="string">&#x27;mysql-master&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;port&#x27;</span>: <span class="number">3306</span>,</span><br><span class="line">                <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;repl&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;passwd&#x27;</span>: <span class="string">&#x27;password&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            server_id=<span class="number">100</span>,</span><br><span class="line">            blocking=<span class="literal">True</span>,</span><br><span class="line">            resume_stream=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> binlogevent <span class="keyword">in</span> stream:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(binlogevent, WriteRowsEvent):</span><br><span class="line">                self.handle_write_event(binlogevent)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(binlogevent, UpdateRowsEvent):</span><br><span class="line">                self.handle_update_event(binlogevent)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(binlogevent, DeleteRowsEvent):</span><br><span class="line">                self.handle_delete_event(binlogevent)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_write_event</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理插入事件&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> event.rows:</span><br><span class="line">            <span class="keyword">if</span> event.table == <span class="string">&#x27;users&#x27;</span>:</span><br><span class="line">                user_id = row[<span class="string">&#x27;values&#x27;</span>][<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">                redis_key = <span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span></span><br><span class="line">                self.redis.setex(redis_key, <span class="number">3600</span>, json.dumps(row[<span class="string">&#x27;values&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_update_event</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理更新事件&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> event.rows:</span><br><span class="line">            <span class="keyword">if</span> event.table == <span class="string">&#x27;users&#x27;</span>:</span><br><span class="line">                user_id = row[<span class="string">&#x27;after_values&#x27;</span>][<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">                redis_key = <span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span></span><br><span class="line">                self.redis.setex(redis_key, <span class="number">3600</span>, json.dumps(row[<span class="string">&#x27;after_values&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_delete_event</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理删除事件&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> event.rows:</span><br><span class="line">            <span class="keyword">if</span> event.table == <span class="string">&#x27;users&#x27;</span>:</span><br><span class="line">                user_id = row[<span class="string">&#x27;values&#x27;</span>][<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">                redis_key = <span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span></span><br><span class="line">                self.redis.delete(redis_key)</span><br></pre></td></tr></table></figure><h3 id="五-读写分离场景的一致性"><a class="markdownIt-Anchor" href="#五-读写分离场景的一致性"></a> 五、读写分离场景的一致性</h3><h4 id="1-主从延迟问题"><a class="markdownIt-Anchor" href="#1-主从延迟问题"></a> 1. 主从延迟问题</h4><p><strong>解决主从延迟导致的脏读</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_with_read_after_write</span>(<span class="params">user_id, write_timestamp=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    读写分离环境下的一致性读取</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> write_timestamp:</span><br><span class="line">        <span class="comment"># 检查主从延迟</span></span><br><span class="line">        slave_lag = get_slave_lag()</span><br><span class="line">        <span class="keyword">if</span> time.time() - write_timestamp &amp;lt; slave_lag + <span class="number">1</span>:  <span class="comment"># 额外1秒缓冲</span></span><br><span class="line">            <span class="comment"># 强制读主库</span></span><br><span class="line">            <span class="keyword">return</span> read_from_master(user_id)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 先尝试读从库</span></span><br><span class="line">    user_data = read_from_slave(user_id)</span><br><span class="line">    <span class="keyword">if</span> user_data:</span><br><span class="line">        <span class="keyword">return</span> user_data</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从库没有，读主库</span></span><br><span class="line">    <span class="keyword">return</span> read_from_master(user_id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_from_master</span>(<span class="params">user_id</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从主库读取&quot;&quot;&quot;</span></span><br><span class="line">    user_data = db_master.query(<span class="string">&quot;SELECT * FROM users WHERE id = %s&quot;</span>, user_id)</span><br><span class="line">    <span class="keyword">if</span> user_data:</span><br><span class="line">        <span class="comment"># 更新缓存</span></span><br><span class="line">        redis.setex(<span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span>, <span class="number">3600</span>, user_data)</span><br><span class="line">    <span class="keyword">return</span> user_data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_from_slave</span>(<span class="params">user_id</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从从库读取&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> db_slave.query(<span class="string">&quot;SELECT * FROM users WHERE id = %s&quot;</span>, user_id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_slave_lag</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取从库延迟&quot;&quot;&quot;</span></span><br><span class="line">    result = db_slave.query(<span class="string">&quot;SHOW SLAVE STATUS&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result[<span class="string">&#x27;Seconds_Behind_Master&#x27;</span>] <span class="keyword">if</span> result <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="六-监控与治理"><a class="markdownIt-Anchor" href="#六-监控与治理"></a> 六、监控与治理</h3><h4 id="1-一致性监控体系"><a class="markdownIt-Anchor" href="#1-一致性监控体系"></a> 1. 一致性监控体系</h4><p><strong>监控关键指标</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConsistencyMonitor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.metrics = &#123;</span><br><span class="line">            <span class="string">&#x27;cache_hits&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;cache_misses&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;stale_reads&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;consistency_errors&#x27;</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_consistency</span>(<span class="params">self, key, db_data, cache_data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查数据一致性&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> db_data != cache_data:</span><br><span class="line">            self.metrics[<span class="string">&#x27;consistency_errors&#x27;</span>] += <span class="number">1</span></span><br><span class="line">            self._repair_inconsistency(key, db_data)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_repair_inconsistency</span>(<span class="params">self, key, correct_data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;修复不一致数据&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            redis.setex(key, <span class="number">3600</span>, correct_data)</span><br><span class="line">            logging.warning(<span class="string">f&quot;Repaired inconsistency for key: <span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logging.error(<span class="string">f&quot;Failed to repair inconsistency: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">track_stale_read</span>(<span class="params">self, key, duration</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;跟踪过期数据读取&quot;&quot;&quot;</span></span><br><span class="line">        self.metrics[<span class="string">&#x27;stale_reads&#x27;</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> duration &amp;gt; <span class="number">5</span>:  <span class="comment"># 5秒以上的旧数据</span></span><br><span class="line">            send_alert(<span class="string">f&quot;Stale data detected: <span class="subst">&#123;key&#125;</span>&quot;</span>, <span class="string">f&quot;Duration: <span class="subst">&#123;duration&#125;</span>s&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_report</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;生成监控报告&quot;&quot;&quot;</span></span><br><span class="line">        total_requests = self.metrics[<span class="string">&#x27;cache_hits&#x27;</span>] + self.metrics[<span class="string">&#x27;cache_misses&#x27;</span>]</span><br><span class="line">        consistency_rate = <span class="number">1</span> - (self.metrics[<span class="string">&#x27;consistency_errors&#x27;</span>] / total_requests) <span class="keyword">if</span> total_requests &amp;gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;consistency_rate&#x27;</span>: <span class="string">f&quot;<span class="subst">&#123;consistency_rate:<span class="number">.3</span>%&#125;</span>&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;stale_reads&#x27;</span>: self.metrics[<span class="string">&#x27;stale_reads&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;total_requests&#x27;</span>: total_requests</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="2-自动修复机制"><a class="markdownIt-Anchor" href="#2-自动修复机制"></a> 2. 自动修复机制</h4><p><strong>不一致数据自动检测和修复</strong>：</p><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoRepairService</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, db_client</span>):</span><br><span class="line">        self.redis = redis_client</span><br><span class="line">        self.db = db_client</span><br><span class="line">        self.repair_queue = queue.Queue()</span><br><span class="line">        self.start_workers()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_workers</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;启动修复工作线程&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):  <span class="comment"># 3个修复 worker</span></span><br><span class="line">            thread = threading.Thread(target=self._repair_worker)</span><br><span class="line">            thread.daemon = <span class="literal">True</span></span><br><span class="line">            thread.start()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_repair_worker</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;修复工作线程&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                key = self.repair_queue.get()</span><br><span class="line">                self._repair_key(key)</span><br><span class="line">                self.repair_queue.task_done()</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                logging.error(<span class="string">f&quot;Repair worker error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_repair_key</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;修复单个key&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 从数据库获取正确数据</span></span><br><span class="line">        <span class="keyword">if</span> key.startswith(<span class="string">&#x27;user:&#x27;</span>):</span><br><span class="line">            user_id = key.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">            db_data = self.db.query(<span class="string">&quot;SELECT * FROM users WHERE id = %s&quot;</span>, user_id)</span><br><span class="line">            <span class="keyword">if</span> db_data:</span><br><span class="line">                <span class="comment"># 更新缓存</span></span><br><span class="line">                self.redis.setex(key, <span class="number">3600</span>, db_data)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">schedule_repair</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;调度修复任务&quot;&quot;&quot;</span></span><br><span class="line">        self.repair_queue.put(key)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bulk_repair_check</span>(<span class="params">self, pattern=<span class="string">&quot;user:*&quot;</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;批量检查修复&quot;&quot;&quot;</span></span><br><span class="line">        cursor = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            cursor, keys = self.redis.scan(cursor, <span class="keyword">match</span>=pattern, count=<span class="number">100</span>)</span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">                self._verify_and_repair(key)</span><br><span class="line">            <span class="keyword">if</span> cursor == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_verify_and_repair</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;验证并修复数据&quot;&quot;&quot;</span></span><br><span class="line">        cache_data = self.redis.get(key)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cache_data:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取数据库数据对比</span></span><br><span class="line">        <span class="keyword">if</span> key.startswith(<span class="string">&#x27;user:&#x27;</span>):</span><br><span class="line">            user_id = key.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">            db_data = self.db.query(<span class="string">&quot;SELECT * FROM users WHERE id = %s&quot;</span>, user_id)</span><br><span class="line">            <span class="keyword">if</span> db_data != cache_data:</span><br><span class="line">                self.schedule_repair(key)</span><br></pre></td></tr></table></figure><h3 id="七-场景化解决方案"><a class="markdownIt-Anchor" href="#七-场景化解决方案"></a> 七、场景化解决方案</h3><h4 id="1-电商商品库存一致性"><a class="markdownIt-Anchor" href="#1-电商商品库存一致性"></a> 1. 电商商品库存一致性</h4><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InventoryService</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.redis = redis.Redis()</span><br><span class="line">        self.db = database.Connection()</span><br><span class="line">        self.lock = redis.Redis()  <span class="comment"># 用于分布式锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrease_stock</span>(<span class="params">self, product_id, quantity</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;减少库存（保证一致性）&quot;&quot;&quot;</span></span><br><span class="line">        lock_key = <span class="string">f&quot;lock:stock:<span class="subst">&#123;product_id&#125;</span>&quot;</span></span><br><span class="line">        cache_key = <span class="string">f&quot;stock:<span class="subst">&#123;product_id&#125;</span>&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取分布式锁</span></span><br><span class="line">        <span class="keyword">with</span> self._acquire_lock(lock_key):</span><br><span class="line">            <span class="comment"># 检查缓存库存</span></span><br><span class="line">            cache_stock = self.redis.get(cache_key)</span><br><span class="line">            <span class="keyword">if</span> cache_stock <span class="keyword">and</span> <span class="built_in">int</span>(cache_stock) &amp;lt; quantity:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&quot;库存不足&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新数据库</span></span><br><span class="line">            self.db.update(</span><br><span class="line">                <span class="string">&quot;UPDATE products SET stock = stock - %s WHERE id = %s AND stock &amp;gt;= %s&quot;</span>,</span><br><span class="line">                quantity, product_id, quantity</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新缓存</span></span><br><span class="line">            <span class="keyword">if</span> cache_stock:</span><br><span class="line">                new_stock = <span class="built_in">int</span>(cache_stock) - quantity</span><br><span class="line">                self.redis.setex(cache_key, <span class="number">3600</span>, <span class="built_in">str</span>(new_stock))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 缓存不存在，删除以确保下次从数据库加载</span></span><br><span class="line">                self.redis.delete(cache_key)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_stock</span>(<span class="params">self, product_id</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取库存信息&quot;&quot;&quot;</span></span><br><span class="line">        cache_key = <span class="string">f&quot;stock:<span class="subst">&#123;product_id&#125;</span>&quot;</span></span><br><span class="line">        stock = self.redis.get(cache_key)</span><br><span class="line">        <span class="keyword">if</span> stock:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(stock)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从数据库获取</span></span><br><span class="line">        stock = self.db.query(<span class="string">&quot;SELECT stock FROM products WHERE id = %s&quot;</span>, product_id)</span><br><span class="line">        <span class="keyword">if</span> stock <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.redis.setex(cache_key, <span class="number">3600</span>, <span class="built_in">str</span>(stock))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stock</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_acquire_lock</span>(<span class="params">self, lock_key, timeout=<span class="number">10</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取分布式锁&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 实现分布式锁逻辑</span></span><br><span class="line">        identifier = <span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">        end = time.time() + timeout</span><br><span class="line">        <span class="keyword">while</span> time.time() &amp;lt; end:</span><br><span class="line">            <span class="keyword">if</span> self.lock.<span class="built_in">set</span>(lock_key, identifier, nx=<span class="literal">True</span>, ex=<span class="number">5</span>):</span><br><span class="line">                <span class="keyword">return</span> identifier</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;获取锁超时&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-金融账户余额一致性"><a class="markdownIt-Anchor" href="#2-金融账户余额一致性"></a> 2. 金融账户余额一致性</h4><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountService</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.redis = redis.Redis()</span><br><span class="line">        self.db = database.Connection()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transfer</span>(<span class="params">self, from_account, to_account, amount</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;转账操作（强一致性要求）&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用数据库事务保证一致性</span></span><br><span class="line">        <span class="keyword">with</span> self.db.transaction():</span><br><span class="line">            <span class="comment"># 更新数据库</span></span><br><span class="line">            self.db.update(</span><br><span class="line">                <span class="string">&quot;UPDATE accounts SET balance = balance - %s WHERE id = %s AND balance &amp;gt;= %s&quot;</span>,</span><br><span class="line">                amount, from_account, amount</span><br><span class="line">            )</span><br><span class="line">            self.db.update(</span><br><span class="line">                <span class="string">&quot;UPDATE accounts SET balance = balance + %s WHERE id = %s&quot;</span>,</span><br><span class="line">                amount, to_account</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 删除相关缓存</span></span><br><span class="line">            self.redis.delete(<span class="string">f&quot;account:<span class="subst">&#123;from_account&#125;</span>&quot;</span>)</span><br><span class="line">            self.redis.delete(<span class="string">f&quot;account:<span class="subst">&#123;to_account&#125;</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 记录交易日志</span></span><br><span class="line">            self._log_transaction(from_account, to_account, amount)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_balance</span>(<span class="params">self, account_id</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取余额（最终一致性）&quot;&quot;&quot;</span></span><br><span class="line">        cache_key = <span class="string">f&quot;account:<span class="subst">&#123;account_id&#125;</span>&quot;</span></span><br><span class="line">        balance = self.redis.get(cache_key)</span><br><span class="line">        <span class="keyword">if</span> balance:</span><br><span class="line">            <span class="keyword">return</span> decimal.Decimal(balance)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从数据库获取</span></span><br><span class="line">        balance = self.db.query(<span class="string">&quot;SELECT balance FROM accounts WHERE id = %s&quot;</span>, account_id)</span><br><span class="line">        <span class="keyword">if</span> balance <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 异步更新缓存</span></span><br><span class="line">            threading.Thread(</span><br><span class="line">                target=self.redis.setex,</span><br><span class="line">                args=(cache_key, <span class="number">300</span>, <span class="built_in">str</span>(balance))</span><br><span class="line">            ).start()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> balance</span><br></pre></td></tr></table></figure><h3 id="八-总结与最佳实践"><a class="markdownIt-Anchor" href="#八-总结与最佳实践"></a> 八、总结与最佳实践</h3><h4 id="一致性方案选择指南"><a class="markdownIt-Anchor" href="#一致性方案选择指南"></a> 一致性方案选择指南</h4><p><img src="db541323ce40494a994076ba3cd5de0c.png" alt="" /></p><h4 id="最佳实践-checklist"><a class="markdownIt-Anchor" href="#最佳实践-checklist"></a> 最佳实践 checklist ✅</h4><p><strong>设计阶段</strong>：</p><ul><li><p>明确业务的一致性要求</p></li><li><p>选择合适的一致性级别</p></li><li><p>设计缓存更新策略</p></li><li><p>规划监控和修复机制</p></li></ul><p><strong>开发阶段</strong>：</p><ul><li><p>实现适当的重试机制</p></li><li><p>添加分布式锁避免并发冲突</p></li><li><p>设置合理的超时时间</p></li><li><p>实现数据验证和修复</p></li></ul><p><strong>运维阶段</strong>：</p><ul><li><p>监控缓存命中率和一致性</p></li><li><p>设置告警机制</p></li><li><p>定期进行一致性检查</p></li><li><p>准备应急预案</p></li></ul><h4 id="关键建议"><a class="markdownIt-Anchor" href="#关键建议"></a> 关键建议 🚀</h4><ol><li><p><strong>不要过度设计</strong>：根据业务需求选择适当的一致性级别</p></li><li><p><strong>监控重于预防</strong>：建立完善的监控体系比追求完美方案更重要</p></li><li><p><strong>设计容错机制</strong>：假设不一致会发生，准备好修复方案</p></li><li><p><strong>持续优化改进</strong>：根据监控数据不断调整和优化策略</p></li></ol><p>通过本文的详细分析和实践方案，你应该能够根据业务需求选择合适的缓存一致性方案，并构建出可靠的数据同步体系。记住：一致性是一个持续的过程，而不是一次性的解决方案！</p>]]></content>
    
    
    <summary type="html">【Redis缓存一致性：如何保证数据库与缓存同步】</summary>
    
    
    
    <category term="数据库" scheme="http://www.formeasy.cc/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="http://www.formeasy.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch知识点详细总结</title>
    <link href="http://www.formeasy.cc/2025/10/03/Elasticsearch/Elasticsearch%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>http://www.formeasy.cc/2025/10/03/Elasticsearch/Elasticsearch%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</id>
    <published>2025-10-03T13:42:57.000Z</published>
    <updated>2025-10-03T13:48:08.764Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch（简称 ES）是一款基于 Lucene 构建的分布式、高扩展、高实时的全文搜索引擎，同时也是 Elastic Stack（ELK Stack：Elasticsearch, Logstash, Kibana）的核心组件，广泛应用于日志分析、全文检索、实时数据分析等场景。本文将从核心概念、架构设计、数据操作、查询分析、性能优化等维度进行全面总结。</p><h3 id="一-核心概念"><a class="markdownIt-Anchor" href="#一-核心概念"></a> 一、核心概念</h3><p>Elasticsearch 的概念体系与传统数据库有显著差异，理解这些基础概念是掌握 ES 的前提。</p><h4 id="1-与传统数据库的对应关系"><a class="markdownIt-Anchor" href="#1-与传统数据库的对应关系"></a> 1. 与传统数据库的对应关系</h4><p>为便于快速理解，可将 ES 核心概念与关系型数据库（如 MySQL）进行类比：</p><table><thead><tr><th>Elasticsearch 概念</th><th>关系型数据库概念</th><th>说明</th></tr></thead><tbody><tr><td>Index（索引）</td><td>Database（数据库）</td><td>存储同类文档的集合，具有相似的结构</td></tr><tr><td>Type（类型，7.x 后废弃）</td><td>Table（表）</td><td>早期用于对 Index 内文档分类，7.x 起强制为 <code>_doc</code></td></tr><tr><td>Document（文档）</td><td>Row（行）</td><td>索引中最小的数据单元，以 JSON 格式存储</td></tr><tr><td>Field（字段）</td><td>Column（列）</td><td>文档中的属性，对应 JSON 的键值对</td></tr><tr><td>Mapping（映射）</td><td>Schema（表结构）</td><td>定义文档中字段的类型、分词器、是否索引等元数据</td></tr><tr><td>Shard（分片）</td><td>-</td><td>索引的物理分片，实现水平扩展（Lucene 索引实例）</td></tr><tr><td>Replica（副本）</td><td>-</td><td>分片的冗余备份，用于高可用和负载分担</td></tr></tbody></table><h4 id="2-核心概念详解"><a class="markdownIt-Anchor" href="#2-核心概念详解"></a> 2. 核心概念详解</h4><h5 id="1index索引"><a class="markdownIt-Anchor" href="#1index索引"></a> （1）Index（索引）</h5><ul><li><strong>定义</strong>：一个逻辑上的集合，包含具有相似结构的文档（如“商品索引”“用户日志索引”）。</li><li><strong>命名规则</strong>： lowercase 小写，无特殊字符（建议用 <code>-</code> 分隔，如 <code>user-logs-2024</code>）。</li><li><strong>特点</strong>：索引是分片的逻辑容器，创建时需指定分片和副本数量，创建后分片数量不可修改（副本可动态调整）。</li></ul><h5 id="2document文档"><a class="markdownIt-Anchor" href="#2document文档"></a> （2）Document（文档）</h5><ul><li><strong>格式</strong>：唯一支持 JSON 格式，灵活性高（无需严格统一结构，但建议遵循 Mapping 规范）。</li><li><strong>唯一标识</strong>：由 <code>_index</code>（所属索引）、<code>_type</code>（7.x 固定为 <code>_doc</code>）、<code>_id</code>（文档 ID）共同确定。<ul><li><code>_id</code> 可手动指定（如用业务 ID 作为 <code>_id</code>），也可由 ES 自动生成（20 位 UUID）。</li></ul></li><li><strong>元数据</strong>：除业务字段外，包含 <code>_index</code>、<code>_type</code>、<code>_id</code>、<code>_version</code>（版本号）、<code>_score</code>（查询相关性得分）等系统字段。</li></ul><h5 id="3mapping映射"><a class="markdownIt-Anchor" href="#3mapping映射"></a> （3）Mapping（映射）</h5><ul><li><strong>定义</strong>：相当于文档的“ schema ”，用于约束字段的类型、分词方式、是否可检索等属性。</li><li><strong>类型</strong>：<ul><li>动态映射（Dynamic Mapping）：ES 自动根据文档字段值推断类型（如数字→<code>long</code>，字符串→<code>text</code>/<code>keyword</code>），适合快速上手，但可能存在精度问题。</li><li>静态映射（Explicit Mapping）：手动定义字段类型和属性，适合生产环境，保证数据结构一致性。</li></ul></li><li><strong>常见字段类型</strong>：<ul><li>文本类：<code>text</code>（可分词，用于全文检索，如“商品描述”）、<code>keyword</code>（不分词，用于精确匹配/聚合，如“商品分类”）。</li><li>数值类：<code>long</code>、<code>integer</code>、<code>double</code>、<code>float</code>（对应不同精度的数字）。</li><li>日期类：<code>date</code>（支持格式化，如 <code>yyyy-MM-dd HH:mm:ss</code>）。</li><li>布尔类：<code>boolean</code>（<code>true</code>/<code>false</code>）。</li><li>复合类：<code>object</code>（嵌套对象）、<code>nested</code>（处理嵌套数组，解决 <code>object</code> 类型的扁平化问题）。</li></ul></li></ul><h5 id="4shard-replica分片与副本"><a class="markdownIt-Anchor" href="#4shard-replica分片与副本"></a> （4）Shard &amp; Replica（分片与副本）</h5><ul><li><p><strong>Shard（分片）</strong>：</p><ul><li>核心目的：实现水平扩展。单个索引的数据被拆分到多个分片，每个分片是独立的 Lucene 索引，可分布在不同节点。</li><li>类型：主分片（Primary Shard）、副本分片（Replica Shard）。</li><li>数量限制：创建索引时指定主分片数量（<code>number_of_shards</code>），创建后不可修改（需通过 <code>reindex</code> 重建索引调整）；默认 1 个主分片。</li></ul></li><li><p><strong>Replica（副本）</strong>：</p><ul><li>核心目的：高可用 + 负载分担。副本是主分片的冗余备份，主分片故障时可自动升级为主分片；同时可承担查询请求，缓解主分片压力。</li><li>数量配置：创建时通过 <code>number_of_replicas</code> 指定，支持动态修改（如 <code>PUT /index/_settings &#123;&quot;number_of_replicas&quot;: 2&#125;</code>）；默认 1 个副本。</li><li>约束：副本分片不会与对应的主分片在同一节点（避免单点故障）。</li></ul></li></ul><h5 id="5cluster-node集群与节点"><a class="markdownIt-Anchor" href="#5cluster-node集群与节点"></a> （5）Cluster &amp; Node（集群与节点）</h5><ul><li><p><strong>Node（节点）</strong>：</p><ul><li>定义：运行 ES 进程的单个服务器，是集群的基本组成单元。</li><li>类型：<ul><li>主节点（Master Node）：负责集群元数据管理（如创建索引、分片分配），默认所有节点均可竞选，建议通过 <code>node.master: true</code> 专门配置。</li><li>数据节点（Data Node）：负责数据的存储、索引、查询和聚合，通过 <code>node.data: true</code> 配置，是集群的“数据载体”。</li><li>协调节点（Coordinating Node）：接收客户端请求，分发到其他节点，汇总结果返回；默认所有节点都是协调节点，可通过 <code>node.master: false</code> + <code>node.data: false</code> 配置专用协调节点。</li><li>ingest 节点：负责数据预处理（如添加字段、转换格式），通过 <code>node.ingest: true</code> 配置。</li></ul></li></ul></li><li><p><strong>Cluster（集群）</strong>：</p><ul><li>定义：由多个节点组成的集合，共享同一集群名称（<code>cluster.name</code>），协同工作实现分布式能力。</li><li>集群状态：通过 <code>_cluster/health</code> 查看，状态分为 <code>green</code>（所有主/副本分片正常）、<code>yellow</code>（主分片正常，副本分片缺失）、<code>red</code>（主分片缺失，数据不可用）。</li></ul></li></ul><h3 id="二-架构设计"><a class="markdownIt-Anchor" href="#二-架构设计"></a> 二、架构设计</h3><p>Elasticsearch 的分布式架构是其高扩展、高可用的核心，主要围绕“分片分配”“路由机制”“故障转移”展开。</p><h4 id="1-分片路由机制"><a class="markdownIt-Anchor" href="#1-分片路由机制"></a> 1. 分片路由机制</h4><p>当客户端写入/查询文档时，ES 需要确定文档归属的主分片，核心逻辑如下：</p><ol><li>计算路由值：<code>shard = hash(_routing) % number_of_primary_shards</code>。</li><li><code>_routing</code> 默认为文档的 <code>_id</code>，可手动指定（如按“用户 ID”路由，确保同一用户的文档在同一分片，优化聚合效率）。</li><li>协调节点根据路由结果，将请求转发到主分片所在节点；写入操作需等待主分片和副本分片均确认后返回成功（默认配置）。</li></ol><h4 id="2-分片分配与再平衡"><a class="markdownIt-Anchor" href="#2-分片分配与再平衡"></a> 2. 分片分配与再平衡</h4><ul><li><strong>分配策略</strong>：Master 节点负责将主分片和副本分片分配到不同节点，遵循“副本不与主分片同节点”“分片均匀分布”等原则。</li><li><strong>再平衡（Rebalancing）</strong>：当集群节点数量变化（新增/下线节点）或分片状态变化时，Master 会自动触发分片迁移，确保负载均衡；可通过 <code>cluster.routing.rebalance.enable</code> 控制开关。</li></ul><h4 id="3-故障转移机制"><a class="markdownIt-Anchor" href="#3-故障转移机制"></a> 3. 故障转移机制</h4><p>当主节点故障或主分片不可用时，ES 自动执行故障转移：</p><ol><li>节点间通过 ZenDiscovery 协议选举新的主节点（需满足“法定人数”，避免脑裂，可配置 <code>discovery.zen.minimum_master_nodes</code>）。</li><li>新主节点将该主分片对应的副本分片升级为新的主分片。</li><li>重新创建缺失的副本分片，恢复集群状态为 <code>green</code>。</li></ol><h3 id="三-数据操作crud"><a class="markdownIt-Anchor" href="#三-数据操作crud"></a> 三、数据操作（CRUD）</h3><p>ES 提供 RESTful API 用于数据交互，核心操作包括索引（Index）、查询（Search）、更新（Update）、删除（Delete）。</p><h4 id="1-文档操作"><a class="markdownIt-Anchor" href="#1-文档操作"></a> 1. 文档操作</h4><h5 id="1创建文档index"><a class="markdownIt-Anchor" href="#1创建文档index"></a> （1）创建文档（Index）</h5><ul><li>手动指定 <code>_id</code>：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /&lt;index&gt;/_doc/&lt;_id&gt;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field1&quot;: &quot;value1&quot;,</span><br><span class="line">  &quot;field2&quot;: &quot;value2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动生成 <code>_id</code>（用 POST）：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /&lt;index&gt;/_doc/</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field1&quot;: &quot;value1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2查询文档get"><a class="markdownIt-Anchor" href="#2查询文档get"></a> （2）查询文档（Get）</h5><ul><li>按 <code>_id</code> 精确查询：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /&lt;index&gt;/_doc/&lt;_id&gt;</span><br></pre></td></tr></table></figure><ul><li>查询文档是否存在：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEAD /&lt;index&gt;/_doc/&lt;_id&gt;  # 200 存在，404 不存在</span><br></pre></td></tr></table></figure><h5 id="3更新文档update"><a class="markdownIt-Anchor" href="#3更新文档update"></a> （3）更新文档（Update）</h5><ul><li>全量更新（覆盖原有文档，<code>_version</code> 自增）：直接用 <code>PUT</code> 重写文档。</li><li>局部更新（仅修改指定字段）：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /&lt;index&gt;/_doc/&lt;_id&gt;/_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;field1&quot;: &quot;new_value&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4删除文档delete"><a class="markdownIt-Anchor" href="#4删除文档delete"></a> （4）删除文档（Delete）</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /&lt;index&gt;/_doc/&lt;_id&gt;</span><br></pre></td></tr></table></figure><h4 id="2-索引操作"><a class="markdownIt-Anchor" href="#2-索引操作"></a> 2. 索引操作</h4><h5 id="1创建索引含-mapping"><a class="markdownIt-Anchor" href="#1创建索引含-mapping"></a> （1）创建索引（含 Mapping）</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PUT /&lt;index&gt;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;number_of_shards&quot;: 3,    # 主分片数量</span><br><span class="line">    &quot;number_of_replicas&quot;: 1   # 副本数量</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,       # 可分词，用于全文检索</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;  # 中文分词器</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;category&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;     # 不分词，用于精确匹配</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;double&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;create_time&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;,</span><br><span class="line">        &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2删除索引"><a class="markdownIt-Anchor" href="#2删除索引"></a> （2）删除索引</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE /&lt;index&gt;  # 删除单个索引</span><br><span class="line">DELETE /&lt;index1&gt;,&lt;index2&gt;  # 删除多个索引</span><br><span class="line">DELETE /*  # 删除所有索引（谨慎使用！）</span><br></pre></td></tr></table></figure><h5 id="3查看索引信息"><a class="markdownIt-Anchor" href="#3查看索引信息"></a> （3）查看索引信息</h5><ul><li>查看索引设置：<code>GET /&lt;index&gt;/_settings</code></li><li>查看索引 Mapping：<code>GET /&lt;index&gt;/_mapping</code></li><li>查看索引统计信息：<code>GET /&lt;index&gt;/_stats</code></li></ul><h3 id="四-查询与分析"><a class="markdownIt-Anchor" href="#四-查询与分析"></a> 四、查询与分析</h3><p>查询是 ES 的核心能力，支持全文检索、精确匹配、聚合分析等复杂场景，查询语法通过 <code>Query DSL</code>（Domain Specific Language）定义。</p><h4 id="1-查询类型分类"><a class="markdownIt-Anchor" href="#1-查询类型分类"></a> 1. 查询类型分类</h4><p>ES 的查询分为两大类：</p><table><thead><tr><th>类型</th><th>特点</th><th>代表查询</th></tr></thead><tbody><tr><td>叶子查询（Leaf Queries）</td><td>直接查询字段值，可单独使用</td><td>匹配查询（match）、精确匹配（term）、范围查询（range）</td></tr><tr><td>复合查询（Compound Queries）</td><td>组合多个叶子查询或其他复合查询</td><td>布尔查询（bool）、嵌套查询（nested）、函数评分查询（function_score）</td></tr></tbody></table><h4 id="2-常用核心查询"><a class="markdownIt-Anchor" href="#2-常用核心查询"></a> 2. 常用核心查询</h4><h5 id="1匹配查询match"><a class="markdownIt-Anchor" href="#1匹配查询match"></a> （1）匹配查询（match）</h5><ul><li>用于 <code>text</code> 类型字段的全文检索，会对查询词分词后匹配。</li><li>示例：查询“手机”相关的商品（“智能手机”“手机壳”均会匹配）：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;手机&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2精确匹配term"><a class="markdownIt-Anchor" href="#2精确匹配term"></a> （2）精确匹配（term）</h5><ul><li>用于 <code>keyword</code> 或数值类型字段的精确匹配，不对查询词分词。</li><li>示例：查询分类为“手机”的商品（仅“手机”分类匹配，“智能手机”不匹配）：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;category&quot;: &quot;手机&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3范围查询range"><a class="markdownIt-Anchor" href="#3范围查询range"></a> （3）范围查询（range）</h5><ul><li>用于数值、日期类型字段的范围筛选，支持 <code>gt</code>（&gt;）、<code>gte</code>（≥）、<code>lt</code>（&lt;）、<code>lte</code>（≤）。</li><li>示例：查询价格 1000-3000 元的商品：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: 1000,</span><br><span class="line">        &quot;lte&quot;: 3000</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4布尔查询bool"><a class="markdownIt-Anchor" href="#4布尔查询bool"></a> （4）布尔查询（bool）</h5><ul><li>组合多个子查询，通过 <code>must</code>（必须匹配）、<code>should</code>（可选匹配，加分）、<code>must_not</code>（必须不匹配）、<code>filter</code>（过滤，不影响评分）控制逻辑。</li><li>示例：查询分类为“手机”、价格 1000-3000 元、标题含“华为”的商品：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;&quot;term&quot;: &#123;&quot;category&quot;: &quot;手机&quot;&#125;&#125;,</span><br><span class="line">        &#123;&quot;match&quot;: &#123;&quot;title&quot;: &quot;华为&quot;&#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &#123;&quot;range&quot;: &#123;&quot;price&quot;: &#123;&quot;gte&quot;: 1000, &quot;lte&quot;: 3000&#125;&#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-聚合分析aggregation"><a class="markdownIt-Anchor" href="#3-聚合分析aggregation"></a> 3. 聚合分析（Aggregation）</h4><p>聚合用于对查询结果进行统计分析（如分组、求和、排序），类似 SQL 的 <code>GROUP BY</code> + 聚合函数，分为<strong>桶聚合（Bucket）</strong> 和<strong>指标聚合（Metric）</strong>。</p><h5 id="1桶聚合bucket"><a class="markdownIt-Anchor" href="#1桶聚合bucket"></a> （1）桶聚合（Bucket）</h5><ul><li>按条件对数据分组，每个组称为一个“桶”，如按分类分组、按价格区间分组。</li><li>示例：按“category”字段分组，统计每个分类的商品数量：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,  # 不返回原始文档，仅返回聚合结果</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;category_count&quot;: &#123;  # 聚合名称（自定义）</span><br><span class="line">      &quot;terms&quot;: &#123;  # 桶聚合类型：按字段值分组</span><br><span class="line">        &quot;field&quot;: &quot;category&quot;,</span><br><span class="line">        &quot;size&quot;: 10  # 返回前 10 个分组</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2指标聚合metric"><a class="markdownIt-Anchor" href="#2指标聚合metric"></a> （2）指标聚合（Metric）</h5><ul><li>对桶内数据进行数值计算，如求和、平均值、最大值等。</li><li>示例：按分类分组，统计每个分类的商品平均价格：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;category_avg_price&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;&quot;field&quot;: &quot;category&quot;&#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;  # 嵌套指标聚合</span><br><span class="line">        &quot;avg_price&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;&quot;field&quot;: &quot;price&quot;&#125;  # 指标聚合类型：求平均值</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五-分词器analyzer"><a class="markdownIt-Anchor" href="#五-分词器analyzer"></a> 五、分词器（Analyzer）</h3><p>分词是全文检索的核心步骤，将文本拆分为可索引的“词条（Term）”，ES 的分词能力依赖于分词器。</p><h4 id="1-分词器组成"><a class="markdownIt-Anchor" href="#1-分词器组成"></a> 1. 分词器组成</h4><p>一个完整的分词器由 3 部分组成：</p><ol><li><strong>Character Filter（字符过滤器）</strong>：预处理文本（如去除 HTML 标签、替换特殊字符），可选。</li><li><strong>Tokenizer（分词器）</strong>：将文本拆分为词条（如按空格、标点拆分），必须。</li><li><strong>Token Filter（词条过滤器）</strong>：处理词条（如小写转换、停用词移除、同义词替换），可选。</li></ol><h4 id="2-内置分词器"><a class="markdownIt-Anchor" href="#2-内置分词器"></a> 2. 内置分词器</h4><ul><li><strong>Standard Analyzer</strong>：默认分词器，按 Unicode 文本分割，小写转换，移除标点。</li><li><strong>Simple Analyzer</strong>：按非字母字符分割，小写转换。</li><li><strong>Whitespace Analyzer</strong>：仅按空格分割，不做其他处理。</li><li><strong>Keyword Analyzer</strong>：不分词，将整个文本作为一个词条。</li></ul><h4 id="3-中文分词器"><a class="markdownIt-Anchor" href="#3-中文分词器"></a> 3. 中文分词器</h4><p>内置分词器对中文支持差（如将“我爱中国”拆分为“我”“爱”“中”“国”），需引入第三方分词器：</p><ul><li><strong>IK Analyzer</strong>：最常用的中文分词器，支持自定义词典，有两种模式：<ul><li><code>ik_max_word</code>：最大粒度分词（如“中华人民共和国”→“中华人民共和国”“中华人民”“中华”“中国”等）。</li><li><code>ik_smart</code>：</li></ul></li></ul>]]></content>
    
    
    <summary type="html">Elasticsearch知识点详细总结</summary>
    
    
    
    <category term="数据库" scheme="http://www.formeasy.cc/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Elasticsearch" scheme="http://www.formeasy.cc/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>开发中常用素材格式完整清单（适用于前后端、全栈及各领域研发工程师）</title>
    <link href="http://www.formeasy.cc/2025/10/03/Other/%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B4%A0%E6%9D%90%E6%A0%BC%E5%BC%8F%E5%AE%8C%E6%95%B4%E6%B8%85%E5%8D%95%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E3%80%81%E5%85%A8%E6%A0%88%E5%8F%8A%E5%90%84%E9%A2%86%E5%9F%9F%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%89/"/>
    <id>http://www.formeasy.cc/2025/10/03/Other/%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%B4%A0%E6%9D%90%E6%A0%BC%E5%BC%8F%E5%AE%8C%E6%95%B4%E6%B8%85%E5%8D%95%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E3%80%81%E5%85%A8%E6%A0%88%E5%8F%8A%E5%90%84%E9%A2%86%E5%9F%9F%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%89/</id>
    <published>2025-10-03T13:29:38.000Z</published>
    <updated>2025-10-03T13:37:49.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开发中常用素材格式完整清单适用于前后端-全栈及各领域研发工程师"><a class="markdownIt-Anchor" href="#开发中常用素材格式完整清单适用于前后端-全栈及各领域研发工程师"></a> 开发中常用素材格式完整清单（适用于前后端、全栈及各领域研发工程师）</h2><p>在软件开发过程中，无论是构建 Web 应用、移动 App、桌面程序还是 AI 系统，开发者都会接触到各种类型的<strong>数字素材</strong>。这些素材不仅是产品功能的组成部分，也直接影响用户体验、性能和可维护性。</p><p>本文整理了一份<strong>全面、分类清晰、跨领域</strong>的开发常用素材格式清单，适用于：</p><ul><li>✅ 前端工程师</li><li>✅ 后端工程师</li><li>✅ 全栈工程师</li><li>✅ 移动开发工程师（iOS/Android）</li><li>✅ 数据科学家 / AI 工程师</li><li>✅ DevOps 工程师</li><li>✅ UI/UX 设计师与开发者协作场景</li></ul><hr /><h3 id="一-图像素材images"><a class="markdownIt-Anchor" href="#一-图像素材images"></a> 📁 一、图像素材（Images）</h3><table><thead><tr><th>格式</th><th>全称</th><th>特点</th><th>适用场景</th><th>开发者用途</th></tr></thead><tbody><tr><td><strong>JPEG / JPG</strong></td><td>Joint Photographic Experts Group</td><td>有损压缩，文件小，支持真彩色</td><td>照片、背景图、用户上传图片</td><td>前端展示、后端存储、CDN 分发</td></tr><tr><td><strong>PNG</strong></td><td>Portable Network Graphics</td><td>无损压缩，支持透明通道（Alpha）</td><td>Logo、图标、需要透明背景的图像</td><td>前端 UI 元素、SVG 替代方案</td></tr><tr><td><strong>GIF</strong></td><td>Graphics Interchange Format</td><td>支持动画，256 色，支持透明</td><td>简单动画、loading 效果</td><td>前端动效、提示动画</td></tr><tr><td><strong>WebP</strong></td><td>Web Picture Format (Google)</td><td>高压缩率，支持有损/无损 + 透明 + 动画</td><td>Web 图片优化，替代 JPEG/PNG</td><td>前端性能优化，节省带宽</td></tr><tr><td><strong>AVIF</strong></td><td>AV1 Image File Format</td><td>新一代高效压缩格式，优于 WebP</td><td>高质量图片，未来 Web 标准</td><td>前端实验性支持，渐进增强</td></tr><tr><td><strong>SVG</strong></td><td>Scalable Vector Graphics</td><td>矢量图，XML 格式，无限缩放不失真</td><td>图标、Logo、图表、UI 组件</td><td>前端内联使用、动态修改样式</td></tr><tr><td><strong>ICO</strong></td><td>Icon Format</td><td>Windows 图标格式，支持多尺寸</td><td>网站 favicon、桌面应用图标</td><td>前端 <code>&lt;link rel=&quot;icon&quot;&gt;</code></td></tr><tr><td><strong>BMP</strong></td><td>Bitmap</td><td>无压缩，文件大</td><td>基本图像处理教学</td><td>一般不用于生产环境</td></tr></tbody></table><blockquote><p>🔧 <strong>开发者建议</strong>：优先使用 WebP + SVG，提供 JPEG/PNG 回退。</p></blockquote><hr /><h3 id="二-音频素材audio"><a class="markdownIt-Anchor" href="#二-音频素材audio"></a> 🎵 二、音频素材（Audio）</h3><table><thead><tr><th>格式</th><th>全称</th><th>特点</th><th>适用场景</th><th>开发者用途</th></tr></thead><tbody><tr><td><strong>MP3</strong></td><td>MPEG-1 Audio Layer III</td><td>有损压缩，兼容性极广</td><td>背景音乐、语音播放</td><td>前端 <code>&lt;audio&gt;</code>、App 内嵌播放</td></tr><tr><td><strong>WAV</strong></td><td>Waveform Audio File Format</td><td>无损，文件大，PCM 编码</td><td>专业音频处理、录音</td><td>后端语音识别输入</td></tr><tr><td><strong>OGG</strong></td><td>Ogg Vorbis</td><td>开源有损压缩，Web 友好</td><td>Web 游戏音效、HTML5 音频</td><td>前端替代 MP3（免版权）</td></tr><tr><td><strong>AAC</strong></td><td>Advanced Audio Coding</td><td>高效压缩，音质好</td><td>iOS 系统、视频伴音</td><td>移动 App、流媒体</td></tr><tr><td><strong>FLAC</strong></td><td>Free Lossless Audio Codec</td><td>无损压缩，开源</td><td>音乐存档、高保真播放</td><td>音乐类 App、专业音频平台</td></tr><tr><td><strong>M4A</strong></td><td>MPEG-4 Audio</td><td>基于 AAC，苹果生态常用</td><td>iTunes、播客</td><td>iOS App 音频资源</td></tr></tbody></table><blockquote><p>🔧 <strong>开发者建议</strong>：Web 使用 <code>MP3 + OGG</code> 多格式支持；AI 语音处理优先用 <code>WAV</code>。</p></blockquote><hr /><h3 id="三-视频素材video"><a class="markdownIt-Anchor" href="#三-视频素材video"></a> 🎥 三、视频素材（Video）</h3><table><thead><tr><th>格式</th><th>全称</th><th>特点</th><th>适用场景</th><th>开发者用途</th></tr></thead><tbody><tr><td><strong>MP4</strong></td><td>MPEG-4 Part 14</td><td>H.264/H.265 编码，兼容性好</td><td>Web 视频、App 播放</td><td>前端 <code>&lt;video&gt;</code>、移动端播放</td></tr><tr><td><strong>WebM</strong></td><td>Web Media Format (Google)</td><td>VP8/VP9 编码，开源免费</td><td>Web 视频，替代 MP4</td><td>前端性能优化，免版权</td></tr><tr><td><strong>AVI</strong></td><td>Audio Video Interleave</td><td>微软格式，文件大</td><td>旧系统兼容</td><td>一般不用于新项目</td></tr><tr><td><strong>MOV</strong></td><td>QuickTime Movie</td><td>苹果格式，高质量</td><td>iOS 录制、专业剪辑</td><td>iOS App 视频上传处理</td></tr><tr><td><strong>MKV</strong></td><td>Matroska Video</td><td>支持多音轨、字幕，封装能力强</td><td>视频存档、高清资源</td><td>后端转码输入</td></tr><tr><td><strong>FLV</strong></td><td>Flash Video</td><td>旧式流媒体格式</td><td>逐步淘汰</td><td>仅维护老系统</td></tr></tbody></table><blockquote><p>🔧 <strong>开发者建议</strong>：Web 推荐 <code>MP4 (H.264) + WebM</code> 双格式；使用 FFmpeg 进行转码。</p></blockquote><hr /><h3 id="四-文档与数据格式documents-data"><a class="markdownIt-Anchor" href="#四-文档与数据格式documents-data"></a> 📄 四、文档与数据格式（Documents &amp; Data）</h3><table><thead><tr><th>格式</th><th>类型</th><th>特点</th><th>适用场景</th><th>开发者用途</th></tr></thead><tbody><tr><td><strong>JSON</strong></td><td>数据交换</td><td>轻量、易读、JavaScript 原生支持</td><td>API 返回、配置文件、前后端通信</td><td>全栈通用，必会格式</td></tr><tr><td><strong>XML</strong></td><td>标记语言</td><td>结构化强，支持 Schema</td><td>SOAP、RSS、Android 布局</td><td>后端接口、配置文件</td></tr><tr><td><strong>YAML</strong></td><td>配置文件</td><td>缩进语法，人类友好</td><td>Docker Compose、K8s 配置、CI/CD</td><td>DevOps、微服务配置</td></tr><tr><td><strong>CSV</strong></td><td>文本数据</td><td>简单表格，Excel 友好</td><td>数据导入导出、批量处理</td><td>后端数据处理、BI 分析</td></tr><tr><td><strong>PDF</strong></td><td>文档</td><td>跨平台、排版固定</td><td>合同、报告、电子书</td><td>后端生成（如 Puppeteer）、前端预览</td></tr><tr><td><strong>Markdown (.md)</strong></td><td>轻量标记</td><td>易写易读，支持 HTML</td><td>技术文档、README、博客</td><td>前端渲染（如 VuePress）</td></tr><tr><td><strong>Excel (.xlsx/.xls)</strong></td><td>表格</td><td>支持公式、样式</td><td>财务、报表、运营数据</td><td>后端读取（如 Apache POI）</td></tr></tbody></table><blockquote><p>🔧 <strong>开发者建议</strong>：API 优先用 JSON；配置用 YAML；文档用 Markdown。</p></blockquote><hr /><h3 id="五-uiux-与设计资源designer-handoff"><a class="markdownIt-Anchor" href="#五-uiux-与设计资源designer-handoff"></a> 🎨 五、UI/UX 与设计资源（Designer Handoff）</h3><table><thead><tr><th>格式</th><th>工具</th><th>说明</th><th>开发者用途</th></tr></thead><tbody><tr><td><strong>Figma (.fig)</strong></td><td>Figma</td><td>实时协作设计工具</td><td>前端提取尺寸、颜色、图标</td></tr><tr><td><strong>Sketch (.sketch)</strong></td><td>Sketch</td><td>macOS 原生设计工具</td><td>导出切图、样式变量</td></tr><tr><td><strong>Adobe XD (.xd)</strong></td><td>Adobe</td><td>UI/UX 设计</td><td>获取设计规范</td></tr><tr><td><strong>PSD</strong></td><td>Photoshop</td><td>图像编辑</td><td>旧项目切图提取</td></tr><tr><td><strong>XCF</strong></td><td>GIMP</td><td>开源图像编辑</td><td>开源项目资源</td></tr><tr><td><strong>Lottie (.json)</strong></td><td>Airbnb</td><td>JSON 格式的动画</td><td>前端/移动端嵌入高性能动画</td></tr><tr><td><strong>Motion Design (After Effects)</strong></td><td>AE</td><td>复杂动画</td><td>导出为视频或 Lottie</td></tr></tbody></table><blockquote><p>🔧 <strong>开发者建议</strong>：与设计师约定使用 Figma + Lottie，提升协作效率。</p></blockquote><hr /><h3 id="六-ai-与机器学习素材格式"><a class="markdownIt-Anchor" href="#六-ai-与机器学习素材格式"></a> 🧠 六、AI 与机器学习素材格式</h3><table><thead><tr><th>格式</th><th>用途</th><th>说明</th><th>开发者用途</th></tr></thead><tbody><tr><td><strong>.h5 / .hdf5</strong></td><td>模型保存</td><td>Keras/TensorFlow 模型</td><td>加载预训练模型</td></tr><tr><td><strong>.pb</strong></td><td>Protocol Buffer</td><td>TensorFlow 冻结图</td><td>模型部署</td></tr><tr><td><strong>.onnx</strong></td><td>Open Neural Network Exchange</td><td>跨框架模型交换</td><td>模型转换与部署</td></tr><tr><td><strong>.pt / .pth</strong></td><td>PyTorch</td><td>PyTorch 模型权重</td><td>深度学习训练与推理</td></tr><tr><td><strong>.tflite</strong></td><td>TensorFlow Lite</td><td>移动端轻量模型</td><td>Android/iOS 集成</td></tr><tr><td><strong>.npy / .npz</strong></td><td>NumPy</td><td>数组数据存储</td><td>数据预处理、特征保存</td></tr><tr><td><strong>.parquet</strong></td><td>列式存储</td><td>大数据高效存储</td><td>数据湖、AI 训练数据集</td></tr></tbody></table><blockquote><p>🔧 <strong>开发者建议</strong>：生产部署优先使用 ONNX 或 TFLite 提升兼容性。</p></blockquote><hr /><h3 id="️-七-开发与部署资源格式"><a class="markdownIt-Anchor" href="#️-七-开发与部署资源格式"></a> 🛠️ 七、开发与部署资源格式</h3><table><thead><tr><th>格式</th><th>说明</th><th>用途</th></tr></thead><tbody><tr><td><strong>Dockerfile</strong></td><td>容器构建脚本</td><td>定义镜像构建流程</td></tr><tr><td><strong>.tar / .tar.gz / .zip</strong></td><td>压缩包</td><td>代码打包、资源分发</td></tr><tr><td><strong>.jar / .war</strong></td><td>Java 归档</td><td>Java 应用打包</td></tr><tr><td><strong>.exe / .msi</strong></td><td>Windows 可执行</td><td>桌面应用分发</td></tr><tr><td><strong>.dmg / .pkg</strong></td><td>macOS 安装包</td><td>Mac 应用发布</td></tr><tr><td><strong>.apk / .aab</strong></td><td>Android 应用</td><td>Android App 发布</td></tr><tr><td><strong>.ipa</strong></td><td>iOS 应用</td><td>iOS App 上架</td></tr><tr><td><strong>.env</strong></td><td>环境变量</td><td>存储配置（数据库密码等）</td></tr><tr><td><strong>.pem / .crt / .key</strong></td><td>证书</td><td>HTTPS、SSL 加密通信</td></tr></tbody></table><hr /><h3 id="八-字体素材fonts"><a class="markdownIt-Anchor" href="#八-字体素材fonts"></a> 🧩 八、字体素材（Fonts）</h3><table><thead><tr><th>格式</th><th>说明</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>WOFF / WOFF2</strong></td><td>Web 字体</td><td>Web 使用，压缩优化</td></tr><tr><td><strong>TTF / OTF</strong></td><td>TrueType / OpenType</td><td>桌面应用、设计软件</td></tr><tr><td><strong>EOT</strong></td><td>Embedded OpenType</td><td>旧版 IE 兼容</td></tr><tr><td><strong>SVG Fonts</strong></td><td>矢量字体</td><td>旧式图标字体</td></tr></tbody></table><blockquote><p>🔧 <strong>建议</strong>：Web 使用 <code>WOFF2</code>，通过 <code>@font-face</code> 引入。</p></blockquote><hr /><h3 id="九-开发者使用建议总结"><a class="markdownIt-Anchor" href="#九-开发者使用建议总结"></a> ✅ 九、开发者使用建议总结</h3><table><thead><tr><th>场景</th><th>推荐格式</th></tr></thead><tbody><tr><td><strong>Web 图片</strong></td><td>WebP + SVG + JPEG/PNG 回退</td></tr><tr><td><strong>Web 音频</strong></td><td>MP3 + OGG</td></tr><tr><td><strong>Web 视频</strong></td><td>MP4 (H.264) + WebM</td></tr><tr><td><strong>API 数据</strong></td><td>JSON</td></tr><tr><td><strong>配置文件</strong></td><td>YAML</td></tr><tr><td><strong>文档协作</strong></td><td>Markdown</td></tr><tr><td><strong>动画效果</strong></td><td>Lottie (.json)</td></tr><tr><td><strong>AI 模型</strong></td><td>ONNX / TFLite / PyTorch (.pt)</td></tr><tr><td><strong>字体</strong></td><td>WOFF2</td></tr><tr><td><strong>设计交接</strong></td><td>Figma / Lottie</td></tr></tbody></table><hr /><h3 id="十-附录跨领域素材使用场景对照表"><a class="markdownIt-Anchor" href="#十-附录跨领域素材使用场景对照表"></a> 📌 十、附录：跨领域素材使用场景对照表</h3><table><thead><tr><th>领域</th><th>常用素材格式</th></tr></thead><tbody><tr><td><strong>前端开发</strong></td><td>WebP, SVG, JSON, CSS, WOFF2, Lottie, Markdown</td></tr><tr><td><strong>后端开发</strong></td><td>JSON, XML, CSV, PDF, YAML, .env, .pem</td></tr><tr><td><strong>移动开发</strong></td><td>PNG, WebP, MP4, AAC, .apk/.ipa, .tflite</td></tr><tr><td><strong>全栈开发</strong></td><td>全部上述格式</td></tr><tr><td><strong>AI/数据科学</strong></td><td>.npy, .parquet, .h5, .onnx, .pt, CSV, JSON</td></tr><tr><td><strong>DevOps</strong></td><td>YAML, .tar.gz, Dockerfile, .pem, .env</td></tr><tr><td><strong>游戏开发</strong></td><td>PNG, WebP, MP3, WAV, GLB (3D), JSON (配置)</td></tr><tr><td><strong>物联网 (IoT)</strong></td><td>JSON, CSV, .bin (固件), .crt (证书)</td></tr></tbody></table><hr /><h3 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 🎯 结语</h3><p>掌握各类素材格式的特点与适用场景，是现代研发工程师的<strong>基本功</strong>。无论你是前端、后端、全栈还是 AI 工程师，都需要与这些“数字资产”打交道。</p><blockquote><p><strong>核心原则</strong>：</p><ul><li><strong>性能优先</strong>：选择压缩率高、加载快的格式</li><li><strong>兼容性保障</strong>：考虑浏览器/设备支持</li><li><strong>协作高效</strong>：与设计师、数据科学家使用通用格式</li><li><strong>安全合规</strong>：避免使用有版权风险的素材</li></ul></blockquote><hr /><p>📌 <strong>建议收藏</strong>：将本文作为团队内部知识库，统一素材使用规范，提升开发效率与产品质量。</p>]]></content>
    
    
    <summary type="html">开发中常用素材格式完整清单（适用于前后端、全栈及各领域研发工程师）</summary>
    
    
    
    <category term="资源" scheme="http://www.formeasy.cc/categories/%E8%B5%84%E6%BA%90/"/>
    
    
    <category term="Other" scheme="http://www.formeasy.cc/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 RAG：原理、流程与代码实战</title>
    <link href="http://www.formeasy.cc/2025/09/21/ollama/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20RAG%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/"/>
    <id>http://www.formeasy.cc/2025/09/21/ollama/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20RAG%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/</id>
    <published>2025-09-21T03:22:29.000Z</published>
    <updated>2025-09-21T03:28:03.559Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-引言为什么需要-rag"><a class="markdownIt-Anchor" href="#1-引言为什么需要-rag"></a> 1. 引言：为什么需要 RAG？</h3><p>在当今人工智能浪潮中，大型语言模型（LLM）如 GPT、LLaMA、ChatGLM 等已经展现了令人惊叹的能力，无论是在对话、创作还是代码生成方面。然而，当我们真正将它们应用于企业级或专业化场景时，会发现它们存在几个致命的“硬伤”：</p><ol><li><strong>知识滞后与静态性</strong>：LLM 的参数化知识来自于其训练时的数据快照。对于训练截止日期之后的事件、新闻、研究进展或公司内部的最新文档，模型一无所知，甚至会“一本正经地胡说八道”（幻觉现象）。</li><li><strong>缺乏领域特异性</strong>：一个通用的 LLM 可能对医学、法律或金融等专业领域的深度知识掌握不足，难以给出高度精准和可靠的答案。</li><li><strong>透明性与可追溯性缺失</strong>：LLM 的回答像一个“黑箱”，我们无法得知其生成答案的具体依据来源，这在严肃的应用场景中是不可接受的。</li></ol><p><strong>那么，如何让强大的 LLM 具备获取最新、特定知识的能力，同时还能提供可靠的依据呢？</strong></p><p>答案就是 <strong>RAG (Retrieval-Augmented Generation，检索增强生成)</strong>。</p><p>RAG 巧妙地将<strong>信息检索（IR）</strong> 技术与<strong>大语言模型（LLM）</strong> 相结合，就像是给一位博学但记忆停留在过去的学者（LLM）配备了一位高效、实时的图书管理员（检索系统）。在回答问题时，图书管理员会迅速从最新的知识库（如公司文档、数据库、网页）中查找相关资料，交给学者。学者基于这些最新的、准确的资料，组织语言，生成最终答案。</p><p>这种方法不仅解决了知识更新问题，还通过提供引用来源极大地增强了答案的可信度和可解释性。</p><p>本文将深入剖析 RAG 的核心原理、主要流程，并通过代码示例带你实战一个简单的 RAG 系统。</p><h3 id="2-rag-是什么"><a class="markdownIt-Anchor" href="#2-rag-是什么"></a> 2. RAG 是什么？</h3><p>RAG 的概念最早由 Meta (Facebook) 的研究团队在 2020 年的论文《Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks》中提出。</p><p>其核心思想可以概括为：<strong>“先检索，再生成”</strong>。</p><p>它不是通过重新训练或微调（Fine-tuning）LLM 来更新其知识，而是在模型<strong>外部</strong>挂载一个知识库。在收到用户查询（Query）时，RAG 系统会首先从这个外部知识库中检索出与问题最相关的信息片段（Context），然后将<strong>原始问题</strong>和<strong>检索到的上下文</strong>一并打包，发送给 LLM，指令 LLM 基于给定的上下文来回答问题。</p><p>这样做的好处是：</p><ul><li><strong>成本低</strong>：无需重新训练昂贵的 LLM。</li><li><strong>更新快</strong>：只需更新外部知识库（如插入新的文档），LLM 立即就能获取到新知识。</li><li><strong>可信度高</strong>：答案来源于提供的上下文，减少幻觉，且可溯源。</li></ul><h3 id="3-rag-的主要流程"><a class="markdownIt-Anchor" href="#3-rag-的主要流程"></a> 3. RAG 的主要流程</h3><p>一个典型的 RAG 流程可以分解为两个核心阶段：<strong>索引（Indexing）</strong> 和<strong>推理（Inference）</strong>。</p><h4 id="31-索引阶段indexing-data-preparation"><a class="markdownIt-Anchor" href="#31-索引阶段indexing-data-preparation"></a> 3.1 索引阶段（Indexing / Data Preparation）</h4><p>索引阶段是“备课”的过程，目的是将原始的非结构化文档（如 PDF、Word、TXT、网页）处理成便于快速检索的结构化格式。这个过程是离线的，通常只需执行一次或在数据更新时重复。</p><p>其主要步骤如下：</p><p><strong>1. 加载（Loading）</strong>：<br />使用文档加载器（Document Loader）从各种数据源读取原始数据，并将其转换成统一的文档对象（Document）。每个文档对象通常包含文本内容及其元数据（如来源、创建日期等）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：使用 LangChain 的 PyPDFLoader 加载 PDF</span></span><br><span class="line"><span class="keyword">from</span> langchain.document_loaders <span class="keyword">import</span> PyPDFLoader</span><br><span class="line"></span><br><span class="line">loader = PyPDFLoader(<span class="string">&quot;path/to/your/document.pdf&quot;</span>)</span><br><span class="line">documents = loader.load()</span><br></pre></td></tr></table></figure><p><strong>2. 分割（Splitting）</strong>：<br />LLM 有上下文长度限制，因此需要将长文档切分成更小的、语义完整的文本块（Chunks）。这一步至关重要， chunk 的大小和质量直接影响检索效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：使用 LangChain 的 RecursiveCharacterTextSplitter 进行文本分割</span></span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br><span class="line"></span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter(</span><br><span class="line">    chunk_size=<span class="number">500</span>,  <span class="comment"># 每个 chunk 的大小</span></span><br><span class="line">    chunk_overlap=<span class="number">50</span> <span class="comment"># chunk 之间的重叠部分，避免语义断裂</span></span><br><span class="line">)</span><br><span class="line">docs = text_splitter.split_documents(documents)</span><br></pre></td></tr></table></figure><p><strong>3. 嵌入（Embedding）</strong>：<br />使用<strong>嵌入模型（Embedding Model）</strong> 将每个文本块转换成一个高维向量（Vector）。这个向量就像是文本的“数学指纹”，语义相近的文本块其向量在向量空间中的距离也更近。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：使用 OpenAI 的 text-embedding-ada-002 模型生成嵌入向量</span></span><br><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line"></span><br><span class="line">embeddings_model = OpenAIEmbeddings(model=<span class="string">&quot;text-embedding-ada-002&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>4. 存储（Storing）</strong>：<br />将上一步生成的文本块（原始文本）和其对应的向量<strong>索引（Index）</strong> 起来，存入<strong>向量数据库（Vector Database）</strong> 中。向量数据库专门为高效的海量向量相似性搜索而设计。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：使用 Chroma 向量数据库并存储向量</span></span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> Chroma</span><br><span class="line"></span><br><span class="line">vectorstore = Chroma.from_documents(</span><br><span class="line">    documents=docs,</span><br><span class="line">    embedding=embeddings_model,</span><br><span class="line">    persist_directory=<span class="string">&quot;./chroma_db&quot;</span>  <span class="comment"># 指定持久化目录</span></span><br><span class="line">)</span><br><span class="line">vectorstore.persist() <span class="comment"># 持久化到磁盘</span></span><br></pre></td></tr></table></figure><h4 id="32-推理阶段inference-retrieval-generation"><a class="markdownIt-Anchor" href="#32-推理阶段inference-retrieval-generation"></a> 3.2 推理阶段（Inference / Retrieval &amp; Generation）</h4><p>推理阶段是“答题”的过程，在线处理用户的查询。</p><p><strong>1. 检索（Retrieval）</strong>：</p><ul><li>用户输入一个查询（Query）。</li><li>系统使用与索引阶段<strong>相同的嵌入模型</strong>，将用户的查询也转换为一个查询向量（Query Vector）。</li><li>系统在向量数据库中进行<strong>相似性搜索（Similarity Search）</strong>，找出与查询向量最相似的 K 个文本块（K 是可设定的参数）。这些被检索到的文本块就是与问题最相关的上下文（Context）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户查询</span></span><br><span class="line">query = <span class="string">&quot;什么是机器学习？&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将查询转换为向量并进行相似性检索</span></span><br><span class="line">retrieved_docs = vectorstore.similarity_search(query, k=<span class="number">3</span>) <span class="comment"># 检索最相似的 3 个片段</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印检索结果</span></span><br><span class="line"><span class="keyword">for</span> doc <span class="keyword">in</span> retrieved_docs:</span><br><span class="line">    <span class="built_in">print</span>(doc.page_content)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>2. 增强（Augmentation）</strong>：<br />将检索到的多个文本块（Context）和用户的原始查询（Query）按照预设的<strong>提示模板（Prompt Template）</strong> 组合成一个新的、增强后的提示（Augmented Prompt）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个提示模板</span></span><br><span class="line">template = <span class="string">&quot;&quot;&quot;请根据以下上下文信息回答问题。如果你不知道答案，就说不知道，不要编造答案。</span></span><br><span class="line"><span class="string">上下文：</span></span><br><span class="line"><span class="string">&#123;context&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">问题：&#123;question&#125;</span></span><br><span class="line"><span class="string">请给出答案：&quot;&quot;&quot;</span></span><br><span class="line">prompt = PromptTemplate.from_template(template)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合提示</span></span><br><span class="line">context = <span class="string">&quot;\n\n&quot;</span>.join([doc.page_content <span class="keyword">for</span> doc <span class="keyword">in</span> retrieved_docs])</span><br><span class="line">augmented_prompt = prompt.<span class="built_in">format</span>(context=context, question=query)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(augmented_prompt)</span><br></pre></td></tr></table></figure><p><strong>3. 生成（Generation）</strong>：<br />将组合好的增强提示（Augmented Prompt）发送给 LLM。LLM 会严格基于提供的上下文来生成最终答案，而不是依赖其内部可能过时或不准确的知识。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：使用 OpenAI 的 GPT 模型进行生成</span></span><br><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line">llm = OpenAI(model_name=<span class="string">&quot;gpt-3.5-turbo-instruct&quot;</span>)</span><br><span class="line">answer = llm(augmented_prompt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;最终答案：\n<span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-流程图"><a class="markdownIt-Anchor" href="#4-流程图"></a> 4. 流程图</h3><p>下图清晰地展示了 RAG 两个阶段的数据流与核心组件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[RAG 流程]</span><br><span class="line"></span><br><span class="line">    subgraph S1 [第一阶段：索引（离线）]</span><br><span class="line">        direction LR</span><br><span class="line">        A1[原始文档] --&gt;|加载| B1[文档加载器]</span><br><span class="line">        B1 --&gt; C1[长文本]</span><br><span class="line">        C1 --&gt;|分割| D1[文本块 Chunks]</span><br><span class="line">        D1 --&gt;|嵌入| E1[向量 Vector]</span><br><span class="line">        E1 --&gt;|存储| F1[向量数据库]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph S2 [第二阶段：推理（在线）]</span><br><span class="line">        direction TB</span><br><span class="line">        G[用户查询] --&gt;|嵌入| H[查询向量]</span><br><span class="line">        H --&gt;|相似性检索| F1</span><br><span class="line">        F1 --&gt; I[Top-K 相关文本块]</span><br><span class="line">        I --&gt; J[提示工程： 组合查询与上下文]</span><br><span class="line">        J --&gt; K[增强的提示]</span><br><span class="line">        K --&gt; L[大语言模型 LLM]</span><br><span class="line">        L --&gt; M[最终答案]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    S1 --&gt; S2</span><br></pre></td></tr></table></figure><h3 id="5-代码实战构建一个简单的-rag-问答系统"><a class="markdownIt-Anchor" href="#5-代码实战构建一个简单的-rag-问答系统"></a> 5. 代码实战：构建一个简单的 RAG 问答系统</h3><p>下面我们使用 <code>LangChain</code>（一个流行的 LLM 应用开发框架）和 <code>Chroma</code>（轻量级向量数据库）来快速搭建一个 RAG 系统。</p><p><strong>环境准备：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install langchain openai chromadb tiktoken pypdf</span><br></pre></td></tr></table></figure><p><strong>完整代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> langchain.document_loaders <span class="keyword">import</span> PyPDFLoader</span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> Chroma</span><br><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 OpenAI API Key</span></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&quot;你的-OpenAI-API-Key&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 索引阶段（假设我们有一个叫做 &#x27;ml_book.pdf&#x27; 的文档）</span></span><br><span class="line">loader = PyPDFLoader(<span class="string">&quot;ml_book.pdf&quot;</span>)</span><br><span class="line">documents = loader.load()</span><br><span class="line"></span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter(chunk_size=<span class="number">1000</span>, chunk_overlap=<span class="number">100</span>)</span><br><span class="line">docs = text_splitter.split_documents(documents)</span><br><span class="line"></span><br><span class="line">embeddings = OpenAIEmbeddings()</span><br><span class="line">vectorstore = Chroma.from_documents(documents=docs, embedding=embeddings, persist_directory=<span class="string">&quot;./rag_chroma_db&quot;</span>)</span><br><span class="line">vectorstore.persist() <span class="comment"># 持久化，之后只需加载即可，无需重复索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 推理阶段</span></span><br><span class="line">query = <span class="string">&quot;机器学习的定义是什么？&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从磁盘加载已存在的向量数据库</span></span><br><span class="line"><span class="comment"># db = Chroma(persist_directory=&quot;./rag_chroma_db&quot;, embedding_function=embeddings)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检索</span></span><br><span class="line">retriever = vectorstore.as_retriever(search_kwargs=&#123;<span class="string">&quot;k&quot;</span>: <span class="number">3</span>&#125;)</span><br><span class="line">relevant_docs = retriever.get_relevant_documents(query)</span><br><span class="line">context = <span class="string">&quot;\n\n&quot;</span>.join([doc.page_content <span class="keyword">for</span> doc <span class="keyword">in</span> relevant_docs])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建提示</span></span><br><span class="line">prompt_template = <span class="string">&quot;&quot;&quot;你是一个专业的AI助手。请严格仅根据以下提供的上下文信息来回答问题。</span></span><br><span class="line"><span class="string">如果上下文中的信息不足以回答这个问题，请直接回答&quot;根据提供的资料，我无法回答这个问题。&quot;。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上下文：</span></span><br><span class="line"><span class="string">&#123;context&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">问题：&#123;question&#125;</span></span><br><span class="line"><span class="string">请给出答案：&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">prompt = PromptTemplate(</span><br><span class="line">    template=prompt_template, input_variables=[<span class="string">&quot;context&quot;</span>, <span class="string">&quot;question&quot;</span>]</span><br><span class="line">)</span><br><span class="line">formatted_prompt = prompt.<span class="built_in">format</span>(context=context, question=query)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成</span></span><br><span class="line">llm = OpenAI(temperature=<span class="number">0</span>) <span class="comment"># temperature=0 使输出更确定</span></span><br><span class="line">answer = llm(formatted_prompt)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;用户问题: <span class="subst">&#123;query&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n检索到并送入LLM的上下文: \n<span class="subst">&#123;context&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nLLM生成的最终答案: \n<span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="6-总结与展望"><a class="markdownIt-Anchor" href="#6-总结与展望"></a> 6. 总结与展望</h3><p>RAG 通过将其强大的生成能力与外部知识源的可信性、实时性相结合，成功地解决了纯 LLM 应用的诸多痛点。它已成为构建企业级知识库问答、智能客服、代码辅助等应用的首选架构。</p><p><strong>RAG 的优势：</strong></p><ul><li><strong>知识实时性</strong>：轻松接入最新信息。</li><li><strong>成本效益</strong>：避免重复训练大模型。</li><li><strong>可信可控</strong>：答案有据可依，来源可追溯，风险可控。</li><li><strong>灵活性</strong>：可以为不同领域快速构建专属问答系统。</li></ul><p><strong>RAG 的挑战与进阶方向：</strong></p><ul><li><strong>检索质量</strong>：如何提升 chunk 的质量、优化检索器（如使用重排序 Re-Ranking）以找到最相关的上下文。</li><li><strong>上下文长度</strong>：如何应对检索到的上下文过长，超出 LLM 窗口限制的问题（如通过 Map-Reduce 等摘要技巧）。</li><li><strong>多模态 RAG</strong>：未来不仅检索文本，还能检索图片、表格等多模态信息来生成答案。</li></ul><p>希望本文能帮助你全面理解 RAG，并为你在 AI 应用开发的道路上打开一扇新的大门。</p>]]></content>
    
    
    <summary type="html">深入浅出 RAG：原理、流程与代码实战</summary>
    
    
    
    <category term="智能" scheme="http://www.formeasy.cc/categories/%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="ollama" scheme="http://www.formeasy.cc/tags/ollama/"/>
    
  </entry>
  
  <entry>
    <title>使用WinSW把nginx做成windows服务</title>
    <link href="http://www.formeasy.cc/2025/09/17/Python/%E4%BD%BF%E7%94%A8WinSW%E6%8A%8Anginx%E5%81%9A%E6%88%90windows%E6%9C%8D%E5%8A%A1/"/>
    <id>http://www.formeasy.cc/2025/09/17/Python/%E4%BD%BF%E7%94%A8WinSW%E6%8A%8Anginx%E5%81%9A%E6%88%90windows%E6%9C%8D%E5%8A%A1/</id>
    <published>2025-09-17T05:58:13.000Z</published>
    <updated>2025-09-17T06:04:25.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-下载nginx"><a class="markdownIt-Anchor" href="#1-下载nginx"></a> 1. 下载nginx</h3><p><a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p><h3 id="2-下载win-sw"><a class="markdownIt-Anchor" href="#2-下载win-sw"></a> 2. 下载win sw</h3><p><a href="https://github.com/winsw/winsw/releases/tag/v2.11.0">https://github.com/winsw/winsw/releases/tag/v2.11.0</a>  下载.NET4.0版本，WinSW.NET4.exe。</p><h3 id="3-解压nignx压缩包并重命名文件夹为nginx"><a class="markdownIt-Anchor" href="#3-解压nignx压缩包并重命名文件夹为nginx"></a> 3. 解压nignx压缩包，并重命名文件夹为“nginx”。</h3><p>本例的nginx.exe完整路径为：D:\Soft\nginx\nginx.exe</p><h3 id="4-将下载的winswnet4exe-复制进-dsoftnginx"><a class="markdownIt-Anchor" href="#4-将下载的winswnet4exe-复制进-dsoftnginx"></a> 4. 将下载的WinSW.NET4.exe 复制进 D:\Soft\nginx\</h3><h3 id="5-在dsoftnginx新建一个名为winswnet4xml的xml文件内容如下"><a class="markdownIt-Anchor" href="#5-在dsoftnginx新建一个名为winswnet4xml的xml文件内容如下"></a> 5. 在D:\Soft\nginx\新建一个名为“WinSW.NET4.xml”的XML文件，内容如下：</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;service&gt; </span><br><span class="line"> &lt;!--服务名称--&gt;</span><br><span class="line">&lt;id&gt;nginxsvr&lt;/id&gt;</span><br><span class="line">  &lt;!--显示名称--&gt;</span><br><span class="line">&lt;name&gt;nginx-svr&lt;/name&gt;</span><br><span class="line"> &lt;!--描述--&gt;</span><br><span class="line">&lt;description&gt;自启动的 nginx&lt;/description&gt; </span><br><span class="line"> &lt;!--windows服务安装日志--&gt;</span><br><span class="line">&lt;logpath&gt;D:\Soft\nginx\log2&lt;/logpath&gt; </span><br><span class="line">&lt;logmode&gt;roll&lt;/logmode&gt; </span><br><span class="line">&lt;depend&gt;&lt;/depend&gt; </span><br><span class="line"> &lt;executable&gt;D:\Soft\nginx\nginx.exe&lt;/executable&gt; </span><br><span class="line"> &lt;stopexecutable&gt;D:\Soft\nginx\nginx.exe -s stop&lt;/stopexecutable&gt; </span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure><p>XML的路径根据实际情况修改。</p><h3 id="6-用命令安装并启动"><a class="markdownIt-Anchor" href="#6-用命令安装并启动"></a> 6. 用命令安装并启动：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\\Soft\\nginx\\WinSW.NET4.exe install</span><br><span class="line"></span><br><span class="line">NET START nginxsvr</span><br></pre></td></tr></table></figure><h3 id="7-如果需要卸载"><a class="markdownIt-Anchor" href="#7-如果需要卸载"></a> 7. 如果需要卸载 ：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NET STOP nginxsvr</span><br><span class="line"></span><br><span class="line">D:\\Soft\\nginx\\WinSW.NET4.exe uninstall</span><br></pre></td></tr></table></figure><p>可以保存为批处理，安装BAT：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;安装&quot;</span><br><span class="line">D:\Soft\nginx\WinSW.NET4.exe install</span><br><span class="line">echo &quot;启动名为nginxsvr的windows服务&quot;</span><br><span class="line">NET START nginxsvr</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>卸载BAT：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;一定要先停止后卸载，否则电脑需要重启&quot;</span><br><span class="line">echo &quot;停止名为nginxsvr的windows服务&quot;</span><br><span class="line">NET STOP nginxsvr</span><br><span class="line">D:\Soft\nginx\WinSW.NET4.exe uninstall</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>可运行 services.msc 来查看服务状态。</p>]]></content>
    
    
    <summary type="html">使用WinSW把nginx做成windows服务</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Python" scheme="http://www.formeasy.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使用NSSM将.exe程序安装成windows服务</title>
    <link href="http://www.formeasy.cc/2025/09/17/Python/%E4%BD%BF%E7%94%A8NSSM%E5%B0%86.exe%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%E6%88%90windows%E6%9C%8D%E5%8A%A1/"/>
    <id>http://www.formeasy.cc/2025/09/17/Python/%E4%BD%BF%E7%94%A8NSSM%E5%B0%86.exe%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%E6%88%90windows%E6%9C%8D%E5%8A%A1/</id>
    <published>2025-09-17T05:52:51.000Z</published>
    <updated>2025-09-17T05:57:47.134Z</updated>
    
    <content type="html"><![CDATA[<p>1、下载NSSM：<a href="https://nssm.cc/usage">NSSM - the Non-Sucking Service Manager</a></p><p><img src="2447777-20240506104400143-1336746940.png" alt="" /></p><p>2、方式一：cmd方式安装服务</p><p>将下载的压缩包解压，找到nssm.exe，以管理员身份打开cmd，在cmd中定位到nssm.exe所在路径，执行nssm install 服务名：</p><p><img src="2447777-20240506105204004-1853535886.png" alt="" /></p><p>按下enter键会自动弹出nssm的窗体：</p><p><img src="2447777-20240506105550887-1981089896.png" alt="" /></p><p>在Application-Application Path中选择你的可执行文件.exe，确认后会自动填入Startup directory，Service name处可以修改服务名</p><p>上方选项卡的Details中可以填入显示名称、描述、启动方式，一般默认是自动启动</p><p>填写完成后点击右下角的Install service即可。</p><p>3、方式二：批处理文件方式安装服务</p><p>将nssm.exe复制到要打包的程序文件夹中，再在同目录下新建三个txt文本，分别对应安装服务、关闭服务、卸载服务，将后缀名改为bat</p><ul><li>右键安装服务.bat-编辑：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">REM 创建服务</span><br><span class="line">echo off</span><br><span class="line">echo 即将开始采用nssm安装应用程序为windows服务，请确认以系统管理员身份运行</span><br><span class="line">set servicename=自定义服务名称</span><br><span class="line">REM %~dp0 为BAT脚本取当前系统目录命令,API_HOST.EXE为需要包装为服务的应用程序</span><br><span class="line">set app_path=&quot;%~dp0程序.exe&quot;</span><br><span class="line">set nssm_path=&quot;%~dp0nssm.exe&quot;</span><br><span class="line">REM 将NSSM复制至系统盘目录，或者 添加 windows 环境变量亦可达到目的</span><br><span class="line">set targetFolder=&quot;C:\windows\System32\nssm.exe&quot;</span><br><span class="line">REM 检查NSSM.exe文件是否存在</span><br><span class="line">echo 检查当前目录nssm.exe文件是否存在</span><br><span class="line">if not exist %nssm_path% (</span><br><span class="line">    echo %nssm_path% 不存在,请确认</span><br><span class="line">    pause </span><br><span class="line">    goto exitCode</span><br><span class="line"> )</span><br><span class="line">) </span><br><span class="line">echo %nssm_path% 存在，即将检查文件并复制</span><br><span class="line">REM 复制nssm</span><br><span class="line">if not exist %targetFolder% (</span><br><span class="line">    copy /y %nssm_path% %targetFolder%</span><br><span class="line">    echo 复制nssm至windows系统目录完成</span><br><span class="line">)</span><br><span class="line">echo 即将创建服务 %servicename%</span><br><span class="line">echo  ****************************************</span><br><span class="line"></span><br><span class="line">REM 判断service 是否存在，若存在，先停止，至删除</span><br><span class="line">echo 检查服务是否存在,存在则停止服务后删除，再安装</span><br><span class="line">sc query|find /i &quot;%servicename%&quot; &gt;nul 2&gt;nul</span><br><span class="line">if not errorlevel 1 (</span><br><span class="line">    echo 服务已存在，停止运行服务</span><br><span class="line">    echo stop %servicename%</span><br><span class="line">    REM NSSM停止服务命令：nssm stop &lt;ServiceName&gt;</span><br><span class="line">    nssm stop %servicename%    </span><br><span class="line">    echo 开始移除服务 %servicename%</span><br><span class="line">    echo remove service %servicename%</span><br><span class="line">    REM NSSM删除服务命令：nssm remove &lt;ServiceName&gt; confirm</span><br><span class="line">    REM 移除命令最后的 confirm 即表示无限弹窗确认,直接移除。</span><br><span class="line">    nssm remove %servicename% confirm</span><br><span class="line">    echo 移除服务完成</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">echo *********************************</span><br><span class="line">echo 开始创建服务 %servicename%</span><br><span class="line">REM NSSM命令：nssm install &lt;服务名&gt; &lt;服务需要执行的程序&gt;</span><br><span class="line">nssm install %servicename% %app_path%</span><br><span class="line">echo 开始设置服务信息</span><br><span class="line">echo set service property</span><br><span class="line">echo 设置服务显示名称</span><br><span class="line">REM nssm set &lt;ServiceName&gt; DisplayName &lt;ServiceName&gt;</span><br><span class="line">nssm set %servicename% DisplayName %servicename%</span><br><span class="line">echo 设置服务描述</span><br><span class="line">REM nssm set &lt;ServiceName&gt; Description &lt;ServiceName&gt;</span><br><span class="line">nssm set %servicename% Description xxx控制系统 </span><br><span class="line">echo 设置服务启动方式为：自动</span><br><span class="line">nssm set %servicename% Start SERVICE_AUTO_START</span><br><span class="line">echo *********************************</span><br><span class="line">echo 启动服务 %servicename%</span><br><span class="line">echo start service %servicename%</span><br><span class="line">nssm start %servicename%</span><br><span class="line">echo 服务创建并启动完成</span><br><span class="line"></span><br><span class="line">:exitCode</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>set servicename=自定义服务名称，这里的自定义服务名称改为你想要的名称<br />set app_path=“%~dp0程序.exe”，这里的程序.exe改为你的可执行文件名<br />%~dp0代表的是当前目录</p><ul><li>右键关闭服务.bat-编辑：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off </span><br><span class="line">@title 关闭服务</span><br><span class="line">echo= 开始关闭服务！  </span><br><span class="line">@echo off  </span><br><span class="line">@sc stop 自定义服务名称</span><br><span class="line">@echo off  </span><br><span class="line">echo= 关闭服务结束！  </span><br><span class="line">@pause</span><br></pre></td></tr></table></figure><ul><li>右键卸载服务.bat-编辑：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@echo off </span><br><span class="line">@title 删除服务</span><br><span class="line">echo= 开始删除服务！  </span><br><span class="line">@echo off  </span><br><span class="line">nssm stop 自定义服务名称</span><br><span class="line">nssm remove 自定义服务名称 confirm    </span><br><span class="line">@echo off  </span><br><span class="line">echo= 删除完成！  </span><br><span class="line">@pause</span><br></pre></td></tr></table></figure><ul><li>上述的bat文件都需要用管理员身份运行，可以为bat文件创建快捷方式，在快捷方式上右键属性-快捷方式-高级-勾选用管理员身份运行</li></ul><p><img src="2447777-20240506103959941-479814109.png" alt="" /></p><ul><li>双击快捷方式执行即可。</li></ul><p>4、补充</p><p>① 有园友说也可以用WinSW，找了下资料，还没试过，仅供参考：</p><p>② 如果有时候显示服务安装成功，但在服务管理器又找不到，可以看看是不是被杀毒软件拦截了</p>]]></content>
    
    
    <summary type="html">使用NSSM将.exe程序安装成windows服务</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Python" scheme="http://www.formeasy.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python打包flask服务成exe文件并快速注册成windows服务</title>
    <link href="http://www.formeasy.cc/2025/09/17/Python/python%E6%89%93%E5%8C%85flask%E6%9C%8D%E5%8A%A1%E6%88%90exe%E6%96%87%E4%BB%B6%E5%B9%B6%E5%BF%AB%E9%80%9F%E6%B3%A8%E5%86%8C%E6%88%90windows%E6%9C%8D%E5%8A%A1/"/>
    <id>http://www.formeasy.cc/2025/09/17/Python/python%E6%89%93%E5%8C%85flask%E6%9C%8D%E5%8A%A1%E6%88%90exe%E6%96%87%E4%BB%B6%E5%B9%B6%E5%BF%AB%E9%80%9F%E6%B3%A8%E5%86%8C%E6%88%90windows%E6%9C%8D%E5%8A%A1/</id>
    <published>2025-09-17T05:46:01.000Z</published>
    <updated>2025-09-17T05:52:22.677Z</updated>
    
    <content type="html"><![CDATA[<p>由于相关业务问题，需要在windows环境中开启多个flask服务，为了方便管理各个flask服务，需要进行注册成windows服务，在windows服务中进行自动开启状态。下面将分享在实际过程中的方法，避免小伙伴们遇到同样的问题。</p><h4 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1.安装flask、pyinstaller</span><br><span class="line"># 2.下载nssm部署windows服务执行文件</span><br><span class="line"># 3.准备flask开发的案例代码</span><br><span class="line"># 4.使用pyinstaller将flask服务进行打包</span><br><span class="line"># 5.解压nssm文件，指定打包文件和服务名称</span><br><span class="line"># 6.测试最终结果是否正确</span><br></pre></td></tr></table></figure><h3 id="1准备工作"><a class="markdownIt-Anchor" href="#1准备工作"></a> 1.准备工作</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python环境：3.6.8</span><br><span class="line">windows环境：windows10</span><br></pre></td></tr></table></figure><p>安装相关包如下，准备打包python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.安装flask框架</span></span><br><span class="line">pip install flask</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2.安装pyinstaller包</span></span><br><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure><p>下载nssm.zip文件，准备在windows上安装exe文件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 下载地址</span><br><span class="line">http://www.nssm.cc/release/nssm-2.24.zip</span><br></pre></td></tr></table></figure><h3 id="2开始实际操作"><a class="markdownIt-Anchor" href="#2开始实际操作"></a> 2.开始实际操作</h3><p>flask代码开发，以下是个demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request,jsonify</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查询模型训练状态</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/modelstatus&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_status</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, <span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;false&#x27;</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;hello&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;不支持该请求&#x27;</span>&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">9004</span>)</span><br></pre></td></tr></table></figure><h3 id="3开始打包"><a class="markdownIt-Anchor" href="#3开始打包"></a> 3.开始打包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 说明：(我在执行 pyinstaller -w admin.py时,打包过程中控制台正常没报错，打包完成以后进行dist文件，找到admin.exe双击启动时，提示创库显示执行失败。因为想程序占着控制台，所以执行的参数为 -w)</span></span><br><span class="line"><span class="comment"># 最终执行flask服务打包</span></span><br><span class="line">pyinstaller -F admin.py</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 一下就是程序打包以后文件目录</span></span><br></pre></td></tr></table></figure><p><img src="2b6f6336f903a8e1caad04fd7ead53a0.png" alt="" /></p><h3 id="4开始进行注册windows服务"><a class="markdownIt-Anchor" href="#4开始进行注册windows服务"></a> 4.开始进行注册windows服务</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.在cmd中进入nssm中的目录，然后进行命令</span><br><span class="line">2. nssm install aiweb(服务名)</span><br><span class="line">3. 选择Application path按钮将pyinstaller打包后的exe文件选择过来。</span><br><span class="line">4.点击installer service按钮，则提示成功，此时去windows服务中查看服务即可。</span><br></pre></td></tr></table></figure><p><img src="df25be88d6135abc2c6453db5c137749.png" alt="" /></p><p><img src="fa73497bd830729f519915d78374742a.png" alt="" /></p><p><img src="5f42a37870613fa32e2d783b6746cb94.png" alt="" /></p><h3 id="5测试windows服务"><a class="markdownIt-Anchor" href="#5测试windows服务"></a> 5.测试windows服务</h3><p>在服务中点击启动按钮，在浏览器中输入ip地址和端口号，如图：</p><p><img src="69ad754b7ea7fa035dbba64b3e2621d3.png" alt="" /></p><p><img src="b8aa7972f31ababda44f878616cf3694.png" alt="" /></p><p>最后大功告成，此方法可以将flask服务、爬虫服务都可以注册成windows服务，开机自启动。</p>]]></content>
    
    
    <summary type="html">python打包flask服务成exe文件并快速注册成windows服务</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Python" scheme="http://www.formeasy.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Windows上将Eex部署成为服务WinSW和NSSM</title>
    <link href="http://www.formeasy.cc/2025/09/14/Python/Windows%E4%B8%8A%E5%B0%86Eex%E9%83%A8%E7%BD%B2%E6%88%90%E4%B8%BA%E6%9C%8D%E5%8A%A1WinSW%E5%92%8CNSSM/"/>
    <id>http://www.formeasy.cc/2025/09/14/Python/Windows%E4%B8%8A%E5%B0%86Eex%E9%83%A8%E7%BD%B2%E6%88%90%E4%B8%BA%E6%9C%8D%E5%8A%A1WinSW%E5%92%8CNSSM/</id>
    <published>2025-09-14T14:14:35.000Z</published>
    <updated>2025-09-14T14:21:33.768Z</updated>
    
    <content type="html"><![CDATA[<p>使用Windows，经常需要将带界面的Windows 应用、exe可执行程序、bat批处理文件变为Windows服务，以便于后台运行，支持开启重启、进程保护等功能。<br />有众多的工具支持将exe文件封装为Windows服务，常用的工具包括：<br />Sc.exe/NSSM/WinSW/Shawl/AlwaysUp/FireDaemon</p><h3 id="scexe"><a class="markdownIt-Anchor" href="#scexe"></a> Sc.exe</h3><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/services/controlling-a-service-using-sc">https://learn.microsoft.com/zh-cn/windows/win32/services/controlling-a-service-using-sc</a></p><p>Windows系统内置命令，需要熟悉命令行操作，对新手不友好</p><p>以前还有SRVANY.exe，微软官方在 Windows 10/11 上已经不再提供支持，因此不推荐。</p><h3 id="nssm"><a class="markdownIt-Anchor" href="#nssm"></a> NSSM</h3><p><a href="https://nssm.cc/builds">https://nssm.cc/builds</a></p><p><a href="https://github.com/kirillkovalenko/nssm">https://github.com/kirillkovalenko/nssm</a></p><p>开源，功能强大，但从2017年以后未再更新维护</p><h3 id="winsw"><a class="markdownIt-Anchor" href="#winsw"></a> Winsw</h3><p><a href="https://github.com/winsw/winsw">https://github.com/winsw/winsw</a></p><p>开源，功能强大但配置较为复杂，2023年后未再更新维护</p><h3 id="shawl"><a class="markdownIt-Anchor" href="#shawl"></a> Shawl</h3><p><a href="https://github.com/mtkennerly/shawl">https://github.com/mtkennerly/shawl</a></p><p>开源，功能相对于NSSM、Winsw弱一些，目前还在更新维护</p><h3 id="alwaysup"><a class="markdownIt-Anchor" href="#alwaysup"></a> AlwaysUp</h3><p><a href="https://www.coretechnologies.com/products/AlwaysUp/">https://www.coretechnologies.com/products/AlwaysUp/</a></p><p>收费商业软件</p><h3 id="firedaemon"><a class="markdownIt-Anchor" href="#firedaemon"></a> FireDaemon</h3><p><a href="https://www.firedaemon.com/">https://www.firedaemon.com/</a></p><p>收费商业软件</p><p>可以看出，要将exe程序变为Windows服务，免费方案包括Sc.exe，NSSM，Winsw，Shawl，但各有优劣。</p><p>下面介绍其中的两款WinSW和NSSM，在Windows上使用这两款式软件可以快将EXE部署成为服务（为什么不直接写服务，我个人喜欢EXE调试测试方便OK之后 再部署成为服务这样方便）</p><p><strong>NSSM（C++）</strong></p><p>官方 <a href="http://www.nssm.cc/">http://www.nssm.cc/</a> 下载只有一个绿色EXE 使用方法命令行下 NSSM.exe install (对应移除使用 remove</p><p><img src="624386-20250122192200962-1765742953.png" alt="" /></p><p>在这里就可以选择你想要的EXE 且起对应的服务的名字（移除的时候需要这个名字）</p><p>如果是移除 使用 NSSM.exe Remove 弹出如下界面，填写名字移除</p><p><img src="624386-20250122191214948-2065923795.png" alt="" /></p><p><strong>WinSW (C#)</strong></p><p><strong><a href="https://github.com/winsw/winsw/releases">https://github.com/winsw/winsw/releases</a> github上就有</strong></p><p><strong>使用windsw 需要有对应的配置文件，如下面的xml文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 服务ID名称（唯一） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>Myserver<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 服务显示名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Myserver<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 服务的描述信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Minio文件存储服务器<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 可设置环境变量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span> <span class="attr">name</span>=<span class="string">&quot;HOME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%BASE%&quot;</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 要执行的可执行文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executable</span>&gt;</span>%BASE%\minio.exe<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 可执行文件传递的参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arguments</span>&gt;</span>server &quot;%BASE%\data&quot;<span class="tag">&lt;/<span class="name">arguments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;logmode&gt;rotate&lt;/logmode&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logpath</span>&gt;</span>%BASE%\logs<span class="tag">&lt;/<span class="name">logpath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log</span> <span class="attr">mode</span>=<span class="string">&quot;roll-by-size-time&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sizeThreshold</span>&gt;</span>10240<span class="tag">&lt;/<span class="name">sizeThreshold</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>yyyyMMdd<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">autoRollAtTime</span>&gt;</span>00:00:00<span class="tag">&lt;/<span class="name">autoRollAtTime</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">zipOlderThanNumDays</span>&gt;</span>5<span class="tag">&lt;/<span class="name">zipOlderThanNumDays</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">zipDateFormat</span>&gt;</span>yyyyMMdd<span class="tag">&lt;/<span class="name">zipDateFormat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">log</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>管理员身份运行CMD并定位到WinSW的安装目录，执行安装命令WinSWr install，此时我们的Windows服务列表中就多了一个叫Minio-Server的服务了</p><p>WinSW的各个命令</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>install</td><td>安装服务</td></tr><tr><td>uninstall</td><td>卸载服务</td></tr><tr><td>start</td><td>启动服务</td></tr><tr><td>stop</td><td>停止服务</td></tr><tr><td>restart</td><td>重启服务</td></tr><tr><td>status</td><td>检查服务状态</td></tr><tr><td>refresh</td><td>刷新服务属性而不是重新安装</td></tr><tr><td>customize</td><td>--</td></tr></tbody></table><p><img src="624386-20250122192046755-1088983727.jpg" alt="" /></p><p>配合这两图片应该基本使用方式 记录完了</p><p>从上面来看我个人喜欢有界面设置的NSSM</p>]]></content>
    
    
    <summary type="html">Windows上将Eex部署成为服务WinSW和NSSM</summary>
    
    
    
    <category term="技术" scheme="http://www.formeasy.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Python" scheme="http://www.formeasy.cc/tags/Python/"/>
    
  </entry>
  
</feed>
